<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · MIRT.jl</title><meta name="title" content="Methods · MIRT.jl"/><meta property="og:title" content="Methods · MIRT.jl"/><meta property="twitter:title" content="Methods · MIRT.jl"/><meta name="description" content="Documentation for MIRT.jl."/><meta property="og:description" content="Documentation for MIRT.jl."/><meta property="twitter:description" content="Documentation for MIRT.jl."/><meta property="og:url" content="https://JeffFessler.github.io/MIRT.jl/stable/methods/"/><meta property="twitter:url" content="https://JeffFessler.github.io/MIRT.jl/stable/methods/"/><link rel="canonical" href="https://JeffFessler.github.io/MIRT.jl/stable/methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MIRT.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MIRT.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Methods-list"><span>Methods list</span></a></li><li><a class="tocitem" href="#Methods-usage"><span>Methods usage</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/1-mirt/">MIRT overview</a></li><li><a class="tocitem" href="../generated/examples/2-nufft/">NUFFT</a></li><li><a class="tocitem" href="../generated/examples/3-ls-mm/">Line search MM</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JeffFessler/MIRT.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JeffFessler/MIRT.jl/blob/main/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Methods-list"><a class="docs-heading-anchor" href="#Methods-list">Methods list</a><a id="Methods-list-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-list" title="Permalink"></a></h2><ul><li><a href="#MIRT.MIRT"><code>MIRT.MIRT</code></a></li><li><a href="#MIRT.LineSearchMM"><code>MIRT.LineSearchMM</code></a></li><li><a href="#MIRT.LineSearchMM-Union{Tuple{Tw}, Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}}} where Tw&lt;:MIRT.LineSearchMMWork"><code>MIRT.LineSearchMM</code></a></li><li><a href="#MIRT.LineSearchMMWork"><code>MIRT.LineSearchMMWork</code></a></li><li><a href="#MIRT.Afft-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{Tw}, Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Any}} where {D, Tw&lt;:Number}"><code>MIRT.Afft</code></a></li><li><a href="#MIRT.Afft-Union{Tuple{AbstractArray{&lt;:Bool, D}}, Tuple{Tw}, Tuple{D}} where {D, Tw&lt;:Number}"><code>MIRT.Afft</code></a></li><li><a href="#MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.Anufft</code></a></li><li><a href="#MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}"><code>MIRT.Aodwt</code></a></li><li><a href="#MIRT.Asense-Union{Tuple{Tw}, Tuple{D}, Tuple{AbstractArray{&lt;:Bool, D}, Vector{&lt;:AbstractArray{&lt;:Number}}}} where {D, Tw&lt;:Number}"><code>MIRT.Asense</code></a></li><li><a href="#MIRT._show_struct-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Any}"><code>MIRT._show_struct</code></a></li><li><a href="#MIRT.caller_name-Tuple{}"><code>MIRT.caller_name</code></a></li><li><a href="#MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.diff_adj</code></a></li><li><a href="#MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D"><code>MIRT.diff_forw</code></a></li><li><a href="#MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D"><code>MIRT.diff_map</code></a></li><li><a href="#MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}"><code>MIRT.diffl</code></a></li><li><a href="#MIRT.diffl-Tuple{AbstractArray, Int64}"><code>MIRT.diffl</code></a></li><li><a href="#MIRT.diffl-Tuple{AbstractArray}"><code>MIRT.diffl</code></a></li><li><a href="#MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}"><code>MIRT.diffl!</code></a></li><li><a href="#MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}"><code>MIRT.diffl!</code></a></li><li><a href="#MIRT.diffl_adj-Tuple{AbstractArray, Int64}"><code>MIRT.diffl_adj</code></a></li><li><a href="#MIRT.diffl_adj-Tuple{AbstractArray}"><code>MIRT.diffl_adj</code></a></li><li><a href="#MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}"><code>MIRT.diffl_adj</code></a></li><li><a href="#MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}"><code>MIRT.diffl_adj!</code></a></li><li><a href="#MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}"><code>MIRT.diffl_adj!</code></a></li><li><a href="#MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D"><code>MIRT.diffl_map</code></a></li><li><a href="#MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}"><code>MIRT.downsample1</code></a></li><li><a href="#MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}"><code>MIRT.downsample2</code></a></li><li><a href="#MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}"><code>MIRT.downsample3</code></a></li><li><a href="#MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}"><code>MIRT.downsample_dim1</code></a></li><li><a href="#MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}"><code>MIRT.dtft</code></a></li><li><a href="#MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}"><code>MIRT.dtft</code></a></li><li><a href="#MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_adj</code></a></li><li><a href="#MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}"><code>MIRT.dtft_adj</code></a></li><li><a href="#MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_init</code></a></li><li><a href="#MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}"><code>MIRT.dtft_init</code></a></li><li><a href="#MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number"><code>MIRT.embed</code></a></li><li><a href="#MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.embed</code></a></li><li><a href="#MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.embed!</code></a></li><li><a href="#MIRT.eql_root-Tuple{Real, Real, Real}"><code>MIRT.eql_root</code></a></li><li><a href="#MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>MIRT.exp_mult</code></a></li><li><a href="#MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>MIRT.exp_xform</code></a></li><li><a href="#MIRT.genkspace-NTuple{8, Any}"><code>MIRT.genkspace</code></a></li><li><a href="#MIRT.genspi-Tuple{Any, Any}"><code>MIRT.genspi</code></a></li><li><a href="#MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.getindex!</code></a></li><li><a href="#MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}"><code>MIRT.interp1</code></a></li><li><a href="#MIRT.ir_dump-Tuple{Any}"><code>MIRT.ir_dump</code></a></li><li><a href="#MIRT.ir_load_brainweb_t1_256-Tuple{}"><code>MIRT.ir_load_brainweb_t1_256</code></a></li><li><a href="#MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}"><code>MIRT.ir_mri_coil_compress</code></a></li><li><a href="#MIRT.ir_mri_kspace_ga_radial-Tuple{}"><code>MIRT.ir_mri_kspace_ga_radial</code></a></li><li><a href="#MIRT.ir_mri_sensemap_sim-Tuple{}"><code>MIRT.ir_mri_sensemap_sim</code></a></li><li><a href="#MIRT.ir_mri_sensemap_sim-Tuple{Symbol}"><code>MIRT.ir_mri_sensemap_sim</code></a></li><li><a href="#MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}"><code>MIRT.ir_mri_sensemap_sim</code></a></li><li><a href="#MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}"><code>MIRT.ir_mri_sensemap_sim_do</code></a></li><li><a href="#MIRT.ir_mri_smap1-NTuple{4, Any}"><code>MIRT.ir_mri_smap1</code></a></li><li><a href="#MIRT.ir_mri_smap_r-Tuple{Any, Any}"><code>MIRT.ir_mri_smap_r</code></a></li><li><a href="#MIRT.jinc-Tuple{Real}"><code>MIRT.jinc</code></a></li><li><a href="#MIRT.line_search_mm-Tuple"><code>MIRT.line_search_mm</code></a></li><li><a href="#MIRT.make_dot_curvf-Union{Tuple{Tw}, Tuple{Tx}, Tuple{Function, AbstractArray{Tx}}, Tuple{Function, AbstractArray{Tx}, Type{&lt;:Number}}} where {Tx&lt;:Number, Tw&lt;:Number}"><code>MIRT.make_dot_curvf</code></a></li><li><a href="#MIRT.make_dot_gradf-Union{Tuple{Tw}, Tuple{Tx}, Tuple{Function, AbstractArray{Tx}}, Tuple{Function, AbstractArray{Tx}, Type{&lt;:Number}}} where {Tx&lt;:Number, Tw&lt;:Number}"><code>MIRT.make_dot_gradf</code></a></li><li><a href="#MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.map_many</code></a></li><li><a href="#MIRT.mask_or-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_or</code></a></li><li><a href="#MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_outline</code></a></li><li><a href="#MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.maskit</code></a></li><li><a href="#MIRT.max_percent_diff-Tuple{Any, Any}"><code>MIRT.max_percent_diff</code></a></li><li><a href="#MIRT.mri_kspace_spiral-Tuple{}"><code>MIRT.mri_kspace_spiral</code></a></li><li><a href="#MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D"><code>MIRT.mri_trajectory</code></a></li><li><a href="#MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring"><code>MIRT.mri_trajectory_gads</code></a></li><li><a href="#MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}"><code>MIRT.mri_trajectory_radial</code></a></li><li><a href="#MIRT.mri_trajectory_rosette3-Tuple{Any, Any}"><code>MIRT.mri_trajectory_rosette3</code></a></li><li><a href="#MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a></li><li><a href="#MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a></li><li><a href="#MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}"><code>MIRT.nufft_eltype</code></a></li><li><a href="#MIRT.nufft_errors-Tuple{}"><code>MIRT.nufft_errors</code></a></li><li><a href="#MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.nufft_init</code></a></li><li><a href="#MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.nufft_init</code></a></li><li><a href="#MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>MIRT.nufft_typer</code></a></li><li><a href="#MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ogm_ls</code></a></li><li><a href="#MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}"><code>MIRT.ogm_ls</code></a></li><li><a href="#MIRT.pogm_restart-Tuple{Any, Function, Function, Real}"><code>MIRT.pogm_restart</code></a></li><li><a href="#MIRT.poweriter-Tuple{Any}"><code>MIRT.poweriter</code></a></li><li><a href="#MIRT.rect-Tuple{Real}"><code>MIRT.rect</code></a></li><li><a href="#MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}"><code>MIRT.reverser</code></a></li><li><a href="#MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}"><code>MIRT.rmsd100</code></a></li><li><a href="#MIRT.rotate2d-Tuple{Any, Any, Any}"><code>MIRT.rotate2d</code></a></li><li><a href="#MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}"><code>MIRT.snr2sigma</code></a></li><li><a href="#MIRT.@shows-Tuple{Any}"><code>MIRT.@shows</code></a></li></ul><h2 id="Methods-usage"><a class="docs-heading-anchor" href="#Methods-usage">Methods usage</a><a id="Methods-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-usage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.MIRT" href="#MIRT.MIRT"><code>MIRT.MIRT</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MIRT is the Michigan Image Reconstruction Toolbox</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/MIRT.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.LineSearchMM" href="#MIRT.LineSearchMM"><code>MIRT.LineSearchMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LineSearchMM{...}</code></pre><p>Mutable struct for MM-based line searches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ls-mm.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.LineSearchMM-Union{Tuple{Tw}, Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}}} where Tw&lt;:MIRT.LineSearchMMWork" href="#MIRT.LineSearchMM-Union{Tuple{Tw}, Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}}} where Tw&lt;:MIRT.LineSearchMMWork"><code>MIRT.LineSearchMM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LineSearchMM(gradf, curvf, u, v; α0 ...)
LineSearchMM(u, v, dot_gradf, dot_curvf; α0 ...)</code></pre><p>Construct iterator for line-search based on majorize-minimize (MM) approach for a general family of 1D cost functions of the form <span>$h(α) = \sum_{j=1}^J f_j(u_j + α v_j)$</span> where each function <span>$f_j(t)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(t;s) = f_j(t) + \nabla f_j(s) (t - s) + 1/2 \|t - s\|^2_{C_j(s)}\]</p><p>where <span>$C_j(⋅)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>Each function <span>$f_j : \mathcal{X}_j ↦ \mathbb{R}$</span> where conceptually <span>$\mathcal{X}_j ⊆ \mathbb{R}^{M_j}$</span>, but we allow more general domains.</p><p>There are two outer constructors (based on the positional arguments):</p><ul><li>The simple way (not type stable) provides<ul><li><code>gradf</code> vector of <span>$J$</span> functions return gradients of <span>$f_1,…,f_J$</span></li><li><code>curvf</code> vector of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar or a vector of curvature values for each element of <span>$z$</span></li></ul></li><li>The fancier way (type stable) provides<ul><li><code>dot_gradf::AbstractVector{&lt;:Function} = make_dot_gradf.(gradf)</code> See <code>make_dot_gradf</code>.</li><li><code>dot_curvf::AbstractVector{&lt;:Function} = make_dot_curvf.(curvf)</code> See <code>make_dot_curvf</code>.</li></ul></li></ul><p><strong>in</strong></p><ul><li><code>u</code> vector of <span>$J$</span> arrays <span>$u_1,…,u_J$</span> (typically vectors)</li><li><code>v</code> vector of <span>$J$</span> arrays <span>$v_1,…,v_J$</span> (typically vectors)</li></ul><p>We require <code>axes(u_j) == axes(v_j)</code> for all <span>$j=1,…,J$</span>.</p><p><strong>option</strong></p><ul><li><code>α0::Real = 0f0</code> initial guess for step size</li><li><code>ninner::Int = 5</code> # max number of inner iterations of MM line search</li><li><code>work = LineSearchMMWork(u, v, α)</code> pre-allocated work space for <span>$u_j+α v_j$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ls-mm.jl#L108-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.LineSearchMMWork" href="#MIRT.LineSearchMMWork"><code>MIRT.LineSearchMMWork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LineSearchMMWork{Tz &lt;: AbstractVector{&lt;:AbstractArray}}</code></pre><p>Workspace for storing <span>$z_j = u_j + α v_j$</span> in MM-based line search.</p><p>If all of those <span>$z_j$</span> arrays had the same <code>eltype</code>, then we could save memory by allocating just the longest vector needed. But for Unitful data they could have different <code>eltype</code>s and <code>size</code>s, which would require a lot of <code>reinterpret</code> and <code>reshape</code> to handle. So we just allocate separate work arrays for each <span>$j$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ls-mm.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.Afft-Union{Tuple{AbstractArray{&lt;:Bool, D}}, Tuple{Tw}, Tuple{D}} where {D, Tw&lt;:Number}" href="#MIRT.Afft-Union{Tuple{AbstractArray{&lt;:Bool, D}}, Tuple{Tw}, Tuple{D}} where {D, Tw&lt;:Number}"><code>MIRT.Afft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A = Afft(samp::AbstractArray{Bool} ; T, dims, operator, work, ...)</code></pre><p>Make a <code>LinearMapAO</code> operator object for (under-sampled) FFT, of type <code>T</code>, using given sampling pattern <code>samp</code>. Especially for compressed sensing MRI with Cartesian sampling.</p><p>Option:</p><ul><li><code>T::Type = ComplexF32</code></li><li><code>dims = 1:D</code> apply fft/bfft only along these dimensions</li><li><code>fft_forward::Bool = true</code> Use <code>false</code> to have <code>bfft!</code> in forward model.</li><li><code>operator::Bool = true</code> set to <code>false</code> to return a <code>LinearMapAM</code></li><li><code>work::AbstractArray</code> work space for in-place fft operations</li><li>remaining arguments are passed to <code>plan_fft</code></li></ul><p><strong>Output</strong></p><p>Returns a <code>LinearMapsAA.LinearMapA[M|O]</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/system/Afft.jl#L104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.Afft-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{Tw}, Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Any}} where {D, Tw&lt;:Number}" href="#MIRT.Afft-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{Tw}, Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Any}} where {D, Tw&lt;:Number}"><code>MIRT.Afft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A = Afft(xdim::Dims, fdim ; T, operator, unitary, work, ...)</code></pre><p>Make a <code>&lt;:LinearMapAX</code> operator object for the FFT of an array of size <code>xdim</code>, along dimensions <code>fdim</code>, of type <code>T</code>.</p><p>In:</p><ul><li><code>xdim::Dims{D}</code> array size</li><li><code>fdim = 1:D</code> apply fft/bfft only along these dimensions</li></ul><p>Option:</p><ul><li><code>T::Type = ComplexF32</code></li><li><code>operator::Bool = true</code> return a <code>LinearMapAO</code> set to <code>false</code> to return a <code>LinearMapAM</code></li><li><code>unitary::Bool = false</code> set to <code>true</code> for unitary DFT</li><li><code>work::AbstractArray</code> work space for in-place fft operations</li><li>remaining arguments are passed to <code>plan_fft</code></li></ul><p><strong>Output</strong></p><p>Returns a <code>LinearMapsAA.LinearMapA[M|O]</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/system/Afft.jl#L16-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}" href="#MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.Anufft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Anufft(ω, N ; kwargs ...)</code></pre><p>Make a <code>LinearMapAO</code> object of size <code>length(ω) × prod(N)</code>. See <code>nufft_init</code> for options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/nufft.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}" href="#MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}"><code>MIRT.Aodwt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A, levels, mfun = Aodwt(dims ; level::Int=3, wt=wavelet(WT.haar))</code></pre><p>Create orthogonal discrete wavelet transform (ODWT) <code>LinearMapAA</code></p><p><strong>in</strong></p><ul><li><code>dims::Dims</code> tuple of dimensions</li></ul><p><strong>option</strong></p><ul><li><code>level::Int</code> # of levels; default 3</li><li><code>wt</code> wavelet transform type (see <code>Wavelets</code> package); default Haar</li><li><code>operator::Bool=true</code> default to <code>LinearMapAO</code></li><li><code>T::Type</code> : <code>Float32</code> by default; use <code>ComplexF32</code> if needed</li></ul><p><strong>out</strong></p><ul><li><code>A</code> a <code>LinearMapAX</code> object</li><li><code>scales</code> array of size <code>dims</code> showing the scale of each coefficient</li></ul><p>which is useful when imposing scale-dependent regularization</p><ul><li><code>mfun</code> convenience function for A*X when X is a Matrix or Array (not vector)</li></ul><p>2019-02-23 Jeff Fessler, University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/Aodwt.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.Asense-Union{Tuple{Tw}, Tuple{D}, Tuple{AbstractArray{&lt;:Bool, D}, Vector{&lt;:AbstractArray{&lt;:Number}}}} where {D, Tw&lt;:Number}" href="#MIRT.Asense-Union{Tuple{Tw}, Tuple{D}, Tuple{AbstractArray{&lt;:Bool, D}, Vector{&lt;:AbstractArray{&lt;:Number}}}} where {D, Tw&lt;:Number}"><code>MIRT.Asense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Asense(samp, smaps; T)</code></pre><p>Construct a MRI encoding operator model for <code>D</code>-dimensional Cartesian sampling pattern <code>samp</code> and coil sensitivity maps <code>smaps</code>.</p><p>The input <code>smaps</code> can either be a <code>D+1</code> dimensional array of size <code>(size(samp)..., ncoil)</code>, or a Vector of <code>ncoil</code> arrays of size <code>size(samp)</code>.</p><p><strong>Input</strong></p><ul><li><code>samp::AbstractArray{&lt;:Bool}</code> <code>D</code>-dimensional sampling pattern.</li><li><code>smaps::Vector{&lt;:AbstractArray{&lt;:Number}}</code> or <code>AbstractArray{&lt;:Number}</code></li></ul><p><strong>Option</strong></p><ul><li><code>T::Type = ComplexF32</code></li><li><code>dims = 1:D</code> apply fft/bfft only along these dimensions</li><li><code>fft_forward::Bool = true</code> Use <code>false</code> to have <code>bfft!</code> in forward model.</li><li><code>unitary::Bool = false</code> set to <code>true</code> for unitary DFT</li><li>remaining arguments are passed to <code>plan_fft</code></li></ul><p><strong>Output</strong></p><p>Returns a <code>LinearMapsAA.LinearMapAO</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/system/Asense.jl#L13-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT._show_struct-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Any}" href="#MIRT._show_struct-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Any}"><code>MIRT._show_struct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_show_struct(io::IO, ::MIME&quot;text/plain&quot;, st::Any)</code></pre><p>Informative way to show fields of a struct (composite type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/io/shows.jl#L56-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.caller_name-Tuple{}" href="#MIRT.caller_name-Tuple{}"><code>MIRT.caller_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">caller_name() or caller_name(;level=4)</code></pre><p>Return &quot;filename line fun():&quot; as a string to describe where this function was called.</p><p>Stack levels:</p><ul><li>1: #caller_name</li><li>2: caller_name()</li><li>3: function that invoked caller()</li><li>4: the calling function we want to return</li></ul><p>Hence the default level is 4, but we increment it by one in case user says <code>@show caller_name()</code> in which case stack[3] is a macro expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/io/caller_name.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.diff_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Z = diff_adj(dx, N::Dims{D} ; dims = 1:D)</code></pre><p>Adjoint of finite differences of arrays along one or more dimensions. By default performs the same operations as <span>$vec(Z) = [(I_{N_d} \otimes \cdots \otimes D_{N_1}); \dots; (D_{N_d} \otimes \cdots \otimes I_{N_1})]&#39; * d$</span> where <code>D_N</code> denotes the <code>N-1 × N</code> 1D finite difference matrix and <code>⊗</code> denotes the Kronecker product, but does it efficiently without using <code>spdiagm</code> (or any <code>SparseArrays</code> function).</p><p><strong>in</strong></p><ul><li><code>dx</code> vector of typical length <code>N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1</code></li><li><code>N::Dims</code> desired output size</li></ul><p><strong>option</strong></p><ul><li><code>dims</code> dimension(s) for performing adjoint finite differences; default <code>1:ndims(X)</code></li></ul><p><strong>out</strong></p><ul><li><code>Z</code> <code>N_1 × ... × N_d</code> array by default</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffs.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D" href="#MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D"><code>MIRT.diff_forw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = diff_forw(X ; dims = 1:ndims(X))</code></pre><p>Finite differences along one or more dimensions of an array, e.g., for anisotropic TV regularization.</p><p>By default performs the same operations as <span>$d = [(I_{N_d} \otimes \cdots \otimes D_{N_1}); \dots; (D_{N_d} \otimes \cdots \otimes I_{N_1})] vec(X)$</span> where <span>$D_N$</span> denotes the <code>N-1 × N</code> 1D finite difference matrix and <code>⊗</code> denotes the Kronecker product, but does it efficiently without using <code>spdiagm</code> (or any <code>SparseArrays</code> function).</p><p>Input dimension <code>N</code> must exceed <code>1</code> for each dimension specified by <code>dims</code>.</p><p><strong>in</strong></p><ul><li><code>X</code> <code>N_1 × ... × N_d</code> array (typically an N-D image).</li></ul><p><strong>option</strong></p><ul><li><code>dims</code> dimension(s) for performing finite differences; default <code>1:ndims(X)</code></li></ul><p>must have unique elements and be a nonempty subset of <code>1:ndims(X)</code></p><p><strong>out</strong></p><ul><li><code>d</code> vector of default length <code>N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffs.jl#L35-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D" href="#MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D"><code>MIRT.diff_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = diff_map(N::Dims{D} ; dims = 1:D)</code></pre><p><strong>in</strong></p><ul><li><code>N::Dims</code> image size</li></ul><p><strong>out</strong></p><ul><li><code>T</code> <code>LinearMapAA</code> object for computing finite differences via <code>T*x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffs.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}" href="#MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}"><code>MIRT.diffl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl!(g::AbstractArray, x::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>When <code>x</code> is a <code>N</code>-dimensional array, the <code>i</code>th slice of the <code>g</code> array (along its last dimension) is the <code>diffl!</code> of <code>x</code> along <code>dims[i]</code>. This is useful for total variation (TV) and other regularizers that need finite differences along multiple dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}" href="#MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}"><code>MIRT.diffl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl!(g::AbstractArray, x::AbstractArray, dim::Int ; ...)</code></pre><p>Apply left finite difference operator to input array <code>x</code>, storing the result &quot;in-place&quot; in pre-allocated output array <code>g</code>. (The letter <code>g</code> is mnemonic for &quot;gradient&quot;.)</p><p>Arrays <code>g</code> and <code>x</code> must have the same size, and cannot alias. By default, the &quot;first&quot; elements of <code>g</code> are zero for dimension <code>dim</code>. The default is <code>dim=1</code>.</p><p>Option:</p><ul><li><code>add::Bool = false</code> use <code>x[i] + x[i-1]</code> instead of <code>x[i] - x[i-1]</code> (useful for certain diagonal majorizers).</li><li><code>edge::Symbol = :zero</code> set the first elements of dimension <code>dim</code> to 0<ul><li>Choose <code>edge=:circ</code> to use circulant (aka periodic) boundary conditions.</li><li>Choose <code>edge=:none</code> to leave the first elements untouched.</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [2, 6, 7]; g = similar(x); diffl!(g, x)
3-element Vector{Int64}:
 0
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}" href="#MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Allocating version of <code>diffl!</code> for <code>dims</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray, Int64}" href="#MIRT.diffl-Tuple{AbstractArray, Int64}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray, dim::Int ; ...)</code></pre><p>Allocating version of <code>diffl!</code> along <code>dim</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1,2] .+ [10 30 70]; g = diffl(x, 2)
2×3 Matrix{Int64}:
 0  20  40
 0  20  40</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray}" href="#MIRT.diffl-Tuple{AbstractArray}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray ; ...)</code></pre><p>Allocating version of <code>diffl!</code> along <code>dim=1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}" href="#MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}"><code>MIRT.diffl_adj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl_adj!(z::AbstractArray, g::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Adjoint of <code>diffl!</code> for multiple dimensions <code>dims</code>. Here <code>g</code> must have one more dimension than <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}" href="#MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}"><code>MIRT.diffl_adj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl_adj!(z, g, dim::Int ; ...)</code></pre><p>Adjoint of left finite difference <code>diffl!</code>, in-place. Arrays <code>z</code> and <code>g</code> must be same size. See <code>diffl_adj</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl_adj-Tuple{AbstractArray, Int64}" href="#MIRT.diffl_adj-Tuple{AbstractArray, Int64}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray, dim::Int ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> along <code>dim</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = ones(Int,2,3); z = diffl_adj(g, 2)
2×3 Matrix{Int64}:
 -1  0  1
 -1  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl_adj-Tuple{AbstractArray}" href="#MIRT.diffl_adj-Tuple{AbstractArray}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> along <code>dim=1</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = [0, 2, 5]; z = diffl_adj(g)
3-element Vector{Int64}:
 -2
 -3
  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L227-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}" href="#MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> for <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L261-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D" href="#MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D"><code>MIRT.diffl_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = diffl_map(N::Dims{D}, dims::AbstractVector{Int} ; kwargs...)
T = diffl_map(N::Dims{D}, dim::Int ; kwargs...)</code></pre><p><strong>in</strong></p><ul><li><code>N::Dims</code> image size</li></ul><p><strong>options: see <code>diffl!</code></strong></p><ul><li><code>T::Type</code> for <code>LinearMapAA</code>, default <code>Float32</code></li><li><code>operator::Bool = true</code> use <code>false</code> for <code>LinearMapAM</code></li></ul><p><strong>out</strong></p><ul><li><code>T</code> <code>LinearMapAA</code> object for computing finite differences via <code>T*x</code></li></ul><p>using <code>diffl!</code> and <code>diffl_adj!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/regularize/diffl.jl#L277-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}" href="#MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}"><code>MIRT.downsample1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample1(x, down ; warn=true)</code></pre><p>Downsample 1D vector by factor <code>down</code>.</p><p><strong>in</strong></p><ul><li><code>x [n1]</code></li><li><code>down::Int</code> downsampling factor</li></ul><p><strong>option</strong></p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default <code>isinteractive()</code></li></ul><p><strong>out</strong></p><ul><li><code>y [n1/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/downsample.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}" href="#MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}"><code>MIRT.downsample2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample2(x, down ; warn=true, T)</code></pre><p>Downsample by averaging by integer factors.</p><p><strong>in</strong></p><ul><li><code>x [nx ny]</code></li><li><code>down</code> can be a scalar (same factor for both dimensions) or a <code>NTuple{2,Int}</code></li></ul><p><strong>option</strong></p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default <code>isinteractive()</code></li><li><code>T::Type</code> specify output eltype; default <code>eltype(x[1] / down[1])</code></li></ul><p><strong>out</strong></p><ul><li><code>y [nx/down ny/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/downsample.jl#L85-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}" href="#MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}"><code>MIRT.downsample3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample3(x, down ; warn=true, T)</code></pre><p>Downsample by averaging by integer factors.</p><p><strong>in</strong></p><ul><li><code>x (nx,ny,nz)</code></li><li><code>down</code> can be a scalar (same factor for all dimensions) or a <code>NTuple{3,Int}</code></li></ul><p><strong>option</strong></p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default true</li><li><code>T::Type</code> specify output eltype; default <code>eltype(x[1] / down[1])</code></li></ul><p><strong>out</strong></p><ul><li><code>y (nx/down,ny/down,nz/down)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/downsample.jl#L140-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}" href="#MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}"><code>MIRT.downsample_dim1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample_dim1(x, down ; warn::Bool)</code></pre><p>Down-sample <code>x</code> by factor <code>down</code> along first dimension by averaging.</p><p><strong>in</strong></p><ul><li><code>x [n1 (Nd)]</code></li><li><code>down::Int</code> downsampling factor</li></ul><p><strong>option</strong></p><ul><li><code>warn::Bool</code> warn if non-integer multiple; default <code>isinteractive()</code></li></ul><p><strong>out</strong></p><ul><li><code>y [n1÷down (Nd)]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/downsample.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}" href="#MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}"><code>MIRT.dtft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X = dtft(w, x ; n_shift=?)</code></pre><p>multi-dimensional DTFT (DSFT)</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m,:] (n - n_{shift})), m=1,…,M$</span> where here <code>n</code> is a <code>CartesianIndex</code></p><p><strong>in</strong></p><ul><li><code>w::AbstractMatrix{&lt;:Real} (M,D)</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>x::AbstractArray{&lt;:Number} [(Nd)]</code> D-dimensional signal</li></ul><p><strong>option</strong></p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is N/2; default zeros(D)</li></ul><p><strong>out</strong></p><ul><li><code>X::AbstractVector{ComplexF64} (M)</code> DTFT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/dtft.jl#L41-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}" href="#MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}"><code>MIRT.dtft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X = dtft(w, x ; n_shift=?)</code></pre><p>1D DTFT</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m] (n - n_{shift})), m=1,…,M$</span></p><p><strong>in</strong></p><ul><li><code>w::AbstractVector{&lt;:Real} (M)</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>x::AbstractVector{&lt;:Number} (N)</code> 1D signal</li></ul><p><strong>option</strong></p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li></ul><p><strong>out</strong></p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/dtft.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = dtft_adj(w, X, N ; n_shift=?)</code></pre><p>adjoint for multi-dimensional DTFT (DSFT)</p><p><span>$x[n] = \sum_{m=1}^M X[m] \exp(i w[m,:] (n - n_{shift})), n=0,…,N-1$</span> where here <code>n</code> is a <code>CartesianIndex</code></p><p><strong>in</strong></p><ul><li><code>X::AbstractVector{ComplexF64} (M)</code> DTFT</li><li><code>w::AbstractMatrix{&lt;:Real} (M,D)</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Dims (D)</code> dimensions of signal <code>x</code></li></ul><p><strong>option</strong></p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is <code>N/2</code>; default <code>zeros(D)</code></li><li><code>T::Type</code> default <code>(eltype(w) == Float64) ? ComplexF64 : ComplexF32</code></li></ul><p><strong>out</strong></p><ul><li><code>x::AbstractArray{&lt;:Number} [(N)]</code> <code>D</code>-dimensional signal</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/dtft.jl#L171-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}" href="#MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}"><code>MIRT.dtft_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = dtft_adj(w, X, N ; n_shift=?)</code></pre><p>adjoint for 1D DTFT</p><p><span>$x[n] = \sum_{m=1}^M X[m] \exp(i w[m] (n - n_{shift})), n=0,…,N-1$</span></p><p>This is the <em>adjoint</em> (transpose) of <code>dtft</code>, not an <em>inverse</em> DTFT.</p><p><strong>in</strong></p><ul><li><code>w::AbstractVector{&lt;:Real} (M)</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>X::AbstractVector{ComplexF64} (M)</code> spectrum values</li><li><code>N::Int</code> size of signal <code>x</code></li></ul><p><strong>option</strong></p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>T::Type</code> output data type; default <code>ComplexF64</code></li></ul><p><strong>out</strong></p><ul><li><code>x::AbstractVector{&lt;:Number} (N)</code> signal</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/dtft.jl#L136-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = dtft_init(w, N ; n_shift=?)</code></pre><p>for multi-dimensional DTFT (DSFT)</p><p><strong>in</strong></p><ul><li><code>w::AbstractMatrix{&lt;:Real} (M,D)</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Dims</code> <code>[D]</code> dimensions of signal <code>x</code></li></ul><p><strong>option</strong></p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is N/2; default zeros(D)</li><li><code>T::Type</code> default <code>ComplexF64</code> for testing NUFFT accuracy</li></ul><p><strong>out</strong></p><ul><li><code>d::NamedTuple</code> with fields   <code>dtft = x -&gt; dtft(x), adjoint = y -&gt; dtft_adj(y), A=LinearMapAO</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/dtft.jl#L100-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}" href="#MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}"><code>MIRT.dtft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = dtft_init(w, N ; n_shift=?)</code></pre><p>For 1D DTFT</p><p><strong>in</strong></p><ul><li><code>w::AbstractVector{&lt;:Real} (M)</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Int</code> size of signal <code>x</code></li></ul><p><strong>option</strong></p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>T::Type</code> default <code>ComplexF64</code> for testing NUFFT accuracy</li></ul><p><strong>out</strong></p><ul><li><code>d::NamedTuple</code> with fields   <code>dtft = x -&gt; dtft(x), adjoint = y -&gt; dtft_adj(y), A=LinearMapAO</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/dtft.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}" href="#MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(array, v, mask ; filler=0)</code></pre><p>embed vector <code>v</code> of length <code>sum(mask)</code> into elements of <code>array</code> where <code>mask</code> is <code>true</code>, setting the remaining elements to <code>filler</code> (default 0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}" href="#MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array = embed(matrix::AbstractMatrix{&lt;:Number}, mask::AbstractArray{Bool})</code></pre><p>Embed each column of <code>matrix</code> into <code>mask</code> then <code>cat</code> along next dimension In:</p><ul><li><code>matrix [sum(mask) L]</code></li><li><code>mask [(N)]</code></li></ul><p>Out:</p><ul><li><code>array [(N) L]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L85-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number" href="#MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number"><code>MIRT.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array = embed(v, mask ; filler=0)</code></pre><p>embed vector <code>v</code> of length <code>sum(mask)</code> into elements of an array where <code>mask</code> is <code>true</code>; see <code>embed!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.eql_root-Tuple{Real, Real, Real}" href="#MIRT.eql_root-Tuple{Real, Real, Real}"><code>MIRT.eql_root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = eql_root(a,b,c)</code></pre><p>Numerically stable method for computing the positive root of the quadratic polynomial <code>-ax^2 - 2bx + c, a &gt;= 0</code>. Assumes solvable equations; will throw otherwise.</p><p><strong>in</strong></p><ul><li><code>a</code> The negative of the <code>x^2</code> term. Must be positive.</li><li><code>b</code> Half the negative of the <code>x</code> term.</li><li><code>c</code> The constant term.</li></ul><p><strong>out</strong></p><ul><li><code>x</code> The positive root that satisfies <code>0 = -ax^2 - 2bx + c</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/eql_root.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>MIRT.exp_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">D = exp_mult(A, u, v ; warnboth)</code></pre><p>Memory efficient and fast implementation of <code>D = A&#39; * exp(-u * v^T)</code> that is useful for B0-field-corrected MRI image reconstruction.</p><p><strong>in</strong></p><ul><li><code>A [N L]</code> matrix</li><li><code>u [N]</code> vector</li><li><code>v [M]</code> vector</li><li><code>warnboth</code> warn if both <code>u</code> and <code>v</code> are complex; default: true</li></ul><p><strong>out</strong></p><ul><li><code>D [L M]</code> complex vector: <code>D = A&#39; * exp(-u * v^T)</code></li></ul><p><code>D_lm = sum_n A_nl^* exp(-u_n v_m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/exp_mult.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}" href="#MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>MIRT.exp_xform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp_xform(x, u, v ; mode::Symbol = :matrix)</code></pre><p><strong>in</strong></p><ul><li><code>x [N L]</code> possibly complex vector(s)</li><li><code>u [D N]</code> possibly complex vectors</li><li><code>v [D M]</code> possibly complex vectors</li><li><code>mode::Symbol</code> <code>:matrix</code> (default) | <code>:element</code> | <code>:row</code> | <code>:column</code></li></ul><p><strong>out</strong></p><ul><li><code>y [M L]</code> typically complex vector</li></ul><p><code>y[m,l] = sum_n x[n,l] exp(-sum(u[:,n] .* v[:,m]))</code></p><p>Iterates through subsets of the ML matrix designated by <code>:mode</code> (i.e. row, column, element, or just computing the entire matrix) This is the &#39;slow&#39; &#39;exact&#39; transform model for MRI.</p><p>Output type will depend on input types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/exp_xform.jl#L14-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.genkspace-NTuple{8, Any}" href="#MIRT.genkspace-NTuple{8, Any}"><code>MIRT.genkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genkspace</code></pre><p>Generate the proper length of k-space trajectory.</p><p>It linearly interpolates the output of <code>genspiral</code> to the correct <code>length()</code> &amp; takes care of the rotations for the interleaves.</p><ul><li><code>ld</code> is the length of the data</li><li><code>nint</code> is the number of interleaves</li></ul><p>Brad Sutton; University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/kspace-spiral.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.genspi-Tuple{Any, Any}" href="#MIRT.genspi-Tuple{Any, Any}"><code>MIRT.genspi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gx, Gy, kx, ky, sx, sy, gts = genspi(...)</code></pre><p>This is translation of C code from scanner: exactly what is played out to gradients at 4us.</p><p>Multi-shot spiral design uses Duyn&#39;s approximate slewrate limited design augmented with archimedean <code>gmax</code> limit</p><p><strong>in [args]</strong></p><ul><li><p><code>D</code> = FOV; cm</p></li><li><p><code>N</code> = matrix size()</p></li><li><p><code>Tmax</code> = longest acquisition allowed; s</p></li><li><p><code>dts</code> = output sample spacing; s</p></li><li><p><code>gtype</code> = trajectory type()</p></li></ul><p><strong>option [CVs]</strong></p><ul><li><code>nl</code> = number of interleaves</li><li><code>gamp</code> = design grad max; G/cm</li><li><code>gslew</code> = design slew rate; mT/m/ms</li><li><code>nramp</code> = number of rampdown points; default 0</li></ul><p><strong>out</strong></p><ul><li><code>Gx; Gy</code></li></ul><p>time is in sec()</p><ul><li>rev 0 12/26/98    original</li><li>rev 1 4/15/99    little better calc of ts</li></ul><p>Borrowed from Doug Noll; Univ. of Michigan. Modified to take more input cv&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/kspace-spiral.jl#L157-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}" href="#MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.getindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex!(y::AbstractVector, x::AbstractArray{T,D}, mask::AbstractArray{Bool,D})</code></pre><p>Equivalent to the in-place <code>y .= x[mask]</code> but is non-allocating.</p><p>For non-Boolean indexing, just use <code>@views y .= A[index]</code>, per https://discourse.julialang.org/t/efficient-non-allocating-in-place-getindex-for-bitarray/42268</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}" href="#MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}"><code>MIRT.interp1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yi = interp1(x, y, xi ; how=Gridded(Linear()), extrap=0)</code></pre><p>1D interpolation of <code>y = f(x)</code> at points <code>xi</code></p><p>In:</p><ul><li><code>x::AbstractVector{&lt;:Real}</code></li><li><code>y::AbstractVector{&lt;:Number}</code></li></ul><p>Option:</p><ul><li><code>how::Interpolations.InterpolationType</code> default <code>Gridded(Linear())</code></li><li><code>extrap::Any</code> how to extrapolate, e.g., <code>Flat()</code>; default <code>0</code></li></ul><p>other options from Interpolations.jl are <code>Line()</code> <code>Periodic()</code> <code>Reflect()</code> <code>Throw()</code></p><p>Output is same size as input <code>xi</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/interp1.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_dump-Tuple{Any}" href="#MIRT.ir_dump-Tuple{Any}"><code>MIRT.ir_dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_dump(x::Any ; io::IO = stdout)
ir_dump(io::IO, x::Any)</code></pre><p>Show all the fields of a structure or <code>NamedTuple</code> more nicely than dump() does</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/io/ir_dump.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_load_brainweb_t1_256-Tuple{}" href="#MIRT.ir_load_brainweb_t1_256-Tuple{}"><code>MIRT.ir_load_brainweb_t1_256</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data = ir_load_brainweb_t1_256()</code></pre><p>Load brainweb T1-weighted MRI slice of size <code>256 × 256</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/data/loaders.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}" href="#MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}"><code>MIRT.ir_mri_coil_compress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(odata, σ, Vr) = ir_mri_coil_compress(idata ; ncoil)</code></pre><p>MRI coil compression via PCA. Given multiple MRI surface coil images (idata), use SVD/PCA to find a smaller number of virtual coil images (odata).</p><p>In:</p><ul><li><code>idata</code> <code>[(N) n_in]</code>: noisy complex images (2D or 3D) for each coil</li></ul><p>Option:</p><ul><li><code>ncoil</code> Desired # of virtual coils (default: 1)</li></ul><p>Out:</p><ul><li><code>odata</code> <code>[(N) ncoil]</code>: virtual coil images</li><li><code>σ</code>     <code>[n_in]</code>: singular values.</li><li><code>Vr</code>    <code>[n_in, ncoil]</code>: compression matrix for reducing other data.</li></ul><p>todo: currently ignores noise correlations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/coil_compress.jl#L15-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_kspace_ga_radial-Tuple{}" href="#MIRT.ir_mri_kspace_ga_radial-Tuple{}"><code>MIRT.ir_mri_kspace_ga_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace = ir_mri_kspace_ga_radial(; Nro=?, Nspoke=?, ...)</code></pre><p>Generate k-space sampling pattern for &quot;golden angle&quot; radial sampling.</p><p><strong>option</strong></p><ul><li><code>Nro:Int</code> number of samples in each readout/spoke, default 256</li><li><code>Nspoke::Int</code> number of spokes, default 1</li><li><code>start::Real</code> first angle in series [radians], default π/2</li><li><code>angle::Real</code> angular spacing [radians], default GA</li><li><code>delta_ro::Real</code> readout spacing, default <code>1/Nro</code></li><li><code>shift::Real</code> shift due to gradient delays, default 0<ul><li>radial sample locations are <code>ir * delta_ro</code></li><li>where <code>ir = [-(Nro/2 - 1):1:Nro/2] + shift</code></li></ul></li></ul><p><strong>out</strong></p><ul><li><code>kspace</code> <code>[Nro Nspoke 2]</code> (Float32)</li></ul><p><code>kx</code> and <code>ky</code> k-space locations for <code>Nspoke*Nro</code> samples in interval <code>(-0.5 0.5]</code> for default <code>shift</code>, <code>delta_ro</code> so default units are &quot;cycles / sample&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/kspace.jl#L13-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{Symbol}" href="#MIRT.ir_mri_sensemap_sim-Tuple{Symbol}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap,info) = ir_mri_sensemap_sim( :all ; kwargs)</code></pre><p>Like <code>ir_mri_sensemap_sim</code> but also returns <code>info</code> with data for all coils, mainly for testing and plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/sensemap-sim.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}" href="#MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap,info) = ir_mri_sensemap_sim( ir_ic_pair ; kwargs)</code></pre><p>Like <code>ir_mri_sensemap_sim</code> but also returns <code>info</code> with data for specific coils where <code>ir_ic_pair::Vector{Tuple{Int,Int}}</code>. (Usually used internally only.)</p><ul><li><code>info::NamedTuple</code> geometry information for plots</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/sensemap-sim.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{}" href="#MIRT.ir_mri_sensemap_sim-Tuple{}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smap = ir_mri_sensemap_sim(...)</code></pre><p>Simulate 2D or 3D sensitivity maps for sensitivity-encoded MRI based on <a href="http://doi.org/10.1119/1.19461">grivich:00:tmf</a>.</p><p>This code makes maps for multiple coils, but does not model coupling between coils, so most likely it is an approximation at best.</p><p><strong>option</strong></p><ul><li><code>dims::Dims</code> image size; default (64, 64)</li><li><code>dx::Real</code> pixel/voxel dimension; default: 3</li><li><code>dy::Real</code> pixel/voxel dimension; default: <code>dx</code></li><li><code>dz::Real</code> &quot;&quot;</li><li><code>ncoil::Int</code> # of coils total; default 4</li><li><code>nring::Int</code> # of rings of coils; default 1</li><li><code>rcoil::Real</code> coil radius; default <code>dx * nx / 2 * 0.50</code></li><li><code>dz_coil</code> ring spacing in z; default <code>nz*dz/nring</code><ul><li>(3D geometry is a cylinder)</li></ul></li><li><code>coil_distance::Real</code> distance of coil center from isocenter<ul><li>for central ring of coils as a multiple of <code>FOVx</code>,</li><li>where <code>FOVx=nx*dx</code>; default 1.2</li></ul></li><li><code>orbit::Real</code> default 360 [degrees]</li><li><code>orbit_start::AbstractVector{&lt;:Real} = fill(0, nring)</code> [degrees]</li><li><code>scale::Symbol</code><ul><li><code>:none</code> (default)</li><li><code>ssos_center</code> make SSoS of center = 1</li></ul></li></ul><p><strong>out</strong></p><ul><li><code>smap [dims ncoil]</code> simulated sensitivity maps (complex!)</li></ul><p>All length parameters must have same units (e.g., mm or cm)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/sensemap-sim.jl#L20-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}" href="#MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}"><code>MIRT.ir_mri_sensemap_sim_do</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap, info) = ir_mri_sensemap_sim_do()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/sensemap-sim.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_smap1-NTuple{4, Any}" href="#MIRT.ir_mri_smap1-NTuple{4, Any}"><code>MIRT.ir_mri_smap1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_mri_smap1()</code></pre><p>Based on grivich:00:tmf for a circular coil in &quot;x-y plane&quot; of radius &quot;a&quot;</p><p>Note that coil x-y plane is not same as object x-y plane!</p><p>Returns <code>(i,j,k)</code> components of <span>$B$</span> vector for each <code>(x,y,z)</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/sensemap-sim.jl#L235-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ir_mri_smap_r-Tuple{Any, Any}" href="#MIRT.ir_mri_smap_r-Tuple{Any, Any}"><code>MIRT.ir_mri_smap_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_mri_smap_r(r, z)</code></pre><p>Function for testing near 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/sensemap-sim.jl#L223-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.jinc-Tuple{Real}" href="#MIRT.jinc-Tuple{Real}"><code>MIRT.jinc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jinc(x)</code></pre><p>Return <code>jinc(x) = J1(pi*x)/(2x)</code>, where <code>J1</code> is a Bessel function of the first kind.</p><p>Units of <code>x</code> are typically cycles/m.</p><p>Return type is <code>promote_type(typeof(x), Float32)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/jinc.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.line_search_mm-Tuple" href="#MIRT.line_search_mm-Tuple"><code>MIRT.line_search_mm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α = line_search_mm(args...; opt, fun, kwargs...)</code></pre><p>Line-search based on majorize-minimize (MM) approach. This is a wrapper around the iterator <code>LineSearchMM</code>. See its constructors for <code>args</code> and other <code>kwargs</code>.</p><p><strong>option</strong></p><ul><li><code>fun(state)</code> User-defined function to be evaluated with the <code>state</code> initially and then after each iteration.</li><li><code>out::Union{Nothing,Vector{Any}} = nothing</code> optional place to store result of <code>fun</code> for iterates <code>0,…,ninner</code>:  (All <code>missing by default.) This is a</code>Vector{Any}<code>of length</code>ninner+1`.</li></ul><p><strong>output</strong></p><ul><li><code>α</code> final iterate</li></ul><p>This function mutates the optional arguments <code>out</code> and <code>work</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ls-mm.jl#L220-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.make_dot_curvf-Union{Tuple{Tw}, Tuple{Tx}, Tuple{Function, AbstractArray{Tx}}, Tuple{Function, AbstractArray{Tx}, Type{&lt;:Number}}} where {Tx&lt;:Number, Tw&lt;:Number}" href="#MIRT.make_dot_curvf-Union{Tuple{Tw}, Tuple{Tx}, Tuple{Function, AbstractArray{Tx}}, Tuple{Function, AbstractArray{Tx}, Type{&lt;:Number}}} where {Tx&lt;:Number, Tw&lt;:Number}"><code>MIRT.make_dot_curvf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_dot_curvf(curv::Function, [x, Tf::Type; w = similar(x)])</code></pre><p>Make a function with arguments <code>(v, x)</code> that computes the dot product between <code>abs2.(v)</code> and <code>curv(x)</code> where <code>curv(x)</code> is a curvature function associated with a quadratic majorizer for some real-valued cost function <code>f(x)</code>, evaluated at array <code>x</code>, typically for use in a line-search method.</p><ul><li><p>For a single-argument gradient function <code>curv(x)</code>, this returns the version equivalent to <code>(v, x) -&gt; dot(abs2.(v), curv(x))</code>. This version will be allocating, unless <code>curv</code> has its own internal workspace due to a closure. This version expects only the argument <code>curv</code>.</p></li><li><p>For a two-argument mutating gradient function <code>curv!(w, x)</code>, this returns a function equivalent to <code>(v, x) -&gt; dot(abs2.(v), curv!(w, x))</code> using the keyword argument <code>w</code> as the work array.</p></li><li><p>If <code>curv</code> is simply a real number (a Lipschitz constant), possibly with units, then this returns the function <code>(v, x) -&gt; curv * sum(abs2, v)</code>.</p></li></ul><p>If <code>f(x)</code> maps an Array <code>x</code> of elements with units <code>Ux</code> into real numbers with units <code>Uf</code>, then its curvature has units <code>Uf/Ux^2</code>. Those units are relevant to defining the work array <code>w</code>.</p><p><strong>in</strong></p><ul><li><code>curv::Function</code> see above</li><li><code>x</code> an array whose <code>size</code> and <code>eltype</code> is used to allocate <code>w</code></li></ul><p><strong>option</strong></p><ul><li><code>Tf::Type = typeof(one(eltype(x)))</code> Specify <code>eltype</code> of function <code>f(x)</code>, defaulting to unitless.</li><li><code>w = similar(x,  typeof(oneunit(Tf) / oneunit(eltype(x))^2))</code> work space for gradient calculation, with appropriate units (if needed).</li></ul><p><strong>out</strong></p><ul><li><code>(v, x) -&gt; dot(abs2.(v), curv([w,] x))</code> or equivalent.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/dot-curv.jl#L12-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.make_dot_gradf-Union{Tuple{Tw}, Tuple{Tx}, Tuple{Function, AbstractArray{Tx}}, Tuple{Function, AbstractArray{Tx}, Type{&lt;:Number}}} where {Tx&lt;:Number, Tw&lt;:Number}" href="#MIRT.make_dot_gradf-Union{Tuple{Tw}, Tuple{Tx}, Tuple{Function, AbstractArray{Tx}}, Tuple{Function, AbstractArray{Tx}, Type{&lt;:Number}}} where {Tx&lt;:Number, Tw&lt;:Number}"><code>MIRT.make_dot_gradf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_dot_gradf(grad::Function, [x, Tf::Type; w = similar(x)])</code></pre><p>Make a function with arguments <code>(v, x)</code> that computes the dot product between an array <code>v</code> and the gradient <code>grad(x)</code> of some real-valued cost function <code>f(x)</code>, evaluated at array <code>x</code>, typically for use in a line-search method.</p><ul><li><p>For a single-argument gradient function <code>grad(x)</code>, this returns the version <code>(v, x) -&gt; dot(v, grad(x))</code>. This version will be allocating, unless <code>grad</code> has its own internal workspace due to a closure. This version expects only the argument <code>grad</code>.</p></li><li><p>For a two-argument mutating gradient function <code>grad!(w, x)</code>, this returns a function <code>(v, x) -&gt; dot(v, grad!(w, x))</code>  using the keyword argument <code>w</code> as the work array.</p></li></ul><p>If <code>f(x)</code> maps an Array <code>x</code> of elements with units <code>Ux</code> into real numbers with units <code>Uf</code>, then the gradient <code>∇f</code> has units <code>Uf/Ux</code>. Those units are relevant to defining the work array <code>w</code>.</p><p><strong>in</strong></p><ul><li><code>grad::Function</code> see above</li><li><code>x</code> an array whose <code>size</code> and <code>eltype</code> is used to allocate <code>w</code></li><li><code>Tf::Type = typeof(one(eltype(x)))</code> Specify <code>eltype</code> of function <code>f(x)</code>, defaulting to unitless.</li></ul><p><strong>option</strong></p><ul><li><code>w = similar(x, typeof(oneunit(Tf) / oneunit(eltype(x))))</code> work space for gradient calculation, with appropriate units (if needed).</li></ul><p><strong>out</strong></p><ul><li><code>(v, x) -&gt; dot(v, grad([w,] x))</code> or equivalent.</li></ul><p>Example. Consider the cost function <code>f(x) = sum(sin.(x))</code> that has gradient <code>g(x) = cos.(x)</code>. The simple way here is <code>make_dot_gradf(g)</code>, which will return the function <code>(v, x) = dot(v, g(x)) === dot(v, cos.(x))</code>. That will work fine, but the <code>cos.(x)</code> step will be allocating. A better way (for repeated use) is</p><pre><code class="language-julia hljs">function g!(work, x)
   @. work = cos(x) # mutating
   return work
end</code></pre><p>Then <code>make_dot_gradf(g!, x)</code> will return a function <code>(v,x)</code> that does not allocate (except when first generated via a closure). For this particular example, an even better approach is to directly define <code>dot_gradf(v,x) = sum(vx -&gt; vx[1]*cos(vx[2]), zip(v,x))</code>, but <code>make_dot_gradf</code> is here for more general cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/dot-grad.jl#L12-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.map_many</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = map_many(fun::Function, x::AbstractArray{&lt;:Any}, idim::Dims)</code></pre><p>Apply a function <code>fun</code> to leading slices of input <code>x</code>; cousin of <code>mapslices</code></p><p><strong>in</strong></p><ul><li><code>fun::Function</code> maps input of size <code>idim</code> to output of some size <code>odim</code></li><li><code>x [idim ldim]</code></li></ul><p><strong>out</strong></p><ul><li><code>y [odim ldim]</code></li></ul><p>Example: if <code>fun</code> maps array of size (1,2) to array of size (3,4,5) and if input <code>x</code> has size (1,2,7,8) then output <code>y</code> will have size (3,4,5,7,8) where <code>y[:,:,:,i,j] = fun(x[:,:,i,j])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/map_many.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mask_or-Tuple{AbstractMatrix{Bool}}" href="#MIRT.mask_or-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_or</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask_or(mask)</code></pre><p>compress 3D mask to 2D by logical <code>or</code> along <code>z</code> direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}" href="#MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_outline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask_outline(mask)</code></pre><p>return outer boundary of 2D mask (or mask_or for 3D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}" href="#MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.maskit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maskit(x::AbstractArray{&lt;:Number})</code></pre><p>opposite of embed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/mask.jl#L125-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.max_percent_diff-Tuple{Any, Any}" href="#MIRT.max_percent_diff-Tuple{Any, Any}"><code>MIRT.max_percent_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_percent_diff(s1, s2, [options])</code></pre><p>Compute the &quot;maximum percent difference&quot; between two signals: <code>s1, s2</code>.</p><p>Default is to normalize by <code>maximum(abs, s1)</code>.</p><p>options</p><ul><li><code>maxboth::Bool = false</code> use max of both arguments to normalize</li><li><code>normalize::Bool = false</code> normalize each before comparing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/max_percent_diff.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mri_kspace_spiral-Tuple{}" href="#MIRT.mri_kspace_spiral-Tuple{}"><code>MIRT.mri_kspace_spiral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace, omega, gradxy = mri_kspace_spiral( [options] )</code></pre><p>Make k-space spiral trajectory based on GE 3T scanner constraints</p><p>Option:</p><ul><li><code>N</code> dimension of reconstructed image</li><li><code>Nt</code> # of time points</li><li><code>fov</code> field of view in cm</li><li><code>dt</code> time sampling interval out; default <code>5e-6</code> sec</li><li><code>gamp::Real</code> design gradient amplitude max, G/cm; default 2.2</li><li><code>gslew::Int</code> design slew rate, mT/m/ms; default 180</li></ul><p>Out:</p><ul><li><code>kspace [Nt,2]</code> kspace trajectory <code>[kx ky]</code> in cycles/cm, NO: cycles/FOV</li><li><code>omega [Nt,2]</code> &quot;&quot; in radians</li><li><code>gradxy [Nt 2]</code> gradient waveforms in (units?)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/kspace-spiral.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D" href="#MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D"><code>MIRT.mri_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace, omega, wi = mri_trajectory( ; ktype, N, fov, arg_wi, kwargs...)</code></pre><p>Generate kspace trajectory samples and density compensation functions.</p><p><strong>option</strong></p><ul><li><code>ktype::Symbol</code> k-space trajectory type; default <code>:radial</code></li><li><code>N::Dims</code> target image size; default (32,30)</li><li><code>fov</code> field of view in x and y (and z); default (250,250) mm</li><li><code>arg_wi</code> options to pass to <code>ir_mri_density_comp</code> - not yet done</li><li><code>kwargs</code> options for the specific trajectory</li></ul><p><strong>out</strong></p><ul><li><code>kspace [Nk 2|3]</code> kspace samples in units 1/fov</li><li><code>omega [Nk 2|3]</code> trajectory samples over [-π,π)</li><li><code>wi [Nk 1]</code> (optional) density compensation factors</li></ul><p><strong>trajectory types:</strong></p><ul><li><code>:cartesian</code></li><li><code>:radial</code></li><li><code>:cart_y_2</code></li><li><code>:random</code></li><li><code>:half8</code></li><li><code>:epi_sin</code></li><li><code>:spiral0 :spiral1 :spiral3</code></li><li><code>:rosette3</code></li><li><code>:epi_under</code></li><li><code>:gads</code> (emulate golden-angle data sharing per winkelmann:07:aor)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/mri_trajectory.jl#L16-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring" href="#MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring"><code>MIRT.mri_trajectory_gads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">omega, wi = mri_trajectory_gads(N, fov ; ...)</code></pre><p>Emulate 2D golden angle radial sampling with data sharing</p><p><strong>option</strong></p><ul><li><code>Nro</code> # of samples in each readout/spoke</li><li><code>shift</code> shift along read-out due to gradient delays (stress)</li><li><code>kmax_frac</code> fractions of maximum krad (0.5) for rings (annuli)</li><li><code>under</code> under-sampling factor for each annulus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/mri_trajectory.jl#L211-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}" href="#MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}"><code>MIRT.mri_trajectory_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_trajectory_radial()</code></pre><p><strong>option</strong></p><ul><li><code>na_nr</code> default ensures proper sampling at edge of k-space</li><li><code>na</code> angular spokes; default: na_nr * nr</li><li><code>nr</code> radial samples per spoke</li><li><code>ir</code> default: <code>0:nr</code></li></ul><p>todo: generalize to 3D using barger:02:trc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/mri_trajectory.jl#L259-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.mri_trajectory_rosette3-Tuple{Any, Any}" href="#MIRT.mri_trajectory_rosette3-Tuple{Any, Any}"><code>MIRT.mri_trajectory_rosette3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_trajectory_rosette3(N, fov ; ...)</code></pre><p>3d rosette, with default parameters from bucholz:08:miw</p><p><strong>option</strong></p><ul><li><code>omax</code> maximum omega</li><li><code>nt</code> time samples (65.536 ms for 4 usec dt)</li><li><code>dt</code> time sample spacing (4 usec)</li><li><code>ti</code> time samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/mri_trajectory.jl#L296-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}" href="#MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ncg(B, gradf, curvf, x0 ; ...)</code></pre><p>Nonlinear preconditioned conjugate gradient algorithm to minimize a general &quot;inverse problem&quot; cost function of the form <span>$\Psi(x) = \sum_{j=1}^J f_j(B_j x)$</span> where each function <span>$f_j(v)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(v;u) = f_j(u) + \nabla f_j(u) (v - u) + 1/2 \|v - u\|^2_{C_j(u)}\]</p><p>where <span>$C_j(u)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>This CG method uses a majorize-minimize (MM) line search.</p><p><strong>in</strong></p><ul><li><code>B</code> vector of <span>$J$</span> blocks <span>$B_1,…,B_J$</span></li><li><code>gradf</code> vector of <span>$J$</span> functions return gradients of <span>$f_1,…,f_J$</span></li><li><code>curvf</code> vector of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar or a vector of curvature values for each element of <span>$z$</span></li><li><code>x0</code> initial guess; need <code>length(x) == size(B[j],2)</code> for <span>$j=1,…,J$</span></li></ul><p>Usually <code>x0</code> is a <code>Vector</code> but it can be an <code>Array</code> if each <code>B_j</code> is a linear operator (e.g., <code>LinearMapAO</code>) of suitable &quot;dimensions&quot;.</p><p><strong>option</strong></p><ul><li><code>niter</code> # number of outer iterations; default 50</li><li><code>ninner</code> # number of inner iterations of MM line search; default 5</li><li><code>P</code> # preconditioner; default <code>I</code></li><li><code>betahow</code> &quot;beta&quot; method for the search direction; default <code>:dai_yuan</code></li><li><code>fun</code> User-defined function to be evaluated with two arguments (x,iter).<ul><li>It is evaluated at <code>(x0,0)</code> and then after each iteration.</li></ul></li></ul><p><strong>output</strong></p><ul><li><code>x</code> final iterate</li><li><code>out</code> <code>[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))</code><ul><li>(all 0 by default). This is an array of length <code>niter+1</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ncg.jl#L14-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}" href="#MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ncg(grad, curv, x0, ...)</code></pre><p>Special case of <code>ncg</code> (nonlinear CG) for minimizing a cost function whose gradient is <code>grad(x)</code> and that has a quadratic majorizer with diagonal Hessian given by <code>curv(x)</code>. Typically <code>curv = (x) -&gt; L</code> where <code>L</code> is the Lipschitz constant of <code>grad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ncg.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}" href="#MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}"><code>MIRT.nufft_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nufft_eltype(::Type)</code></pre><p>ensure plan_nfft eltype is Float32 or Float64</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/nufft.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.nufft_errors-Tuple{}" href="#MIRT.nufft_errors-Tuple{}"><code>MIRT.nufft_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">w, errs = nufft_errors( ; M=401, w=?, N=513, n_shift=0, ...)</code></pre><p>Compute NUFFT approximation errors (for signal of length <code>N</code> of unit norm), for given digital frequency values <code>w</code>, i.e., Ω. Default <code>w</code> is <code>range(0, 2π/N, M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/errors.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}" href="#MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.nufft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=0)</code></pre><p>Setup 1D NUFFT, for computing fast <span>$O(N \log N)$</span> approximation to</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m] (n - n_{shift})), m=1,…,M$</span></p><p><strong>in</strong></p><ul><li><code>w::AbstractArray{&lt;:Real}</code> <code>[M]</code> frequency locations (aka Ω, units radians/sample)<ul><li><code>eltype(w)</code> determines the <code>plan_nfft</code> type; so to save memory use Float32!</li><li><code>size(w)</code> determines <code>odim</code> for <code>A</code> if <code>operator=true</code></li></ul></li><li><code>N::Int</code> signal length</li></ul><p><strong>option</strong></p><ul><li><code>nfft_m::Int</code> see NFFT.jl documentation; default 4</li><li><code>nfft_sigma::Real</code> &quot;&quot;, default 2.0</li><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>pi_error::Bool</code> throw error if <span>$|w| &gt; π$</span>, default <code>true</code><ul><li>Set to <code>false</code> only if you are very sure of what you are doing!</li></ul></li><li><code>do_many::Bool</code>  support extended inputs via <code>map_many</code>? default <code>true</code></li><li><code>operator::Bool=true</code> set to <code>false</code> to make <code>A</code> an <code>LinearMapAM</code></li></ul><p><strong>out</strong></p><ul><li><code>p NamedTuple</code></li></ul><p><code>(nufft = x -&gt; nufft(x), adjoint = y -&gt; nufft_adj(y), A::LinearMapAO)</code></p><p>The default settings are such that for a 1D signal of length N=512, the worst-case error is below 1e-5 which is probably adequate for typical medical imaging applications. To verify this statement, run <code>nufft_plot1()</code> and see plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/nufft.jl#L45-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.nufft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=?)</code></pre><p>Setup multi-dimensional NUFFT, for computing fast <span>$O(N \log N)$</span> approximation to</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m,:] (n - n_{shift})), m=1,…,M$</span></p><p><strong>in</strong></p><ul><li><code>w::AbstractArray{&lt;:Real}</code> <code>[M,D]</code> frequency locations (aka Ω, units radians/sample)<ul><li><code>eltype(w)</code> determines the <code>plan_nfft</code> type; so to save memory use Float32!</li><li><code>size(w)[1:(end-1)]</code> determines <code>odim</code> if <code>operator=true</code></li></ul></li><li><code>N::Dims{D}</code> signal dimensions</li></ul><p><strong>option</strong></p><ul><li><code>nfft_m::Int</code> see NFFT.jl documentation; default 4</li><li><code>nfft_sigma::Real</code> &quot;&quot;, default 2.0</li><li><code>n_shift::AbstractVector{&lt;:Real} (D)</code> often is N/2; default zeros(D)</li><li><code>pi_error::Bool</code> throw error if <span>$|w| &gt; π$</span>, default <code>true</code><ul><li>Set to <code>false</code> only if you are very sure of what you are doing!</li></ul></li><li><code>do_many::Bool</code> support extended inputs via <code>map_many</code>? default <code>true</code></li><li><code>operator::Bool=true</code> set to <code>false</code> to make <code>A</code> a <code>LinearMapAM</code></li></ul><p>The default <code>do_many</code> option is designed for parallel MRI where the k-space sampling pattern applies to every coil. It may also be useful for dynamic MRI with repeated sampling patterns. The coil and/or time dimensions must come after the spatial dimensions.</p><p><strong>out</strong></p><ul><li><code>p NamedTuple</code> with fields   <code>nufft = x -&gt; nufft(x), adjoint = y -&gt; nufft_adj(y), A=LinearMapAO</code>   (Using <code>operator=true</code> allows the <code>LinearMapAO</code> to support <code>do_many</code>.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/nufft.jl#L130-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T" href="#MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>MIRT.nufft_typer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nufft_typer(T::Type, x::AbstractArray{&lt;:Real} ; warn::Bool=true)</code></pre><p>type conversion wrapper for <code>nfft()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/nufft/nufft.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}" href="#MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ogm_ls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ogm_ls(B, gradf, curvf, x0; niter=?, ninner=?, fun=?)</code></pre><p>OGM with a line search <a href="http://doi.org/10.1007/s10107-019-01410-2">Drori&amp;Taylor</a> to minimize a general &quot;inverse problem&quot; cost function of the form <span>$\Psi(x) = \sum_{j=1}^J f_j(B_j x)$</span> where each function <span>$f_j(v)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(v;u) = f_j(u) + \nabla f_j(u) (v - u) + 1/2 \|v - u\|^2_{C_j(u)}\]</p><p>where <span>$C_j(u)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>This OGM method uses a majorize-minimize (MM) line search.</p><p><strong>in</strong></p><ul><li><code>B</code> vector of <span>$J$</span> blocks <span>$B_1,…,B_J$</span></li><li><code>gradf</code> vector of <span>$J$</span> functions return gradients of <span>$f_1,…,f_J$</span></li><li><code>curvf</code> vector of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar or a vector of curvature values for each element of <span>$z$</span></li><li><code>x0</code> initial guess; need <code>length(x) == size(B[j],2)</code> for <span>$j=1,…,J$</span></li></ul><p><strong>option</strong></p><ul><li><code>niter</code> # number of outer iterations; default 50</li><li><code>ninner</code> # number of inner iterations of MM line search; default 5</li><li><code>fun</code> User-defined function to be evaluated with two arguments (x,iter).</li><li>It is evaluated at (x0,0) and then after each iteration.</li></ul><p><strong>output</strong></p><ul><li><code>x</code> final iterate</li><li><code>out (niter+1) (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))</code><ul><li>(all 0 by default). This is a vector of length <code>niter+1</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ogm_ls.jl#L12-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}" href="#MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}"><code>MIRT.ogm_ls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ogm_ls(grad, curv, x0, ...)</code></pre><p>Special case of <code>ogm_ls</code> (OGM with line search) for minimizing a cost function whose gradient is <code>grad(x)</code> and that has a quadratic majorizer with diagonal Hessian given by <code>curv(x)</code>. Typically <code>curv = (x) -&gt; L</code> where <code>L</code> is the Lipschitz constant of <code>grad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/ogm_ls.jl#L137-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.pogm_restart-Tuple{Any, Function, Function, Real}" href="#MIRT.pogm_restart-Tuple{Any, Function, Function, Real}"><code>MIRT.pogm_restart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x, out = pogm_restart(x0, Fcost, f_grad, f_L ;
f_mu=0, mom=:pogm, restart=:gr, restart_cutoff=0.,
bsig=1, niter=10, g_prox=(z,c)-&gt;z, fun=...)</code></pre><p>Iterative proximal algorithms (PGM=ISTA, FPGM=FISTA, POGM) with restart.</p><p><strong>in</strong></p><ul><li><code>x0</code> initial guess</li><li><code>Fcost</code> function for computing the cost function value <span>$F(x)$</span><ul><li>(needed only if <code>restart === :fr</code>)</li></ul></li><li><code>f_grad</code> function for computing the gradient of <span>$f(x)$</span></li><li><code>f_L</code> Lipschitz constant of the gradient of <span>$f(x)$</span></li></ul><p><strong>option</strong></p><ul><li><code>f_mu</code> strong convexity parameter of <span>$f(x)$</span>; default 0.<ul><li>if <code>f_mu &gt; 0</code>, <span>$(\alpha, \beta_k, \gamma_k)$</span> is chosen by Table 1 in [KF18]</li></ul></li><li><code>g_prox</code> function <code>g_prox(z,c)</code> for the proximal operator for <span>$g(x)$</span><ul><li><code>g_prox(z,c)</code> computes <span>$argmin_x 1/2 \|z-x\|^2 + c \, g(x)$</span></li></ul></li><li><code>mom</code> momentum option<ul><li><code>:pogm</code> POGM (fastest); default!</li><li><code>:fpgm</code> (FISTA), <span>$\gamma_k = 0$</span></li><li><code>:pgm</code> PGM (ISTA), <span>$\beta_k = \gamma_k = 0$</span></li></ul></li><li><code>restart</code> restart option<ul><li><code>:gr</code> gradient restart; default!</li><li><code>:fr</code> function restart</li><li><code>:none</code> no restart</li></ul></li><li><code>restart_cutoff</code> for <code>:gr</code> restart if cos(angle) &lt; this; default 0.</li><li><code>bsig</code> gradient &quot;gamma&quot; decrease option (value within [0 1]); default 1<ul><li>see <span>$\bar{\sigma}$</span> in [KF18]</li></ul></li><li><code>niter</code> number of iterations; default 10</li><li><code>fun</code> function<code>(iter, xk, yk, is_restart)</code> user-defined function evaluated each <code>iter</code> with secondary <code>xk</code>, primary <code>yk</code>, and boolean <code>is_restart</code> indicating whether this iteration was a restart</li></ul><p><strong>out</strong></p><ul><li><code>x</code> final iterate<ul><li>for PGM (ISTA): <span>$x_N = y_N$</span></li><li>for FPGM (FISTA): primary iterate <span>$y_N$</span></li><li>for POGM: secondary iterate <span>$x_N$</span>, see [KF18]</li></ul></li><li><code>out [fun(0, x0, x0, false), fun(1, x1, y1, is_restart), ...]</code> array of length <code>[niter+1]</code></li></ul><p>Optimization Problem: Nonsmooth Composite Convex Minimization</p><ul><li><span>$argmin_x F(x),  F(x) := f(x) + g(x))$</span><ul><li><span>$f(x)$</span> smooth convex function</li><li><span>$g(x)$</span> convex function, possibly nonsmooth and &quot;proximal-friendly&quot; [CP11]</li></ul></li></ul><p><strong>Optimization Algorithms:</strong></p><p>Accelerated First-order Algorithms when <span>$g(x) = 0$</span> [KF18] iterate as below for given coefficients <span>$(\alpha, \beta_k, \gamma_k)$</span></p><ul><li>For k = 0,1,...<ul><li><span>$y_{k+1} = x_k - \alpha  f&#39;(x_k)$</span> : gradient update</li><li><span>$x_{k+1} = y_{k+1} + \beta_k  (y_{k+1} - y_k) + \gamma_k  (y_{k+1} - x_k)$</span> : momentum update</li></ul></li></ul><p>Proximal versions of the above for <span>$g(x) \neq 0$</span> are in the below references, and use the proximal operator <span>$prox_g(z) = argmin_x {1/2\|z-x\|^2 + g(x)}$</span>.</p><ul><li>Proximal Gradient method (PGM or ISTA) - <span>$\beta_k = \gamma_k = 0$</span>. [BT09]</li><li>Fast Proximal Gradient Method (FPGM or FISTA) - <span>$\gamma_k = 0$</span>. [BT09]</li><li>Proximal Optimized Gradient Method (POGM) - [THG15]</li><li>FPGM(FISTA) with Restart - [OC15]</li><li>POGM with Restart - [KF18]</li></ul><p><strong>references</strong></p><ul><li>[CP11] P. L. Combettes, J. C. Pesquet,</li></ul><p>&quot;Proximal splitting methods in signal processing,&quot;  Fixed-Point Algorithms for Inverse Problems in Science and Engineering,  Springer, Optimization and Its Applications, 2011.</p><ul><li>[KF18] D. Kim, J.A. Fessler,</li></ul><p>&quot;Adaptive restart of the optimized gradient method for convex optimization,&quot; 2018  Arxiv:1703.04641,  [http://doi.org/10.1007/s10957-018-1287-4]</p><ul><li>[BT09] A. Beck, M. Teboulle:</li></ul><p>&quot;A fast iterative shrinkage-thresholding algorithm for linear inverse problems,&quot;  SIAM J. Imaging Sci., 2009.</p><ul><li>[THG15] A.B. Taylor, J.M. Hendrickx, F. Glineur,</li></ul><p>&quot;Exact worst-case performance of first-order algorithms  for composite convex optimization,&quot; Arxiv:1512.07516, 2015,  SIAM J. Opt. 2017  [http://doi.org/10.1137/16m108104x]</p><p>Copyright 2017-3-31, Donghwan Kim and Jeff Fessler, University of Michigan 2018-08-13 Julia 0.7.0 2019-02-24 interface redesign</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/pogm_restart.jl#L17-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.poweriter-Tuple{Any}" href="#MIRT.poweriter-Tuple{Any}"><code>MIRT.poweriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">v1,σ1 = poweriter(A; niter=?, ...)</code></pre><p>Determine first right singular vector <code>v1</code> and first singular value <code>σ1</code> of <code>A</code> by applying power iteration to <code>A&#39;A</code></p><p><strong>in</strong></p><ul><li><code>A</code> M × N matrix</li></ul><p><strong>option</strong></p><ul><li><code>niter</code> default 200</li><li><code>x0</code> initial guess of <code>v1</code></li><li><code>tol</code> stopping tolerance for s1, default 1e-6</li><li><code>chat::Bool</code> verbose? default false</li></ul><p><strong>out</strong></p><ul><li><code>v1</code> <code>[N]</code> principal right singular vector</li><li><code>σ1</code> spectral norm of <code>A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/algorithm/general/poweriter.jl#L11-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.rect-Tuple{Real}" href="#MIRT.rect-Tuple{Real}"><code>MIRT.rect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rect(x::Real)</code></pre><p>Unit width rect function. Potential problem? Bring up with fess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/rect.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}" href="#MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}"><code>MIRT.reverser</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = reverser(x, dims)</code></pre><p>reverse array along specified dimensions (or all if unspecified)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/reverser.jl#L10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}" href="#MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}"><code>MIRT.rmsd100</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmsd = rmsd100(x, y ; mask)</code></pre><p>Compute 100 * RMSD (root mean squared difference) between <code>x</code> and <code>y</code> within domain mask.</p><p><strong>in</strong></p><ul><li><code>x</code> : array</li><li><code>y</code> : another array of same size</li></ul><p><strong>option</strong></p><ul><li><code>mask::Array{Bool}</code> : domain over which to compute the RMSE; default <code>trues(size(x))</code></li></ul><p><strong>out</strong></p><ul><li>rmsd : rmsd of <code>x</code> vs <code>y</code> within <code>mask</code> in %</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/utility/rmsd100.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.rotate2d-Tuple{Any, Any, Any}" href="#MIRT.rotate2d-Tuple{Any, Any, Any}"><code>MIRT.rotate2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(xr,yr) = rotate2d(x, y, theta)</code></pre><p>2D rotation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/fbp/rotate2d.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}" href="#MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}"><code>MIRT.snr2sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snr2sigma(db, yb)</code></pre><p>Convert SNR in dB to noise σ for complex gaussian noise. No <code>sqrt(2)</code> factors is needed here because <code>randn(Complex{Float})</code> already accounts for that. (See <code>randn</code> documentation.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/mri/coil_compress.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIRT.@shows-Tuple{Any}" href="#MIRT.@shows-Tuple{Any}"><code>MIRT.@shows</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@shows expr</code></pre><p>Show the type and size of an expression <code>expr</code> (typically a variable).</p><p>More concise output than <code>@show</code> and typically this is all that is needed when debugging code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/75b1b4a538070b335e101df03274d23964aa66e3/src/io/shows.jl#L25-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generated/examples/1-mirt/">MIRT overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 19 May 2024 17:14">Sunday 19 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
