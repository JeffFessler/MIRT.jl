var documenterSearchIndex = {"docs":
[{"location":"toc/","page":"Table of Contents","title":"Table of Contents","text":"","category":"page"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"EditURL = \"https://github.com/JeffFessler/MIRT.jl/blob/main/docs/lit/examples/1-mirt.jl\"","category":"page"},{"location":"examples/1-mirt/#mirt","page":"MIRT overview","title":"MIRT overview","text":"","category":"section"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"This is a placeholder","category":"page"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"","category":"page"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#function_reference","page":"Function References","title":"Function References","text":"","category":"section"},{"location":"reference/","page":"Function References","title":"Function References","text":"Modules = [MIRT]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/#Base.show-Tuple{IO, ImageGeom}","page":"Function References","title":"Base.show","text":"show(io::IO, ig::ImageGeom)\nshow(io::IO, ::MIME\"text/plain\", ig::ImageGeom)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, SinoGeom}","page":"Function References","title":"Base.show","text":"show(io::IO, sg::SinoGeom)\nshow(io::IO, ::MIME\"text/plain\", sg::SinoGeom)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.Afft-Union{Tuple{AbstractArray{Bool, D}}, Tuple{S}, Tuple{D}} where {D, S<:Number}","page":"Function References","title":"MIRT.Afft","text":"A = Afft(samp::AbstractArray{Bool} ; T::DataType = ComplexF32)\n\nMake a LinearMapAO object for (under-sampled) FFT, of type T, using given sampling pattern samp. Especially for compressed sensing MRI with Cartesian sampling.\n\nOption:\n\noperator::Bool=true set to false to return a LinearMapAM\nwork::AbstractArray work space for in-place fft operations\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.Anufft-Tuple{AbstractArray{<:Real}, Int64}","page":"Function References","title":"MIRT.Anufft","text":"Anufft(ω, N ; kwargs ...)\n\nMake a LinearMapAO object of size length(ω) × prod(N). See nufft_init for options.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.Aodwt","text":"A, levels, mfun = Aodwt(dims ; level::Int=3, wt=wavelet(WT.haar))\n\nCreate orthogonal discrete wavelet transform (ODWT) LinearMapAA\n\nin\n\ndims::Dims tuple of dimensions\n\noption\n\nlevel::Int # of levels; default 3\nwt wavelet transform type (see Wavelets package); default Haar\noperator::Bool=true default to LinearMapAO\n\nout\n\nA a LinearMapAX object\nscales array of size dims showing the scale of each coefficient\n\nwhich is useful when imposing scale-dependent regularization\n\nmfun convenience function for A*X when X is a Matrix or Array (not vector)\n\n2019-02-23 Jeff Fessler, University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT._down_round-Union{Tuple{D}, Tuple{Tuple{Vararg{Real, D}}, Tuple{Vararg{Number, D}}, Tuple{Vararg{Int64, D}}}} where D","page":"Function References","title":"MIRT._down_round","text":"(n,d) = _down_round()\n\nhelper function needed to downsample image_geom\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.caller_name-Tuple{}","page":"Function References","title":"MIRT.caller_name","text":"caller_name() or caller_name(;level=4)\n\nReturn \"filename line fun():\" as a string to describe where this function was called.\n\nStack levels:\n\n1: #caller_name\n2: caller_name()\n3: function that invoked caller()\n4: the calling function we want to return\n\nHence the default level is 4, but we increment it by one in case user says @show caller_name() in which case stack[3] is a macro expansion.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cbct-Union{Tuple{ImageGeom{3, S}}, Tuple{S}} where S<:Tuple{Real, Real, Real}","page":"Function References","title":"MIRT.cbct","text":"cbct(ig::ImageGeom{3,<:Real}; nthread::Int=1)\n\nConstructor for MIRT_cbct_ig (does not support units currently)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cuboid_im-Tuple{ImageGeom, AbstractMatrix{<:Real}}","page":"Function References","title":"MIRT.cuboid_im","text":"phantom = cuboid_im(ig, params ;\noversample=1, hu_scale=1, how=:auto, return_params=false)\n\ngenerate cuboid phantom image from parameters: \t[x_center y_center z_center x_diameter y_diameter z_diameter \t\txy_angle_degrees z_angle_degrees amplitude]\n\nin\n\nig::ImageGeom\nparams [N 9] cuboid parameters (\"diameter\" not \"radius\")\n\noptions\n\noversample::Int oversampling factor (for partial volume)\nhow::Symbol\n:sample use samples\n:lowmem1 one slice per time\n:exact perfect partial volume if *angle* = 0\ndefault: :exact if non rotated, else :sample\nreturn_params::Bool\tif true, return both phantom and params\n\nout\n\nphantom [nx ny nz] image\nparams [N 9] cuboid parameters (only return if return_params=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cuboid_im-Tuple{ImageGeom, Symbol}","page":"Function References","title":"MIRT.cuboid_im","text":"phantom = cuboid_im(ig, code, args...)\n\ncode = :default | :rotate # add more options\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cuboid_im-Tuple{ImageGeom}","page":"Function References","title":"MIRT.cuboid_im","text":"phantom = cuboid_im(ig ; args...)\n\n:default default parameters\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cuboid_im_exact-NTuple{10, Any}","page":"Function References","title":"MIRT.cuboid_im_exact","text":"cuboid_im_exact()\n\n:exact\n\nnon-rotated cuboid – rotation not done\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cuboid_im_lowmem1-NTuple{10, Any}","page":"Function References","title":"MIRT.cuboid_im_lowmem1","text":"cuboid_im_lowmem1(...)\n\nThis version does :sample 1 slice at a time to reduce memory\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.cuboid_im_sample-NTuple{10, Any}","page":"Function References","title":"MIRT.cuboid_im_sample","text":"cuboid_im_sample()\n\n:sample\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{<:Number}, Tuple{Vararg{Int64, D}}}} where D","page":"Function References","title":"MIRT.diff_adj","text":"Z = diff_adj(dx, N::Dims{D} ; dims = 1:D)\n\nAdjoint of finite differences of arrays along one or more dimensions. By default performs the same operations as vec(Z) = (I_N_d otimes cdots otimes D_N_1) dots (D_N_d otimes cdots otimes I_N_1) * d where D_N denotes the N-1 × N 1D finite difference matrix and ⊗ denotes the Kronecker product, but does it efficiently without using spdiagm (or any SparseArrays function).\n\nin\n\ndx vector of typical length N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1\nN::Dims desired output size\n\noption\n\ndims dimension(s) for performing adjoint finite differences; default 1:ndims(X)\n\nout\n\nZ N_1 × ... × N_d array by default\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diff_forw-Union{Tuple{AbstractArray{<:Number, D}}, Tuple{D}} where D","page":"Function References","title":"MIRT.diff_forw","text":"d = diff_forw(X ; dims = 1:ndims(X))\n\nFinite differences along one or more dimensions of an array, e.g., for anisotropic TV regularization.\n\nBy default performs the same operations as d = (I_N_d otimes cdots otimes D_N_1) dots (D_N_d otimes cdots otimes I_N_1) vec(X) where D_N denotes the N-1 × N 1D finite difference matrix and ⊗ denotes the Kronecker product, but does it efficiently without using spdiagm (or any SparseArrays function).\n\nInput dimension N must exceed 1 for each dimension specified by dims.\n\nin\n\nX N_1 × ... × N_d array (typically an N-D image).\n\noption\n\ndims dimension(s) for performing finite differences; default 1:ndims(X)\n\nmust have unique elements and be a nonempty subset of 1:ndims(X)\n\nout\n\nd vector of default length N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D","page":"Function References","title":"MIRT.diff_map","text":"T = diff_map(N::Dims{D} ; dims = 1:D)\n\nin\n\nN::Dims image size\n\nout\n\nT LinearMapAA object for computing finite differences via T*x\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}","page":"Function References","title":"MIRT.diffl!","text":"diffl!(g::AbstractArray, x::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nWhen x is a N-dimensional array, the ith slice of the g array (along its last dimension) is the diffl! of x along dims[i]. This is useful for total variation (TV) and other regularizers that need finite differences along multiple dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}","page":"Function References","title":"MIRT.diffl!","text":"diffl!(g::AbstractArray, x::AbstractArray, dim::Int ; ...)\n\nApply left finite difference operator to input array x, storing the result \"in-place\" in pre-allocated output array g. (The letter g is mnemonic for \"gradient\".)\n\nArrays g and x must have the same size, and cannot alias. By default, the \"first\" elements of g are zero for dimension dim. The default is dim=1.\n\nOption:\n\nadd::Bool = false use x[i] + x[i-1] instead of x[i] - x[i-1] (useful for certain diagonal majorizers).\nedge::Symbol = :zero set the first elements of dimension dim to 0\nChoose edge=:circ to use circulant (aka periodic) boundary conditions.\nChoose edge=:none to leave the first elements untouched.\n\nExample\n\njulia> x = [2, 6, 7]; g = similar(x); diffl!(g, x)\n3-element Vector{Int64}:\n 0\n 4\n 1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}","page":"Function References","title":"MIRT.diffl","text":"g = diffl(x::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nAllocating version of diffl! for dims\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl-Tuple{AbstractArray, Int64}","page":"Function References","title":"MIRT.diffl","text":"g = diffl(x::AbstractArray, dim::Int ; ...)\n\nAllocating version of diffl! along dim\n\nExample\n\njulia> x = [1,2] .+ [10 30 70]; g = diffl(x, 2)\n2×3 Matrix{Int64}:\n 0  20  40\n 0  20  40\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl-Tuple{AbstractArray}","page":"Function References","title":"MIRT.diffl","text":"g = diffl(x::AbstractArray ; ...)\n\nAllocating version of diffl! along dim=1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}","page":"Function References","title":"MIRT.diffl_adj!","text":"diffl_adj!(z::AbstractArray, g::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nAdjoint of diffl! for multiple dimensions dims. Here g must have one more dimension than z.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}","page":"Function References","title":"MIRT.diffl_adj!","text":"diffl_adj!(z, g, dim::Int ; ...)\n\nAdjoint of left finite difference diffl!, in-place. Arrays z and g must be same size. See diffl_adj for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj-Tuple{AbstractArray, Int64}","page":"Function References","title":"MIRT.diffl_adj","text":"z = diffl_adj(g::AbstractArray, dim::Int ; ...)\n\nAllocating version of diffl_adj! along dim.\n\nExample\n\njulia> g = ones(Int,2,3); z = diffl_adj(g, 2)\n2×3 Matrix{Int64}:\n -1  0  1\n -1  0  1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj-Tuple{AbstractArray}","page":"Function References","title":"MIRT.diffl_adj","text":"z = diffl_adj(g::AbstractArray ; ...)\n\nAllocating version of diffl_adj! along dim=1.\n\nExample\n\njulia> g = [0, 2, 5]; z = diffl_adj(g)\n3-element Vector{Int64}:\n -2\n -3\n  5\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}","page":"Function References","title":"MIRT.diffl_adj","text":"z = diffl_adj(g::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nAllocating version of diffl_adj! for dims.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D","page":"Function References","title":"MIRT.diffl_map","text":"T = diffl_map(N::Dims{D}, dims::AbstractVector{Int} ; kwargs...)\nT = diffl_map(N::Dims{D}, dim::Int ; kwargs...)\n\nin\n\nN::Dims image size\n\noptions: see diffl!\n\nT::Type for LinearMapAA, default Float32\noperator::Bool = true use false for LinearMapAM\n\nout\n\nT LinearMapAA object for computing finite differences via T*x\n\nusing diffl! and diffl_adj!\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.disk_phantom_params-Tuple{}","page":"Function References","title":"MIRT.disk_phantom_params","text":"params = disk_phantom_params( ; ...)\n\nGenerate ellipse phantom parameters for a head-sized disk plus many disks within it, designed so that the disks have some minimum separation minsep to avoid overlap and to simplify patch-based model fitting.\n\nArguments\n\nfov::Real = 240 image field of view in mm\nrhead::Real = 100 background radius for \"head\" [mm]\nmuhead::Real = 1000 \"mu\" (intensity) value for background head disk\nrmin::Real = 10 min radius for random disks\nrmax::Real = 20 max radius for random disks\nmumin::Real = 100 range of \"mu\" values for disks\nmumax::Real = 300\nndisk::Int = 10 # of random disks\nminsep::Real = 8 minimum disk separation in mm\nmaxtry::Int = 500 give up on adding more disks if this is reached\nwarn::Bool = false warn if maxtry reached?\nseed::Int = 0 if nonzero then use this seed\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample-Union{Tuple{T}, Tuple{T, Int64}} where T<:MIRT.SinoParallel","page":"Function References","title":"MIRT.downsample","text":"sg = downsample(sg, down)\n\ndown-sample (for testing with small problems)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample1-Tuple{AbstractVector{<:Number}, Int64}","page":"Function References","title":"MIRT.downsample1","text":"y = downsample1(x, down ; warn=true)\n\ndownsample 1D vector by factor down\n\nin\n\nx [n1]\ndown::Int downsampling factor\n\noption\n\nwarn::Bool warn if noninteger multiple; default isinteractive()\n\nout\n\ny [n1/down]\n\nCopyright 2019-03-05, Jeff Fessler, University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample2-Tuple{AbstractMatrix{<:Number}, Tuple{Int64, Int64}}","page":"Function References","title":"MIRT.downsample2","text":"y = downsample2(x, down ; warn=true, T)\n\ndownsample by averaging by integer factors in\n\nx [nx ny]\ndown can be a scalar (same factor for both dimensions) or a NTuple{2,Int}\n\noption\n\nwarn::Bool warn if noninteger multiple; default isinteractive()\nT::DataType specify output eltype; default eltype(x[1] / down[1])\n\nout\n\ny [nx/down ny/down]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample3-Tuple{AbstractArray{<:Number, 3}, Tuple{Int64, Int64, Int64}}","page":"Function References","title":"MIRT.downsample3","text":"y = downsample3(x, down ; warn=true, T)\n\ndownsample by averaging by integer factors in\n\nx [nx ny nz]\ndown can be a scalar (same factor for all dimensions) or a NTuple{3,Int}\n\noption\n\nwarn::Bool warn if noninteger multiple; default true\nT::DataType specify output eltype; default eltype(x[1] / down[1])\n\nout\n\ny [nx/down ny/down nz/down]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample_dim1-Tuple{AbstractArray{<:Number}, Int64}","page":"Function References","title":"MIRT.downsample_dim1","text":"y = downsample_dim1(x, down ; warn::Bool)\n\ndownsample by factor down along first dimension by averaging\n\nin\n\nx [n1 (Nd)]\ndown::Int downsampling factor\n\noption\n\nwarn::Bool warn if noninteger multiple; default isinteractive()\n\nout\n\ny [n1/down (Nd)]\n\nCopyright 2019-03-05, Jeff Fessler, University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Number}}","page":"Function References","title":"MIRT.dtft","text":"X = dtft(w, x ; n_shift=?)\n\nmulti-dimensional DTFT (DSFT)\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M where here n is a CartesianIndex\n\nin\n\nw::AbstractMatrix{<:Real}\t[M,D] frequency locations (\"units\" radians/sample)\nx::AbstractArray{<:Number}\t[(Nd)] D-dimensional signal\n\noption\n\nn_shift::AbstractVector{<:Real} often is N/2; default zeros(D)\n\nout\n\nX::AbstractVector{ComplexF64} [M] DTFT\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft-Tuple{AbstractVector{<:Real}, AbstractVector{<:Number}}","page":"Function References","title":"MIRT.dtft","text":"X = dtft(w, x ; n_shift=?)\n\n1D DTFT\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M\n\nin\n\nw::AbstractVector{<:Real}\t[M] frequency locations (\"units\" radians/sample)\nx::AbstractVector{<:Number}\t[N] 1D signal\n\noption\n\nn_shift::Real often is N/2; default 0\n\nout\n\nX::AbstractVector{ComplexF64} [M] DTFT\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_adj-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Number}, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.dtft_adj","text":"x = dtft_adj(w, X, N ; n_shift=?)\n\nadjoint for multi-dimensional DTFT (DSFT)\n\nxn = sum_m=1^M Xm exp(i wm (n - n_shift)) n=0N-1 where here n is a CartesianIndex\n\nin\n\nX::AbstractVector{ComplexF64} [M] DTFT\nw::AbstractMatrix{<:Real} [M,D] frequency locations (\"units\" radians/sample)\nN::Dims\t[D] dimensions of signal x\n\noption\n\nn_shift::AbstractVector{<:Real} often is N/2; default zeros(D)\n\nout\n\nx::AbstractArray{<:Number} [(N)] D-dimensional signal\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_adj-Tuple{AbstractVector{<:Real}, AbstractVector{<:Number}, Int64}","page":"Function References","title":"MIRT.dtft_adj","text":"x = dtft_adj(w, X, N ; n_shift=?)\n\nadjoint for 1D DTFT\n\nxn = sum_m=1^M Xm exp(i wm (n - n_shift)) n=0N-1\n\nThis is the adjoint (transpose) of dtft, not an inverse DTFT.\n\nin\n\nw::AbstractVector{<:Real}\t[M] frequency locations (\"units\" radians/sample)\nX::AbstractVector{ComplexF64}\t[M] spectrum values\nN::Int size of signal x\n\noption\n\nn_shift::Real often is N/2; default 0\n\nout\n\nx::AbstractVector{<:Number}\tsignal [N]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_init-Tuple{AbstractMatrix{<:Real}, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.dtft_init","text":"d = dtft_init(w, N ; n_shift=?)\n\nfor multi-dimensional DTFT (DSFT)\n\nin\n\nw::AbstractMatrix{<:Real}\t[M,D] frequency locations (\"units\" radians/sample)\nN::Dims [D] dimensions of signal x\n\noption\n\nn_shift::AbstractVector{<:Real} often is N/2; default zeros(D)\nT::DataType default ComplexF64 for testing NUFFT accuracy\n\nout\n\nd::NamedTuple with fields\n\n`dtft = x -> dtft(x), adjoint = y -> dtft_adj(y), A=LinearMapAO`\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_init-Tuple{AbstractVector{<:Real}, Int64}","page":"Function References","title":"MIRT.dtft_init","text":"d = dtft_init(w, N ; n_shift=?)\n\nfor 1D DTFT\n\nin\n\nw::AbstractVector{<:Real}\t[M] frequency locations (\"units\" radians/sample)\nN::Int size of signal x\n\noption\n\nn_shift::Real often is N/2; default 0\nT::DataType default ComplexF64 for testing NUFFT accuracy\n\nout\n\nd::NamedTuple with fields\n\n`dtft = x -> dtft(x), adjoint = y -> dtft_adj(y), A=LinearMapAO`\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{ImageGeom, AbstractMatrix{<:Number}}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(ig, params ;\nrot=0, oversample=1, hu_scale=1, replace=false)\n\nGenerate ellipse phantom image from parameters:\n\n[x_center y_center x_radius y_radius angle_degrees amplitude]\n\nin\n\nig\t\tfrom image_geom()\nparams\t[ne 6] ellipse parameters\n\nArguments\n\nrot\t\t\trotate ellipses by this amount [degrees]\noversample\toversampling factor, for grayscale boundaries\nhu_scale\tuse 1000 to scale shepp-logan to HU\nreplace\t\treplace ellipse values if true, else add\nhow\t\t\t:fast is the only option\n\nout\n\nphantom\t\t[nx ny]\timage (Float32)\n\nnote: op ellipse in aspire with nsub=3 is oversample=4 = 2^(3-1) here\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{ImageGeom, Symbol}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(ig, code ; kwarg...)\n\ncode = :shepplogan | :shepplogan_emis | :shepplogan_brainweb | :southpark\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{ImageGeom}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(ig ; kwarg...)\n\n:shepplogan (default) for given image geometry ig\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{Int64, Any}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(nx::Int, params ; kwarg...)\n\nsquare image of size nx by nx with pixel size dx=1 and ellipse params\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{Int64, Int64}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(nx::Int, ny::Int ; kwarg...)\n\n:shepplogan_emis of size nx by ny\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{Int64, Number, Any}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(nx, dx, params ; kwarg...)\n\nsquare image of size nx × nx, specifying pixel size dx and ellipse params\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im-Tuple{Int64}","page":"Function References","title":"MIRT.ellipse_im","text":"phantom = ellipse_im(nx::Int ; ny::Int=nx, dx::Number=1, kwarg...)\n\nimage of size nx by ny (default nx) with specified dx (default 1), defaults to :shepplogan_emis\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im_fast!-NTuple{12, Any}","page":"Function References","title":"MIRT.ellipse_im_fast!","text":"phantom = ellipseimfast!()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_im_params-Tuple{ImageGeom, Symbol}","page":"Function References","title":"MIRT.ellipse_im_params","text":"params = ellipse_im_params(ig::ImageGeom, params::Symbol)\n\ncode = :shepplogan | :shepplogan_emis | :shepplogan_brainweb | :southpark | :disks\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_sino-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, AbstractMatrix{<:Real}}","page":"Function References","title":"MIRT.ellipse_sino","text":"sino = ellipse_sino(rg::AbstractArray{<:Real}, ϕg::AbstractArray{<:Real}, \t\tells ; oversample=1, xscale=1, yscale=1)\n\nCreate sinogram projection of one or more ellipses, for arbitrary radial/angular sampling grid locations (rg, ϕg)\n\nin\n\nrg::AbstractArray{<:Real}\tradial sampling locations\nϕg::AbstractArray{<:Real}\tangular sampling locations (radians)\nells::Matrix [ne 6] ellipse parameters\n[centx centy radx rady angle_degrees amplitude]\n\noptions\n\nxscale::Int use -1 to flip in x (not recommended); default 1\nyscale::Int use -1 to flip in y (not recommended); default 1\n\nout\n\nsino::AbstractArray{Float32} same size as rg and ϕg\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipse_sino-Tuple{SinoGeom, AbstractMatrix{<:Real}}","page":"Function References","title":"MIRT.ellipse_sino","text":"sino = ellipse_sino(sg, ells ; oversample=1, xscale=1, yscale=1)\n\nCreate sinogram projection of one or more ellipses. Works for any sinogram geometry.\n\nin\n\nsg::SinoGeom sinogram geometry object from sino_geom()\nells::Matrix [ne 6] ellipse parameters\n[centx centy radx rady angle_degrees amplitude]\n\noptions\n\noversample::Int\toversampling factor for emulating \"strips\"\ndefault 1: just 1 ray per detector element\nxscale::Int\t\tuse -1 to flip in x (not recommended); default 1\nyscale::Int\t\tuse -1 to flip in y (not recommended); default 1\n\nout\n\nsino [nb na] sinogram\n\nTo get the sample locations, use (pos,ang) = sg.grid\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipsoid_im-Tuple{ImageGeom, AbstractMatrix{<:Number}}","page":"Function References","title":"MIRT.ellipsoid_im","text":"phantom = ellipsoid_im(ig, params;\noversample=1, checkfov=false, how=:slow, showmem=false, hu_scale=1, return_params=false)\n\ngenerate ellipsoid phantom image from parameters: [x_center, y_center, z_center, x_radius, y_radius, z_radius, \txy_angle_degrees, z_angle_degrees, density]\n\nin\n\nig::ImageGeom\tfrom image_geom()\nparams\t\t\t[N 9] ellipsoid parameters.\n\noption\n\noversample::Int\t\toversampling factor (default:1)\ncheckfov::Bool\t\twarn if any ellipsoid is out of fov\nhow::Symbol\n:fast does it fast – to do, only works slow\n:lowmem uses less memory than :fast but slower\n:slow default\nshowmem::Bool\nhu_scale::Number use 1000 to scale shepp-logan to HU; default 1\nreturn_params::Bool\t\tif true, return both phantom and params\n\nout\n\nphantom\t\t[nx ny nz] image\nparams\t\t[N 9] ellipsoid parameters (only if return_params=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipsoid_im-Tuple{ImageGeom, Symbol}","page":"Function References","title":"MIRT.ellipsoid_im","text":"phantom = ellipsoid_im(ig, ptype ; args...)\n\nptype = :zhu | :kak | :e3d | :spheroid\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipsoid_im-Tuple{ImageGeom}","page":"Function References","title":"MIRT.ellipsoid_im","text":"phantom = ellipsoid_im(ig ; args...)\n\n:zhu (default) for given image geometry ig\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ellipsoid_im_slow!-NTuple{13, Any}","page":"Function References","title":"MIRT.ellipsoid_im_slow!","text":"ellipsoid_im_slow!()\n\nbrute force fine grid - can use lots of memory\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{<:Number}, AbstractArray{Bool, D}}} where {T, D}","page":"Function References","title":"MIRT.embed!","text":"embed!(array, v, mask ; filler=0)\n\nembed vector v of length sum(mask) into elements of array where mask is true, setting the remaining elements to filler (default 0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.embed-Tuple{AbstractMatrix{<:Number}, AbstractArray{Bool}}","page":"Function References","title":"MIRT.embed","text":"array = embed(matrix::AbstractMatrix{<:Number}, mask::AbstractArray{Bool})\n\nEmbed each column of matrix into mask then cat along next dimension In:\n\nmatrix [sum(mask) L]\nmask [(N)]\n\nOut:\n\narray [(N) L]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T<:Number","page":"Function References","title":"MIRT.embed","text":"array = embed(v, mask ; filler=0)\n\nembed vector v of length sum(mask) into elements of an array where mask is true; see embed!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.eql_root-Tuple{Real, Real, Real}","page":"Function References","title":"MIRT.eql_root","text":"x = eql_root(a,b,c)\nNumerically stable method for computing the positive root\nof the quadratic polynomial `-ax^2 - 2bx + c, a >= 0`.\nAssumes solvable equations; will throw otherwise.\n\nin\n\na : The negative of the x^2 term. Must be positive.\nb : Half the negative of the x term.\nc : The constant term.\n\nout\n\nx : The positive root that satisfies 0 = -ax^2 - 2bx + c.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.exp_mult-Tuple{Any, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Function References","title":"MIRT.exp_mult","text":"D = exp_mult(A, u, v ; warnboth)\n\nMemory efficient and fast implementation of D = A' * exp(-u * v^T) that is useful for B0-field-corrected MRI image reconstruction.\n\nin:\n\nA [N L] matrix\nu [N] vector\nv [M] vector\nwarnboth warn if both u and v are complex; default: true\n\nout:\n\nD [L M] complex vector: D = A' * exp(-u * v^T)\n\nD_lm = sum_n A_nl^* exp(-u_n v_m)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.exp_xform-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Function References","title":"MIRT.exp_xform","text":"exp_xform(x, u, v ; mode::Symbol = :matrix)\n\nin:\n\nx [N L] possibly complex vector(s)\nu [D N] possibly complex vectors\nv [D M] possibly complex vectors\nmode::Symbol :matrix (default) | :element | :row | :column\n\nout:\n\ny [M L] typically complex vector\n\ny[m,l] = sum_n x[n,l] exp(-sum(u[:,n] .* v[:,m]))\n\nIterates through subsets of the ML matrix designated by :mode (i.e. row, column, element, or just computing the entire matrix) This is the 'slow' 'exact' transform model for MRI.\n\nOutput type will depend on input types.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.genkspace-NTuple{8, Any}","page":"Function References","title":"MIRT.genkspace","text":"genkspace\n\nGenerate the proper length of k-space trajectory.\n\nIt linearly interpolates the output of genspiral to the correct length() & takes care of the rotations for the interleaves.\n\nld is the length of the data\nnint is the number of interleaves\n\nBrad Sutton; University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.genspi-Tuple{Any, Any}","page":"Function References","title":"MIRT.genspi","text":"Gx, Gy, kx, ky, sx, sy, gts = genspi(...)\n\nThis is translation of C code from scanner: exactly what is played out to gradients at 4us.\n\nmulti-shot spiral design uses Duyn's approximate slewrate limited design augmented with archimedian gmax limit in [args]\n\nD = FOV; cm\nN = matrix size()\nTmax = longest acquisition allowed; s\ndts = output sample spacing; s\ngtype = trajectory type()\n\noption [CVs]\n\nnl = number of interleaves\ngamp = design grad max; G/cm\ngslew = design slew rate; mT/m/ms\nnramp = number of rampdown points; default 0\n\nout\n\nGx; Gy\n\ntime is in sec()\n\nrev 0 12/26/98\toriginal\nrev 1 4/15/99\tlittle better calc of ts\n\nBorrowed from Doug Noll; Univ. of Michigan. Modified to take more input cv's.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}","page":"Function References","title":"MIRT.getindex!","text":"getindex!(y::AbstractVector, x::AbstractArray{T,D}, mask::AbstractArray{Bool,D})\n\nEquivalent to the in-place y .= x[mask] but is non-allocating.\n\nFor non-Boolean indexing, just use @views y .= A[index], per https://discourse.julialang.org/t/efficient-non-allocating-in-place-getindex-for-bitarray/42268\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ig_downsample-Union{Tuple{S}, Tuple{D}, Tuple{ImageGeom{D, S}, Tuple{Vararg{Int64, D}}}} where {D, S}","page":"Function References","title":"MIRT.ig_downsample","text":"ig_down = ig_downsample(ig, down::Tuple{Int})\n\ndown sample an image geometry by the factor down cf image_geom_downsample\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom-Tuple{}","page":"Function References","title":"MIRT.image_geom","text":"ig = image_geom(...)\n\nConstructor for ImageGeom, where dx,dy,dz and fov and fovz may have units\n\nArguments\n\nnx::Int = 128\nny::Int = nx\ndx::RealU = ? (must specify one of dx or fov)\ndy::RealU = -dx\noffset_x::Real = 0 (unitless)\noffset_y::Real = 0 (unitless)\nfov::RealU = ? (if specified, then nx*dx=ny*dy)\nnz::Int = 0\ndz::RealU = ? (need one of dz or zfov if nz > 0)\nzfov::RealU = ? (if specified, then nz*dz)\noffset_z::Real = 0 (unitless)\noffsets::Symbol = :none or :dsp\nmask::Union{Symbol,AbstractArray{Bool}} = :all | :circ | :all_but_edge_xy\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom_add_unitv-Union{Tuple{AbstractArray{T, D}}, Tuple{D}, Tuple{T}} where {T<:Number, D}","page":"Function References","title":"MIRT.image_geom_add_unitv","text":"out = imagegeomadd_unitv(z::AbstractArray ; j=?, i=?, c=?)\n\nadd a unit vector to an initial array z (typically of zeros)\n\noptions (use at one of these):\n\nj single index from 1 to length(z)\ni (ix, iy [,iz]) index from 1 to nx,ny\nc (cx, cy [,cz]) index from +/- n/2 center at floor(n/2)+1\n\ndefault with no arguments gives unit vector at center c=(0, 0 [,0])\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom_expand_nz-Union{Tuple{S}, Tuple{ImageGeom{3, S}, Int64}} where S","page":"Function References","title":"MIRT.image_geom_expand_nz","text":"ignew = imagegeomexpandnz(ig::ImageGeom{3}, nz_pad::Int) pad both ends\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom_help-Tuple{}","page":"Function References","title":"MIRT.image_geom_help","text":"imagegeomhelp( ; io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom_mri-Tuple{}","page":"Function References","title":"MIRT.image_geom_mri","text":"ig = image_geom_mri(varargin)\n\nSame as image_geom() but default offsets are 0.5 so that image pixel indices go from -N/2 to N/2-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom_over-Union{Tuple{D}, Tuple{ImageGeom{D, S} where S<:Tuple{Vararg{Number, D}}, Int64}} where D","page":"Function References","title":"MIRT.image_geom_over","text":"igover = imagegeom_over(ig::ImageGeom, over::Int) over-sample an image geometry by the factor over\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.image_geom_plot-Tuple{ImageGeom{2, S} where S<:Tuple{Number, Number}, Function}","page":"Function References","title":"MIRT.image_geom_plot","text":"image_geom_plot(ig, how ; kwargs...)\n\nThe how argument should be MIRTjim.jim to be useful.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.interp1-Tuple{AbstractVector{<:Real}, AbstractVector{<:Number}, Any}","page":"Function References","title":"MIRT.interp1","text":"yi = interp1(x, y, xi ; how=Gridded(Linear()), extrap=0)\n\n1D interpolation of y = f(x) at points xi\n\nIn:\n\nx::AbstractVector{<:Real}\ny::AbstractVector{<:Number}\n\nOption:\n\nhow::Interpolations.InterpolationType default Gridded(Linear())\nextrap::Any how to extrapolate, e.g., Flat(); default 0\n\nother options from Interpolations.jl are Line() Periodic() Reflect() Throw()\n\nOutput is same size as input xi\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_dump-Tuple{Any}","page":"Function References","title":"MIRT.ir_dump","text":"ir_dump(x::Any ; io::IO = stdout)\nir_dump(io::IO, x::Any)\n\nShow all the fields of a structure or NamedTuple more nicely than dump() does\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_load_brainweb_t1_256-Tuple{}","page":"Function References","title":"MIRT.ir_load_brainweb_t1_256","text":"data = ir_load_brainweb_t1_256()\n\nLoad brainweb T1-weighted MRI slice of size 256 × 256\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_coil_compress-Tuple{AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ir_mri_coil_compress","text":"(odata, σ, Vr) = ir_mri_coil_compress(idata ; ncoil)\n\nMRI coil compression via PCA. Given multiple MRI surface coil images (idata), use SVD/PCA to find a smaller number of virtual coil images (odata).\n\nIn:\n\nidata [(N) n_in]: noisy complex images (2D or 3D) for each coil\n\nOption:\n\nncoil Desired # of virtual coils (default: 1)\n\nOut:\n\nodata [(N) ncoil]: virtual coil images\nσ     [n_in]: singular values.\nVr    [n_in, ncoil]: compression matrix for reducing other data.\n\ntodo: currently ignores noise correlations\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_kspace_ga_radial-Tuple{}","page":"Function References","title":"MIRT.ir_mri_kspace_ga_radial","text":"kspace = ir_mri_kspace_ga_radial(; Nro=?, Nspoke=?, ...)\n\nGenerate k-space sampling pattern for \"golden angle\" radial sampling.\n\noption\n\nNro:Int\t\tnumber of samples in each readout/spoke, default 256\nNspoke::Int\tnumber of spokes, default 1\nstart::Real\tfirst angle in series [radians], default π/2\nangle::Real\tangular spacing [radians], default GA\ndelta_ro::Real\treadout spacing, default 1/Nro\nshift::Real\t\tshift due to gradient delays, default 0\nradial sample locations are ir * delta_ro\nwhere ir = [-(Nro/2 - 1):1:Nro/2] + shift\n\nout\n\nkspace\t[Nro Nspoke 2] (Float32)\n\nkx and ky k-space locations for Nspoke*Nro samples in interval (-0.5 0.5] for default shift, delta_ro so default units are \"cycles / sample\"\n\n2015-07 Mai Le, original Matlab version\n\n2015-07-04 Jeff Fessler, minor changes to Matlab version\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim-Tuple{Symbol}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim","text":"(smap,info) = ir_mri_sensemap_sim( :all ; kwargs)\n\nLike ir_mri_sensemap_sim but also returns info with data for all coils, mainly for testing and plotting.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim","text":"(smap,info) = ir_mri_sensemap_sim( ir_ic_pair ; kwargs)\n\nLike ir_mri_sensemap_sim but also returns info with data for specific coils where ir_ic_pair::Vector{Tuple{Int,Int}}. (Usually used internally only.)\n\ninfo::NamedTuple geometry information for plots\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim-Tuple{}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim","text":"smap = ir_mri_sensemap_sim(...)\n\nSimulate 2D or 3D sensitivity maps for sensitivity-encoded MRI based on grivich:00:tmf http://doi.org/10.1119/1.19461\n\nThis code makes maps for multiple coils, but does not model coupling between coils, so most likely it is an approximation at best.\n\noption\n\ndims::Dims\t\timage size; default (64, 64)\ndx::Real\t\tpixel/voxel dimension; default: 3\ndy::Real\t\tpixel/voxel dimension; default: dx\ndz::Real\t\t\"\"\nncoil::Int\t\t# of coils total; default 4\nnring::Int\t\t# of rings of coils; default 1\nrcoil::Real\t\tcoil radius; default dx * nx / 2 * 0.50\ndz_coil\t\t\tring spacing in z; default nz*dz/nring\n(3D geometry is a cylinder)\ncoil_distance::Real\t\tdistance of coil center from isocenter\nfor central ring of coils as a multiple of FOVx,\nwhere FOVx=nx*dx; default 1.2\norbit::Real\t\t\tdefault 360 [degrees]\norbit_start::AbstractVector{<:Real} = fill(0, nring) [degrees]\nscale::Symbol\n:none (default)\n+\tssos_center make SSoS of center = 1\n\nout\n\nsmap\t[dims ncoil]\tsimulated sensitivity maps (complex!)\n\nAll length parameters must have same units (e.g., mm or cm)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim_do","text":"(smap, info) = ir_mri_sensemap_sim_do()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_smap1-NTuple{4, Any}","page":"Function References","title":"MIRT.ir_mri_smap1","text":"ir_mri_smap1()\n\nbased on grivich:00:tmf\n\nfor a circular coil in \"x-y plane\" of radius \"a\"\n\nNote that coil x-y plane is not same as object x-y plane!\n\nReturns (i,j,k) components of B vector for each (x,y,z) location\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_smap_r-Tuple{Any, Any}","page":"Function References","title":"MIRT.ir_mri_smap_r","text":"ir_mri_smap_r(r, z)\n\nfunction for testing near 0\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.jinc-Tuple{Real}","page":"Function References","title":"MIRT.jinc","text":"jinc(x)\n\nReturn jinc(x) = J1(pi*x)/(2x), where J1 is a Bessel function of the first kind.\n\nUnits of x are typically cycles/m.\n\nReturn type is promote_type(typeof(x), Float32).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.map_many","text":"y = map_many(fun::Function, x::AbstractArray{<:Any}, idim::Dims)\n\napply a function fun to leading slices of input x; cousin of mapslices\n\nin\n\nfun::Function maps input of size idim to output of some size odim\nx [idim ldim]\n\nout\n\ny [odim ldim]\n\nExample: if fun maps array of size (1,2) to array of size (3,4,5) and if input x has size (1,2,7,8) then output y will have size (3,4,5,7,8) where y[:,:,:,i,j] = fun(x[:,:,i,j])\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mask_or-Tuple{AbstractMatrix{Bool}}","page":"Function References","title":"MIRT.mask_or","text":"mask_or(mask)\n\ncompress 3D mask to 2D by logical or along z direction\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}","page":"Function References","title":"MIRT.mask_outline","text":"mask_outline(mask)\n\nreturn outer boundary of 2D mask (or mask_or for 3D)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.maskit-Tuple{AbstractArray{<:Number}, AbstractArray{Bool}}","page":"Function References","title":"MIRT.maskit","text":"maskit(x::AbstractArray{<:Number})\n\nopposite of embed\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.max_percent_diff-Tuple{Any, Any}","page":"Function References","title":"MIRT.max_percent_diff","text":"d = max_percent_diff(s1, s2, [options])\n\nCompute the \"maximum percent difference\" between two signals: s1, s2.\n\nDefault is to normalize by maximum(abs.(s1)).\n\noptions\n\nmaxboth::Bool use max of both arguments to normalize; default false\nnormalize::Bool normalize each before comparing; default false\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_kspace_spiral-Tuple{}","page":"Function References","title":"MIRT.mri_kspace_spiral","text":"kspace, omega, gradxy = mri_kspace_spiral( [options] )\n\nMake k-space spiral trajectory based on GE 3T scanner constraints\n\nOption:\n\nN dimention of reconstructed image\nNt # of time points\nfov field of view in cm\ndt time sampling interval out; default 5e-6 sec\ngamp::Real design gradient amplitude max, G/cm; default 2.2\ngslew::Int design slew rate, mT/m/ms; default 180\n\nOut:\n\nkspace [Nt,2] kspace trajectory [kx ky] in cycles/cm, NO: cycles/FOV\nomega [Nt,2] \"\" in radians\ngradxy [Nt 2] gradient waveforms in (units?)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_objects-Tuple{Symbol}","page":"Function References","title":"MIRT.mri_objects","text":"mri_objects(key::Symbol ; fov::Real=22, unit::Symbol=:mm)\n\nSpecial cases\n\nIn:\n\nfov Store the following parameter in fov.\nunit specify units; default :mm    Currently, only :cm (centimeters) supported as an alternate unit\n\nkey choices:\n\n:case1 predefined 2D test case\n:case4 predefined 3D test case\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_objects-Tuple{Tuple}","page":"Function References","title":"MIRT.mri_objects","text":"mri_objects((type,params)) for a single tuple\n\nHere the params can be a single row or column vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_objects-Tuple{Vector{<:Tuple}}","page":"Function References","title":"MIRT.mri_objects","text":"st = mri_objects([(:type1, params1), (:type2, params2), ...])\n\nGenerate object that describes image-domain objects and Fourier domain spectra of simple structures such as rectangles, disks, superpositions thereof. These functions are useful for simple \"idealized\" MRI simulations where the data is modeled as analytical Fourier samples, i.e., no field inhomogeneity and no relaxation effects.\n\nin\n\n[(type, params), ...] e.g. [(:rect2, params), (:gauss3, params), ...]\n\ntype, params:\n\n:dirac2 [N 3] [xcent ycent value]\n:dirac3 [N 4] [xcent ycent zcent value]\n:rect2 [N 5] [xcent ycent xwidth ywidth value]\n:rect3 [N 7] [xcent ycent zcent xwidth ywidth zwidth value]\n:gauss2 [N 5] [xcent ycent xwidth ywidth value]\n:gauss3 [N 7] [xcent ycent zcent xwidth ywidth zwidth value]\n:circ2 [N 5] [xcent ycent rad value]\n:cyl3 [N 6] [xcent ycent zcent xrad zwidth value]\n\nAll types must be 2D or 3D, not mixed.\n\nout\n\nst struct\nst.image(x,y)  returns 2D image-domain (sampled) picture\nst.image(x,y,z) same but 3D\nst.kspace(u,v) returns 2D Fourier-space samples\nst.kspace(u,v,w) same but 3D\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D","page":"Function References","title":"MIRT.mri_trajectory","text":"kspace, omega, wi = mri_trajectory( ; ktype, N, fov, arg_wi, kwargs...)\n\nGenerate kspace trajectory samples and density compensation functions.\n\noption\n\nktype::Symbol k-space trajectory type; default :radial\nN::Dims target image size; default (32,30)\nfov field of view in x and y (and z); default (250,250) mm\narg_wi options to pass to ir_mri_density_comp - not yet done\nkwargs options for the specific trajectory\n\nout\n\nkspace [Nk 2|3] kspace samples in units 1/fov\nomega [Nk 2|3] trajectory samples over [-π,π)\nwi [Nk 1] (optional) density compensation factors\n\ntrajectory types: :cartesian :radial :cart_y_2 :random :half8 :epi_sin :spiral0 :spiral1 :spiral3 :rosette3 :epi_under :gads (emulate golden-angle data sharing per winkelmann:07:aor)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring","page":"Function References","title":"MIRT.mri_trajectory_gads","text":"omega, wi = mri_trajectory_gads(N, fov ; ...)\n\nemulate 2D golden angle radial sampling with data sharing\n\noption: Nro # of samples in each readout/spoke shift shift along read-out due to gradient delays (stress) kmax_frac fractions of maximum krad (0.5) for rings (annuli) under under-sampling factor for each annulus\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}","page":"Function References","title":"MIRT.mri_trajectory_radial","text":"mri_trajectory_radial()\n\noption:\n\nna_nr default ensures proper sampling at edge of k-space\nna angular spokes; default: na_nr * nr\nnr radial samples per spoke\nir default: 0:nr\n\ntodo: generalize to 3D using barger:02:trc\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory_rosette3-Tuple{Any, Any}","page":"Function References","title":"MIRT.mri_trajectory_rosette3","text":"mri_trajectory_rosette3(N, fov ; ...)\n\n3d rosette, with default parameters from bucholz:08:miw\n\noptions: omax: maximum omega nt : time samples (65.536 ms for 4 usec dt) dt : time sample spacing (4 usec) ti : time samples\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.my_rect-Tuple{Any, Any}","page":"Function References","title":"MIRT.my_rect","text":"params = my_rect(xfov, yfov)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ncg-Tuple{AbstractVector, AbstractVector{<:Function}, AbstractVector{<:Function}, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ncg","text":"(x,out) = ncg(B, gradf, curvf, x0 ; ...)\n\nNonlinear preconditioned conjugate gradient algorithm to minimize a general \"inverse problem\" cost function of the form Psi(x) = sum_j=1^J f_j(B_j x) where each function f_j(v) has a quadratic majorizer of the form\n\nq_j(vu) = f_j(u) + nabla f_j(u) (v - u) + 12 v - u^2_C_j(u)\n\nwhere C_j(u) is diagonal matrix of curvatures. (It suffices for each f_j to have a Lipschitz smooth gradient.)\n\nThis CG method uses a majorize-minimize (MM) line search.\n\nin\n\nB\t\tarray of J blocks B_1B_J\ngradf\tarray of J functions return gradients of f_1f_J\ncurvf\tarray of J functions z -> curv(z) that return a scalar\n\nor a vector of curvature values for each element of z\n\nx0\tinitial guess; need length(x) == size(B[j],2) for j=1J\n\nUsually x0 is a Vector but it can be an Array if each B_j is a linear operator (e.g., LinearMapAO) of suitable \"dimensions\".\n\noption\n\nniter\t# number of outer iterations; default 50\nninner\t# number of inner iterations of MM line search; default 5\nP\t\t# preconditioner; default I\nbetahow\t\"beta\" method for the search direction; default :dai_yuan\nfun\t\tUser-defined function to be evaluated with two arguments (x,iter).\nIt is evaluated at (x0,0) and then after each iteration.\n\noutput\n\nx\t\tfinal iterate\nout\t\t[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))\n(all 0 by default). This is an array of length niter+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ncg-Tuple{Function, Function, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ncg","text":"(x,out) = ncg(grad, curv, x0, ...)\n\nspecial case of ncg (nonlinear CG) for minimizing a cost function whose gradient is grad(x) and that has a quadratic majorizer with diagonal Hessian given by curv(x). Typically curv = (x) -> L where L is the Lipschitz constant of grad\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Function References","title":"MIRT.ndgrid","text":"(xx,yy,zz) = ndgrid(x::AbstractVector{<:Any}, y::..., z::...) todo - improve?\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector}","page":"Function References","title":"MIRT.ndgrid","text":"(xx,yy) = ndgrid(x::AbstractVector{<:Any}, y::AbstractVector{<:Any}) todo - improve?\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_eltype-Tuple{Type{<:Integer}}","page":"Function References","title":"MIRT.nufft_eltype","text":"nufft_eltype(::DataType)\n\nensure plan_nfft eltype is Float32 or Float64\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_errors-Tuple{}","page":"Function References","title":"MIRT.nufft_errors","text":"w, errs = nuffterrors( ; M=?, w=?, N=?, nshift=?, ...)\n\nCompute worst-case errors for NUFFT (for signal of length N of unit norm)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_init-Tuple{AbstractArray{<:Real}, Int64}","page":"Function References","title":"MIRT.nufft_init","text":"p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=0)\n\nSetup 1D NUFFT, for computing fast O(N log N) approximation to\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M\n\nin\n\nw::AbstractArray{<:Real} [M] frequency locations (units radians/sample)\neltype(w) determines the plan_nfft type; so to save memory use Float32!\nsize(w) determines odim for A if operator=true\nN::Int signal length\n\noption\n\nnfft_m::Int\t\tsee NFFT.jl documentation; default 4\nnfft_sigma::Real\t\"\", default 2.0\nn_shift::Real\t\toften is N/2; default 0\npi_error::Bool\t\tthrow error if w  π, default true\nSet to false only if you are very sure of what you are doing!\ndo_many::Bool\tsupport extended inputs via map_many? default true\noperator::Bool=true set to false to make A an LinearMapAM\n\nout\n\np NamedTuple\n\n(nufft = x -> nufft(x), adjoint = y -> nufft_adj(y), A::LinearMapAO)\n\nThe default settings are such that for a 1D signal of length N=512, the worst-case error is below 1e-5 which is probably adequate for typical medical imaging applications. To verify this statement, run nufft_plot1() and see plot.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{<:Real}, Tuple{Vararg{Int64, D}}}} where D","page":"Function References","title":"MIRT.nufft_init","text":"p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=?)\n\nSetup multi-dimensional NUFFT, for computing fast O(N log N) approximation to\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M\n\nin\n\nw::AbstractArray{<:Real} [M,D] frequency locations (units radians/sample)\n\n+ `eltype(w)` determines the `plan_nfft` type; so to save memory use Float32!\n+ `size(w)[1:(end-1)]` determines `odim` if `operator=true`\n\nN::Dims{D} signal dimensions\n\noption\n\nnfft_m::Int\t\tsee NFFT.jl documentation; default 4\nnfft_sigma::Real\t\"\", default 2.0\nn_shift::AbstractVector{<:Real}\t[D]\toften is N/2; default zeros(D)\npi_error::Bool\t\tthrow error if w  π, default true\nSet to false only if you are very sure of what you are doing!\ndo_many::Bool\tsupport extended inputs via map_many? default true\noperator::Bool=true set to false to make A an LinearMapAM\n\nThe default do_many option is designed for parallel MRI where the k-space sampling pattern applies to every coil. It may also be useful for dynamic MRI with repeated sampling patterns. The coil and/or time dimensions must come after the spatial dimensions.\n\nout\n\np NamedTuple with fields\n\n`nufft = x -> nufft(x), adjoint = y -> nufft_adj(y), A=LinearMapAO`\n(Using `operator=true` allows the `LinearMapAO` to support `do_many`.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T","page":"Function References","title":"MIRT.nufft_typer","text":"nufft_typer(T::DataType, x::AbstractArray{<:Real} ; warn::Bool=true)\n\ntype conversion wrapper for nfft()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{<:Function}, AbstractVector{<:Function}, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ogm_ls","text":"(x,out) = ogm_ls(B, gradf, curvf, x0; niter=?, ninner=?, fun=?)\n\nOGM with a line search; Drori&Taylor @arxiv 1803.05676; to minimize a general \"inverse problem\" cost function of the form Psi(x) = sum_j=1^J f_j(B_j x) where each function f_j(v) has a quadratic majorizer of the form\n\nq_j(vu) = f_j(u) + nabla f_j(u) (v - u) + 12 v - u^2_C_j(u)\n\nwhere C_j(u) is diagonal matrix of curvatures. (It suffices for each f_j to have a Lipschitz smooth gradient.)\n\nThis OGM method uses a majorize-minimize (MM) line search.\n\nin\n\nB\t\tarray of J blocks B_1B_J\ngradf\tarray of J functions return gradients of f_1f_J\ncurvf\tarray of J functions z -> curv(z) that return a scalar\n\nor a vector of curvature values for each element of z\n\nx0\tinitial guess; need length(x) == size(B[j],2) for j=1J\n\noption\n\nniter\t# number of outer iterations; default 50\nninner\t# number of inner iterations of MM line search; default 5\nfun\t\tUser-defined function to be evaluated with two arguments (x,iter).\nIt is evaluated at (x0,0) and then after each iteration.\n\noutput\n\nx\t\tfinal iterate\nout\t\t[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))\n(all 0 by default). This is an array of length niter+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{<:Number}}","page":"Function References","title":"MIRT.ogm_ls","text":"(x,out) = ogm_ls(grad, curv, x0, ...)\n\nspecial case of ogm_ls (OGM with line search) for minimizing a cost function whose gradient is grad(x) and that has a quadratic majorizer with diagonal Hessian given by curv(x). Typically curv = (x) -> L where L is the Lipschitz constant of grad\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.pogm_restart-Tuple{Any, Function, Function, Real}","page":"Function References","title":"MIRT.pogm_restart","text":"x, out = pogm_restart(x0, Fcost, f_grad, f_L ;\nf_mu=0, mom=:pogm, restart=:gr, restart_cutoff=0.,\nbsig=1, niter=10, g_prox=(z,c)->z, fun=...)\n\nIterative proximal algorithms (PGM=ISTA, FPGM=FISTA, POGM) with restart.\n\nin\n\nx0 initial guess\nFcost function for computing the cost function value F(x)\n(needed only if restart === :fr)\nf_grad function for computing the gradient of f(x)\nf_L Lipschitz constant of the gradient of f(x)\n\noption\n\nf_mu strong convexity parameter of f(x); default 0.\nif f_mu > 0, (alpha beta_k gamma_k) is chosen by Table 1 in [KF18]\ng_prox function g_prox(z,c) for the proximal operator for g(x)\ng_prox(z,c) computes argmin_x 12 z-x^2 + c  g(x)\nmom\tmomentum option\n:pogm POGM (fastest); default!\n:fpgm (FISTA), gamma_k = 0\n:pgm PGM (ISTA), beta_k = gamma_k = 0\nrestart restart option\n:gr gradient restart; default!\n:fr function restart\n:none no restart\nrestart_cutoff for :gr restart if cos(angle) < this; default 0.\nbsig gradient \"gamma\" decrease option (value within [0 1]); default 1\nsee barsigma in [KF18]\nniter number of iterations; default 10\nfun function(iter, xk, yk, is_restart) user-defined function evaluated each iter with secondary xk, primary yk, and boolean is_restart indicating whether this iteration was a restart\n\nout\n\nx\tfinal iterate\nfor PGM (ISTA): x_N = y_N\nfor FPGM (FISTA): primary iterate y_N\nfor POGM: secondary iterate x_N, see [KF18]\nout [fun(0, x0, x0, false), fun(1, x1, y1, is_restart), ...] array of length [niter+1]\n\nOptimization Problem: Nonsmooth Composite Convex Minimization\n\nargmin_x F(x)  F(x) = f(x) + g(x))\nf(x) smooth convex function\ng(x) convex function, possibly nonsmooth and \"proximal-friendly\" [CP11]\n\nOptimization Algorithms:\n\nAccelerated First-order Algorithms when g(x) = 0 [KF18] iterate as below for given coefficients (alpha beta_k gamma_k)\n\nFor k = 0,1,...\ny_k+1 = x_k - alpha  f(x_k) : gradient update\nx_k+1 = y_k+1 + beta_k  (y_k+1 - y_k) + gamma_k  (y_k+1 - x_k) : momentum update\n\nProximal versions of the above for g(x) neq 0 are in the below references, and use the proximal operater prox_g(z) = argmin_x 12z-x^2 + g(x).\n\nProximal Gradient method (PGM or ISTA) - beta_k = gamma_k = 0. [BT09]\nFast Proximal Gradient Method (FPGM or FISTA) - gamma_k = 0. [BT09]\nProximal Optimized Gradient Method (POGM) - [THG15]\nFPGM(FISTA) with Restart - [OC15]\nPOGM with Restart - [KF18]\n\nreferences\n\n[CP11] P. L. Combettes, J. C. Pesquet,\n\n\"Proximal splitting methods in signal processing,\"  Fixed-Point Algorithms for Inverse Problems in Science and Engineering,  Springer, Optimization and Its Applications, 2011.\n\n[KF18] D. Kim, J.A. Fessler,\n\n\"Adaptive restart of the optimized gradient method for convex optimization,\" 2018  Arxiv:1703.04641,  [http://doi.org/10.1007/s10957-018-1287-4]\n\n[BT09] A. Beck, M. Teboulle:\n\n\"A fast iterative shrinkage-thresholding algorithm for linear inverse problems,\"  SIAM J. Imaging Sci., 2009.\n\n[THG15] A.B. Taylor, J.M. Hendrickx, F. Glineur,\n\n\"Exact worst-case performance of first-order algorithms  for composite convex optimization,\" Arxiv:1512.07516, 2015,  SIAM J. Opt. 2017  [http://doi.org/10.1137/16m108104x]\n\nCopyright 2017-3-31, Donghwan Kim and Jeff Fessler, University of Michigan 2018-08-13 Julia 0.7.0 2019-02-24 interface redesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.poweriter-Tuple{Any}","page":"Function References","title":"MIRT.poweriter","text":"v1,σ1 = poweriter(A; niter=?, ...)\n\nDetermine first right singular vector v1 and first singular value σ1 of A by applying power iteration to A'A\n\nin\n\nA M × N matrix\n\noption\n\nniter default 200\nx0 initial guess of v1\ntol stopping tolerance for s1, default 1e-6\nchat::Bool verbose? default false\n\nout\n\nv1 [N] principal right singular vector\nσ1 spectral norm of A\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect-Tuple{Real}","page":"Function References","title":"MIRT.rect","text":"rect(x::Real)\n\nUnit width rect function. Potential problem? Bring up with fess.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{ImageGeom, AbstractMatrix{<:Real}}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(ig, params ;\noversample=1, hu_scale=1, fov=maximum(ig.fovs), chat=false, how=:auto,\nreplace=false, return_params=false)\n\ngenerate rectangle phantom image from parameters:  [x_center y_center x_width y_width angle_degrees amplitude]\n\nin\n\nig\t\t\t\timage_geom() object\nparams\t\t\t[Nrect,6] rect parameters. if empty use default\n\noptions\n\noversample::Int\toversampling factor, for grayscale boundaries\nhu_scale::Real\t\tuse 1000 to scale\nfov::Real\t\t\tdefault maximum(ig.fovs)\nchat::Bool\t\t\tverbosity?\nhow::Symbol\t\t\t:fast or :slow; default :auto\nreplace::Bool\t\tdefault false\nreturn_params::Bool\tif true, return both phantom and params\n\nout\n\nphantom\t\t[nx ny] image (Float32)\nparams\t\t[Nrect 6] rect parameters (only return if return_params=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{ImageGeom, Symbol}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(ig, code ; args...)\n\ncode = :my_rect | :default | :smiley\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{ImageGeom}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(ig ; args...)\n\n:default (default) for given image geometry ig\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{Int64, Any}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(nx::Int, params ; args...)\n\nsquare image of size nx by nx with pixel size dx=1 and rect params\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{Int64, Int64}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(nx::Int, ny::Int ; args...)\n\n:my_rect of size nx by ny\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{Int64, Real, Any}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(nx, dx, params ; args...)\n\nsquare image of size nx by nx, specifying pixel size dx and rect params\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im-Tuple{Int64}","page":"Function References","title":"MIRT.rect_im","text":"phantom = rect_im(nx::Int ; ny::Int=nx, dx::Real=1)\n\nimage of size nx by ny (default nx) with specified dx (default 1), defaults to :my_rect\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im_default_parameters-Tuple{Any, Any}","page":"Function References","title":"MIRT.rect_im_default_parameters","text":"params = rectimdefault_parameters(xfov, yfov)\n\ndefault parameters\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im_fast-NTuple{8, Any}","page":"Function References","title":"MIRT.rect_im_fast","text":"phantom = rectimfast() for non-rotated rectangles \tusing exact integration over each pixel so over-sampling is irrelevant\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_im_slow-NTuple{8, Any}","page":"Function References","title":"MIRT.rect_im_slow","text":"phantom = rect_im_slow()\n\nfor rotated rectangles\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_sino-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, AbstractMatrix{<:Real}}","page":"Function References","title":"MIRT.rect_sino","text":"sino = rect_sino(rg::AbstractArray{<:Real}, ϕg::AbstractArray{<:Real},\n\trects ; oversample=1, xscale=1, yscale=1)\n\nCreate sinogram projection of one or more rectangles, for arbitrary radial/angular sampling grid locations (rg, ϕg)\n\nin\n\nrg::AbstractArray{<:Real}\tradial sampling locations\nϕg::AbstractArray{<:Real}\tangular sampling locations (radians)\nrects::Matrix [n 6] rectangle parameters\n[centx centy widthx widthy angle_degrees value]\n\noptions\n\nxscale::Int use -1 to flip in x (not recommended); default 1\nyscale::Int use -1 to flip in y (not recommended); default 1\n\nout\n\nsino::AbstractArray{Float32} same size as rg and ϕg\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect_sino-Tuple{SinoGeom, AbstractMatrix{<:Real}}","page":"Function References","title":"MIRT.rect_sino","text":"sino = rect_sino(sg, rects ; oversample=1, xscale=1, yscale=1)\n\nCreate sinogram projection of one or more rectangles. Works for any sinogram geometry.\n\nin\n\nsg::SinoGeom sinogram geometry object from sino_geom()\nrects::Matrix [ne 6] rectangle parameters\n[centx centy widthx widthy angle_degrees value]\n\noptions\n\noversample::Int\toversampling factor for emulating \"strips\"\ndefault 1: just 1 ray per detector element\nxscale::Int\t\tuse -1 to flip in x (not recommended); default 1\nyscale::Int\t\tuse -1 to flip in y (not recommended); default 1\n\nout\n\nsino\t\t[nb na] sinogram\n\nTo get the sample locations, use (pos,ang) = sg.grid\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.reshaper-Tuple{AbstractArray, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.reshaper","text":"reshaper(x::AbstractArray, dim:Dims)\n\nReshape x to size dim with : only if needed\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.reverser-Tuple{AbstractArray, AbstractVector{<:Int64}}","page":"Function References","title":"MIRT.reverser","text":"y = reverser(x, dims)\n\nreverse array along specified dimensions (or all if unspecified)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rmsd100-Tuple{AbstractArray{<:Number}, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.rmsd100","text":"rmsd = rmsd100(x, y ; mask)\n\nCompute 100 * RMSD (root mean squared difference) between x and y within domain mask.\n\nin\n\nx : array\ny : another array of same size\n\noption:\n\nmask::Array{Bool} : domain over which to compute the RMSE; default trues(size(x))\n\nout\n\nrmsd : rmsd of x vs y within mask in %\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rot3-NTuple{5, Any}","page":"Function References","title":"MIRT.rot3","text":"rot3\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rotate2d-Tuple{Any, Any, Any}","page":"Function References","title":"MIRT.rotate2d","text":"(xr,yr) = rotate2d(x, y, theta) 2D rotation\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.shepp_logan_3d_parameters-NTuple{4, Any}","page":"Function References","title":"MIRT.shepp_logan_3d_parameters","text":"shepp_logan_3d_parameters()\n\nmost of these values are unitless 'fractions of field of view'\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.shepp_logan_parameters-Tuple{Number, Number}","page":"Function References","title":"MIRT.shepp_logan_parameters","text":"params = shepploganparameters(xfov, yfov ; case::Symbol ; u::Tuple)\n\nShepp Logan phantom parameters from Kak and Slaney text, p. 255.\n\nBy default the first four columns are unitless \"fractions of field of view\", so columns 1,3 are scaled by xfov and columns 2,4 are scaled by xfov. The optional 3-tuple u specifies scaling and/or units:\n\ncolumns 1-4 (center, radii) are scaled by u[1] (e.g., mm),\ncolumn 5 (angle) is scaled by u[2] (e.g., 1 or °),\ncolumn 6 (value) is scaled by u[3] (e.g., 1/cm) for an attenuation map.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom-Tuple{Symbol}","page":"Function References","title":"MIRT.sino_geom","text":"function sg = sino_geom(...)\n\nConstructor for SinoGeom\n\nCreate the \"sinogram geometry\" structure that describes the sampling characteristics of a given sinogram for a 2D parallel or fan-beam system. Using this structure facilitates \"object oriented\" code. (Use ct_geom() instead for 3D axial or helical cone-beam CT.)\n\nin\n\nhow::Symbol\t:fan (fan-beam) | :par (parallel-beam) | :moj (mojette)\n\noptions for all geometries (including parallel-beam):\n\nunits::Symbol\te.g. :cm or :mm; default: :none\norbit_start\t\tdefault: 0\norbit\t\t\t[degrees] default: 180 for parallel / mojette\n\nand 360 for fan\n\ncan be :short for fan-beam short scan\ndown::Int\t\tdown-sampling factor, for testing\nnb\t\t\t\t# radial samples cf nr (i.e., ns for :fan)\nna\t\t\t\t# angular samples (cf nbeta for :fan)\nd\t\t\t\tradial sample spacing; cf dr or ds; default 1\nfor mojette this is actually dx\noffset\t\t\tcf offset_r channel_offset unitless; default 0\n(relative to centerline between two central channels).\nUse 0.25 or 1.25 for \"quarter-detector offset\"\nstrip_width\t\tdetector width; default: d\n\noptions for fan-beam\n\nsource_offset\t\tsame units as d; use with caution! default 0\n\nfan beam distances:\n\ndsd cf dis_src_det default: Inf (parallel beam)\ndod cf dis_iso_det default: 0\ndfs cf dis_foc_src default: 0 (3rd generation CT arc),\nuse Inf for flat detector\n\nout\n\nsg::SinoGeom\tinitialized structure\n\nSee also\n\nsino_geom_help() help on methods\nsino_geom_plot_grids() show sampling\n\nJeff Fessler, University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_fan-Tuple{}","page":"Function References","title":"MIRT.sino_geom_fan","text":"sg = sino_geom_fan()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_gamma-Tuple{SinoFan}","page":"Function References","title":"MIRT.sino_geom_gamma","text":"sino_geom_gamma()\n\ngamma sample values for :fan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_gamma_dfs-Tuple{SinoFan}","page":"Function References","title":"MIRT.sino_geom_gamma_dfs","text":"gamma for general finite dfs (rarely used)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_ge1-Tuple{}","page":"Function References","title":"MIRT.sino_geom_ge1","text":"sino_geom_ge1()\n\nsinogram geometry for GE lightspeed system These numbers are published in IEEE T-MI Oct. 2006, p.1272-1283 wang:06:pwl\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_grid-Tuple{SinoPar}","page":"Function References","title":"MIRT.sino_geom_grid","text":"(rg, ϕg) = sino_geom_grid(sg::SinoGeom)\n\nReturn grids rg and ϕg (in radians) of size [nb na] of equivalent parallel-beam (r,ϕ) (radial, angular) sampling positions, for any sinogram geometry. For parallel beam this is just ndgrid(sg.r, sg.ar) but for fan beam and mojette this involves more complicated computations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_help-Tuple{}","page":"Function References","title":"MIRT.sino_geom_help","text":"sino_geom_help()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_moj-Tuple{}","page":"Function References","title":"MIRT.sino_geom_moj","text":"sg = sino_geom_moj( ... )\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_over-Union{Tuple{T}, Tuple{T, Int64}} where T<:MIRT.SinoParallel","page":"Function References","title":"MIRT.sino_geom_over","text":"sg = sino_geom_over(sg, over::Int)\n\nover-sample in \"radial\" dimension For Mojette sampling, it means that d = dx/over.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_par-Tuple{}","page":"Function References","title":"MIRT.sino_geom_par","text":"sg = sino_geom_par( ... )\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_plot!-Tuple{SinoGeom, Function}","page":"Function References","title":"MIRT.sino_geom_plot!","text":"sino_geom_plot!(sg, plot! ; ig)\n\nPicture of the source position / detector geometry\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_plot_grid-Tuple{SinoGeom, Function}","page":"Function References","title":"MIRT.sino_geom_plot_grid","text":"sino_geom_plot_grid(sg, Plots.scatter) <- trick to avoid Plots.dependency\n\nScatter plot of (r,phi) sampling locations from sg.grid\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_plot_grids-Tuple{Function}","page":"Function References","title":"MIRT.sino_geom_plot_grids","text":"sino_geom_plot_grids()\n\nscatter plot of (r,phi) sampling locations for all geometries\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_rfov-Tuple{SinoPar}","page":"Function References","title":"MIRT.sino_geom_rfov","text":"sino_geom_rfov()\n\nradial FOV\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_taufun-Tuple{SinoGeom, Any, Any}","page":"Function References","title":"MIRT.sino_geom_taufun","text":"sino_geom_taufun()\n\nprojected s/ds, useful for footprint center and support\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_unitv-Tuple{SinoGeom}","page":"Function References","title":"MIRT.sino_geom_unitv","text":"sino_geom_unitv()\n\nsinogram with a single ray\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_xds-Tuple{SinoPar}","page":"Function References","title":"MIRT.sino_geom_xds","text":"sino_geom_xds()\n\ncenter positions of detectors (for beta = 0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.sino_geom_yds-Tuple{SinoPar}","page":"Function References","title":"MIRT.sino_geom_yds","text":"sino_geom_yds()\n\ncenter positions of detectors (for beta = 0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.smiley_parameters-Tuple{Any, Any}","page":"Function References","title":"MIRT.smiley_parameters","text":"params = smiley_parameters(xfov, yfov)\n\nsmiley face out of rects\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.snr2sigma-Tuple{Any, AbstractArray{<:Complex}}","page":"Function References","title":"MIRT.snr2sigma","text":"snr2sigma(db, yb)\n\nconvert SNR in dB to noise σ for complex gaussian noise\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.south_park_parameters-Tuple{}","page":"Function References","title":"MIRT.south_park_parameters","text":"param = southparkparameters( ; fov::Number = 100)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.trapezoid-NTuple{5, Real}","page":"Function References","title":"MIRT.trapezoid","text":"trapezoid(t::Real, t1, t2, t3, t4)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ImageGeom","page":"Function References","title":"MIRT.ImageGeom","text":"ImageGeom{D,S}\n\nImage geometry struct with essential grid parameters.\n\ndims::Dims{D} image dimensions\ndeltas::S where S <: NTuple{D} pixel sizes, where each Δ is usually Real or Unitful.Length\noffsets::NTuple{D,Float32} unitless\nmask::AbstractArray{Bool,D} logical mask, often FillArrays.Trues(dims).\n\n\n\n\n\n","category":"type"},{"location":"reference/#MIRT.ImageGeom-Union{Tuple{S}, Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, S, Tuple{Vararg{Real, D}}, AbstractArray{Bool, D}}} where {D, S<:Tuple{Vararg{Number, D}}}","page":"Function References","title":"MIRT.ImageGeom","text":"ig = ImageGeom(dims, deltas, offsets, [, mask])\n\nConvenient constructor for ImageGeom. The deltas elements should each be Real or a Unitful.Length. Default mask is FillArrays.Trues(dims) which is akin to trues(dims).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ImageGeom-Union{Tuple{}, Tuple{D}} where D","page":"Function References","title":"MIRT.ImageGeom","text":"ig = ImageGeom( ; nx=128, dims=(nx,nx), deltas=(1,1), offsets=(0,0), mask=Trues(dims))\n\nConvenience constructor for 2D case.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.MIRT_cbct_ig","page":"Function References","title":"MIRT.MIRT_cbct_ig","text":"MIRT_cbct_ig\n\nStructure suitable for passing to C routines cbct_* based on the struct cbct_ig found in cbct,def.h\n\n\n\n\n\n","category":"type"},{"location":"reference/#MIRT.SinoFanArc","page":"Function References","title":"MIRT.SinoFanArc","text":"SinoFanArc 2D Fan-beam sinogram geometry for arc detector\n\n\n\n\n\n","category":"type"},{"location":"reference/#MIRT.SinoFanFlat","page":"Function References","title":"MIRT.SinoFanFlat","text":"SinoFanFlat 2D Fan-beam sinogram geometry for flat detector\n\n\n\n\n\n","category":"type"},{"location":"reference/#MIRT.SinoMoj","page":"Function References","title":"MIRT.SinoMoj","text":"SinoMoj 2D Mojette sinogram geometry\n\n\n\n\n\n","category":"type"},{"location":"reference/#MIRT.SinoPar","page":"Function References","title":"MIRT.SinoPar","text":"SinoPar 2D parallel-beam sinogram geometry\n\n\n\n\n\n","category":"type"},{"location":"#MIRT:-The-Michigan-Image-Reconstruction-Toolbox","page":"Home","title":"MIRT: The Michigan Image Reconstruction Toolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIRT.jl is a collection of Julia functions for performing image reconstruction and solving related inverse problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is very much still under construction, although there are already enough tools to solve useful problems like compressed sensing MRI reconstruction. Trying the demos is a good way to get started.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is even more still under construction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further examples will likely be shared at JuliaImageRecon; see Examples there.","category":"page"}]
}
