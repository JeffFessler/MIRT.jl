var documenterSearchIndex = {"docs":
[{"location":"toc/","page":"Table of Contents","title":"Table of Contents","text":"","category":"page"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"EditURL = \"https://github.com/JeffFessler/MIRT.jl/blob/main/docs/lit/examples/1-mirt.jl\"","category":"page"},{"location":"examples/1-mirt/#mirt","page":"MIRT overview","title":"MIRT overview","text":"","category":"section"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"This is a placeholder","category":"page"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"","category":"page"},{"location":"examples/1-mirt/","page":"MIRT overview","title":"MIRT overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#function_reference","page":"Function References","title":"Function References","text":"","category":"section"},{"location":"reference/","page":"Function References","title":"Function References","text":"Modules = [MIRT]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/#MIRT.Afft-Union{Tuple{AbstractArray{Bool, D}}, Tuple{S}, Tuple{D}} where {D, S<:Number}","page":"Function References","title":"MIRT.Afft","text":"A = Afft(samp::AbstractArray{Bool} ; T::DataType = ComplexF32)\n\nMake a LinearMapAO object for (under-sampled) FFT, of type T, using given sampling pattern samp. Especially for compressed sensing MRI with Cartesian sampling.\n\nOption:\n\noperator::Bool = true set to false to return a LinearMapAM\nwork::AbstractArray work space for in-place fft operations\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.Anufft-Tuple{AbstractArray{<:Real}, Int64}","page":"Function References","title":"MIRT.Anufft","text":"Anufft(ω, N ; kwargs ...)\n\nMake a LinearMapAO object of size length(ω) × prod(N). See nufft_init for options.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.Aodwt","text":"A, levels, mfun = Aodwt(dims ; level::Int=3, wt=wavelet(WT.haar))\n\nCreate orthogonal discrete wavelet transform (ODWT) LinearMapAA\n\nin\n\ndims::Dims tuple of dimensions\n\noption\n\nlevel::Int # of levels; default 3\nwt wavelet transform type (see Wavelets package); default Haar\noperator::Bool=true default to LinearMapAO\nT::DataType : Float32 by default; use ComplexF32 if needed\n\nout\n\nA a LinearMapAX object\nscales array of size dims showing the scale of each coefficient\n\nwhich is useful when imposing scale-dependent regularization\n\nmfun convenience function for A*X when X is a Matrix or Array (not vector)\n\n2019-02-23 Jeff Fessler, University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.caller_name-Tuple{}","page":"Function References","title":"MIRT.caller_name","text":"caller_name() or caller_name(;level=4)\n\nReturn \"filename line fun():\" as a string to describe where this function was called.\n\nStack levels:\n\n1: #caller_name\n2: caller_name()\n3: function that invoked caller()\n4: the calling function we want to return\n\nHence the default level is 4, but we increment it by one in case user says @show caller_name() in which case stack[3] is a macro expansion.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{<:Number}, Tuple{Vararg{Int64, D}}}} where D","page":"Function References","title":"MIRT.diff_adj","text":"Z = diff_adj(dx, N::Dims{D} ; dims = 1:D)\n\nAdjoint of finite differences of arrays along one or more dimensions. By default performs the same operations as vec(Z) = (I_N_d otimes cdots otimes D_N_1) dots (D_N_d otimes cdots otimes I_N_1) * d where D_N denotes the N-1 × N 1D finite difference matrix and ⊗ denotes the Kronecker product, but does it efficiently without using spdiagm (or any SparseArrays function).\n\nin\n\ndx vector of typical length N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1\nN::Dims desired output size\n\noption\n\ndims dimension(s) for performing adjoint finite differences; default 1:ndims(X)\n\nout\n\nZ N_1 × ... × N_d array by default\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diff_forw-Union{Tuple{AbstractArray{<:Number, D}}, Tuple{D}} where D","page":"Function References","title":"MIRT.diff_forw","text":"d = diff_forw(X ; dims = 1:ndims(X))\n\nFinite differences along one or more dimensions of an array, e.g., for anisotropic TV regularization.\n\nBy default performs the same operations as d = (I_N_d otimes cdots otimes D_N_1) dots (D_N_d otimes cdots otimes I_N_1) vec(X) where D_N denotes the N-1 × N 1D finite difference matrix and ⊗ denotes the Kronecker product, but does it efficiently without using spdiagm (or any SparseArrays function).\n\nInput dimension N must exceed 1 for each dimension specified by dims.\n\nin\n\nX N_1 × ... × N_d array (typically an N-D image).\n\noption\n\ndims dimension(s) for performing finite differences; default 1:ndims(X)\n\nmust have unique elements and be a nonempty subset of 1:ndims(X)\n\nout\n\nd vector of default length N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D","page":"Function References","title":"MIRT.diff_map","text":"T = diff_map(N::Dims{D} ; dims = 1:D)\n\nin\n\nN::Dims image size\n\nout\n\nT LinearMapAA object for computing finite differences via T*x\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}","page":"Function References","title":"MIRT.diffl!","text":"diffl!(g::AbstractArray, x::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nWhen x is a N-dimensional array, the ith slice of the g array (along its last dimension) is the diffl! of x along dims[i]. This is useful for total variation (TV) and other regularizers that need finite differences along multiple dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}","page":"Function References","title":"MIRT.diffl!","text":"diffl!(g::AbstractArray, x::AbstractArray, dim::Int ; ...)\n\nApply left finite difference operator to input array x, storing the result \"in-place\" in pre-allocated output array g. (The letter g is mnemonic for \"gradient\".)\n\nArrays g and x must have the same size, and cannot alias. By default, the \"first\" elements of g are zero for dimension dim. The default is dim=1.\n\nOption:\n\nadd::Bool = false use x[i] + x[i-1] instead of x[i] - x[i-1] (useful for certain diagonal majorizers).\nedge::Symbol = :zero set the first elements of dimension dim to 0\nChoose edge=:circ to use circulant (aka periodic) boundary conditions.\nChoose edge=:none to leave the first elements untouched.\n\nExample\n\njulia> x = [2, 6, 7]; g = similar(x); diffl!(g, x)\n3-element Vector{Int64}:\n 0\n 4\n 1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}","page":"Function References","title":"MIRT.diffl","text":"g = diffl(x::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nAllocating version of diffl! for dims\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl-Tuple{AbstractArray, Int64}","page":"Function References","title":"MIRT.diffl","text":"g = diffl(x::AbstractArray, dim::Int ; ...)\n\nAllocating version of diffl! along dim\n\nExample\n\njulia> x = [1,2] .+ [10 30 70]; g = diffl(x, 2)\n2×3 Matrix{Int64}:\n 0  20  40\n 0  20  40\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl-Tuple{AbstractArray}","page":"Function References","title":"MIRT.diffl","text":"g = diffl(x::AbstractArray ; ...)\n\nAllocating version of diffl! along dim=1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}","page":"Function References","title":"MIRT.diffl_adj!","text":"diffl_adj!(z::AbstractArray, g::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nAdjoint of diffl! for multiple dimensions dims. Here g must have one more dimension than z.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}","page":"Function References","title":"MIRT.diffl_adj!","text":"diffl_adj!(z, g, dim::Int ; ...)\n\nAdjoint of left finite difference diffl!, in-place. Arrays z and g must be same size. See diffl_adj for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj-Tuple{AbstractArray, Int64}","page":"Function References","title":"MIRT.diffl_adj","text":"z = diffl_adj(g::AbstractArray, dim::Int ; ...)\n\nAllocating version of diffl_adj! along dim.\n\nExample\n\njulia> g = ones(Int,2,3); z = diffl_adj(g, 2)\n2×3 Matrix{Int64}:\n -1  0  1\n -1  0  1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj-Tuple{AbstractArray}","page":"Function References","title":"MIRT.diffl_adj","text":"z = diffl_adj(g::AbstractArray ; ...)\n\nAllocating version of diffl_adj! along dim=1.\n\nExample\n\njulia> g = [0, 2, 5]; z = diffl_adj(g)\n3-element Vector{Int64}:\n -2\n -3\n  5\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}","page":"Function References","title":"MIRT.diffl_adj","text":"z = diffl_adj(g::AbstractArray, dims::AbstractVector{Int} ; ...)\n\nAllocating version of diffl_adj! for dims.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D","page":"Function References","title":"MIRT.diffl_map","text":"T = diffl_map(N::Dims{D}, dims::AbstractVector{Int} ; kwargs...)\nT = diffl_map(N::Dims{D}, dim::Int ; kwargs...)\n\nin\n\nN::Dims image size\n\noptions: see diffl!\n\nT::Type for LinearMapAA, default Float32\noperator::Bool = true use false for LinearMapAM\n\nout\n\nT LinearMapAA object for computing finite differences via T*x\n\nusing diffl! and diffl_adj!\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample1-Tuple{AbstractVector{<:Number}, Int64}","page":"Function References","title":"MIRT.downsample1","text":"y = downsample1(x, down ; warn=true)\n\ndownsample 1D vector by factor down\n\nin\n\nx [n1]\ndown::Int downsampling factor\n\noption\n\nwarn::Bool warn if noninteger multiple; default isinteractive()\n\nout\n\ny [n1/down]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample2-Tuple{AbstractMatrix{<:Number}, Tuple{Int64, Int64}}","page":"Function References","title":"MIRT.downsample2","text":"y = downsample2(x, down ; warn=true, T)\n\ndownsample by averaging by integer factors in\n\nx [nx ny]\ndown can be a scalar (same factor for both dimensions) or a NTuple{2,Int}\n\noption\n\nwarn::Bool warn if noninteger multiple; default isinteractive()\nT::DataType specify output eltype; default eltype(x[1] / down[1])\n\nout\n\ny [nx/down ny/down]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample3-Tuple{AbstractArray{<:Number, 3}, Tuple{Int64, Int64, Int64}}","page":"Function References","title":"MIRT.downsample3","text":"y = downsample3(x, down ; warn=true, T)\n\ndownsample by averaging by integer factors in\n\nx [nx ny nz]\ndown can be a scalar (same factor for all dimensions) or a NTuple{3,Int}\n\noption\n\nwarn::Bool warn if noninteger multiple; default true\nT::DataType specify output eltype; default eltype(x[1] / down[1])\n\nout\n\ny [nx/down ny/down nz/down]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.downsample_dim1-Tuple{AbstractArray{<:Number}, Int64}","page":"Function References","title":"MIRT.downsample_dim1","text":"y = downsample_dim1(x, down ; warn::Bool)\n\nDown-sample x by factor down along first dimension by averaging.\n\nin\n\nx [n1 (Nd)]\ndown::Int downsampling factor\n\noption\n\nwarn::Bool warn if non-integer multiple; default isinteractive()\n\nout\n\ny [n1÷down (Nd)]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Number}}","page":"Function References","title":"MIRT.dtft","text":"X = dtft(w, x ; n_shift=?)\n\nmulti-dimensional DTFT (DSFT)\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M where here n is a CartesianIndex\n\nin\n\nw::AbstractMatrix{<:Real}\t[M,D] frequency locations (\"units\" radians/sample)\nx::AbstractArray{<:Number}\t[(Nd)] D-dimensional signal\n\noption\n\nn_shift::AbstractVector{<:Real} often is N/2; default zeros(D)\n\nout\n\nX::AbstractVector{ComplexF64} [M] DTFT\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft-Tuple{AbstractVector{<:Real}, AbstractVector{<:Number}}","page":"Function References","title":"MIRT.dtft","text":"X = dtft(w, x ; n_shift=?)\n\n1D DTFT\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M\n\nin\n\nw::AbstractVector{<:Real}\t[M] frequency locations (\"units\" radians/sample)\nx::AbstractVector{<:Number}\t[N] 1D signal\n\noption\n\nn_shift::Real often is N/2; default 0\n\nout\n\nX::AbstractVector{ComplexF64} [M] DTFT\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_adj-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Number}, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.dtft_adj","text":"x = dtft_adj(w, X, N ; n_shift=?)\n\nadjoint for multi-dimensional DTFT (DSFT)\n\nxn = sum_m=1^M Xm exp(i wm (n - n_shift)) n=0N-1 where here n is a CartesianIndex\n\nin\n\nX::AbstractVector{ComplexF64} [M] DTFT\nw::AbstractMatrix{<:Real} [M,D] frequency locations (\"units\" radians/sample)\nN::Dims\t[D] dimensions of signal x\n\noption\n\nn_shift::AbstractVector{<:Real} often is N/2; default zeros(D)\nT::DataType default (eltype(w) == Float64) ? ComplexF64 : ComplexF32\n\nout\n\nx::AbstractArray{<:Number} [(N)] D-dimensional signal\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_adj-Tuple{AbstractVector{<:Real}, AbstractVector{<:Number}, Int64}","page":"Function References","title":"MIRT.dtft_adj","text":"x = dtft_adj(w, X, N ; n_shift=?)\n\nadjoint for 1D DTFT\n\nxn = sum_m=1^M Xm exp(i wm (n - n_shift)) n=0N-1\n\nThis is the adjoint (transpose) of dtft, not an inverse DTFT.\n\nin\n\nw::AbstractVector{<:Real}\t[M] frequency locations (\"units\" radians/sample)\nX::AbstractVector{ComplexF64}\t[M] spectrum values\nN::Int size of signal x\n\noption\n\nn_shift::Real often is N/2; default 0\nT::DataType output data type; default ComplexF64\n\nout\n\nx::AbstractVector{<:Number}\tsignal [N]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_init-Tuple{AbstractMatrix{<:Real}, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.dtft_init","text":"d = dtft_init(w, N ; n_shift=?)\n\nfor multi-dimensional DTFT (DSFT)\n\nin\n\nw::AbstractMatrix{<:Real}\t[M,D] frequency locations (\"units\" radians/sample)\nN::Dims [D] dimensions of signal x\n\noption\n\nn_shift::AbstractVector{<:Real} often is N/2; default zeros(D)\nT::DataType default ComplexF64 for testing NUFFT accuracy\n\nout\n\nd::NamedTuple with fields\n\n`dtft = x -> dtft(x), adjoint = y -> dtft_adj(y), A=LinearMapAO`\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.dtft_init-Tuple{AbstractVector{<:Real}, Int64}","page":"Function References","title":"MIRT.dtft_init","text":"d = dtft_init(w, N ; n_shift=?)\n\nfor 1D DTFT\n\nin\n\nw::AbstractVector{<:Real}\t[M] frequency locations (\"units\" radians/sample)\nN::Int size of signal x\n\noption\n\nn_shift::Real often is N/2; default 0\nT::DataType default ComplexF64 for testing NUFFT accuracy\n\nout\n\nd::NamedTuple with fields\n\n`dtft = x -> dtft(x), adjoint = y -> dtft_adj(y), A=LinearMapAO`\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{<:Number}, AbstractArray{Bool, D}}} where {T, D}","page":"Function References","title":"MIRT.embed!","text":"embed!(array, v, mask ; filler=0)\n\nembed vector v of length sum(mask) into elements of array where mask is true, setting the remaining elements to filler (default 0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.embed-Tuple{AbstractMatrix{<:Number}, AbstractArray{Bool}}","page":"Function References","title":"MIRT.embed","text":"array = embed(matrix::AbstractMatrix{<:Number}, mask::AbstractArray{Bool})\n\nEmbed each column of matrix into mask then cat along next dimension In:\n\nmatrix [sum(mask) L]\nmask [(N)]\n\nOut:\n\narray [(N) L]\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T<:Number","page":"Function References","title":"MIRT.embed","text":"array = embed(v, mask ; filler=0)\n\nembed vector v of length sum(mask) into elements of an array where mask is true; see embed!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.eql_root-Tuple{Real, Real, Real}","page":"Function References","title":"MIRT.eql_root","text":"x = eql_root(a,b,c)\nNumerically stable method for computing the positive root\nof the quadratic polynomial `-ax^2 - 2bx + c, a >= 0`.\nAssumes solvable equations; will throw otherwise.\n\nin\n\na : The negative of the x^2 term. Must be positive.\nb : Half the negative of the x term.\nc : The constant term.\n\nout\n\nx : The positive root that satisfies 0 = -ax^2 - 2bx + c.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.exp_mult-Tuple{Any, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Function References","title":"MIRT.exp_mult","text":"D = exp_mult(A, u, v ; warnboth)\n\nMemory efficient and fast implementation of D = A' * exp(-u * v^T) that is useful for B0-field-corrected MRI image reconstruction.\n\nin:\n\nA [N L] matrix\nu [N] vector\nv [M] vector\nwarnboth warn if both u and v are complex; default: true\n\nout:\n\nD [L M] complex vector: D = A' * exp(-u * v^T)\n\nD_lm = sum_n A_nl^* exp(-u_n v_m)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.exp_xform-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Function References","title":"MIRT.exp_xform","text":"exp_xform(x, u, v ; mode::Symbol = :matrix)\n\nin:\n\nx [N L] possibly complex vector(s)\nu [D N] possibly complex vectors\nv [D M] possibly complex vectors\nmode::Symbol :matrix (default) | :element | :row | :column\n\nout:\n\ny [M L] typically complex vector\n\ny[m,l] = sum_n x[n,l] exp(-sum(u[:,n] .* v[:,m]))\n\nIterates through subsets of the ML matrix designated by :mode (i.e. row, column, element, or just computing the entire matrix) This is the 'slow' 'exact' transform model for MRI.\n\nOutput type will depend on input types.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.genkspace-NTuple{8, Any}","page":"Function References","title":"MIRT.genkspace","text":"genkspace\n\nGenerate the proper length of k-space trajectory.\n\nIt linearly interpolates the output of genspiral to the correct length() & takes care of the rotations for the interleaves.\n\nld is the length of the data\nnint is the number of interleaves\n\nBrad Sutton; University of Michigan\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.genspi-Tuple{Any, Any}","page":"Function References","title":"MIRT.genspi","text":"Gx, Gy, kx, ky, sx, sy, gts = genspi(...)\n\nThis is translation of C code from scanner: exactly what is played out to gradients at 4us.\n\nmulti-shot spiral design uses Duyn's approximate slewrate limited design augmented with archimedian gmax limit in [args]\n\nD = FOV; cm\nN = matrix size()\nTmax = longest acquisition allowed; s\ndts = output sample spacing; s\ngtype = trajectory type()\n\noption [CVs]\n\nnl = number of interleaves\ngamp = design grad max; G/cm\ngslew = design slew rate; mT/m/ms\nnramp = number of rampdown points; default 0\n\nout\n\nGx; Gy\n\ntime is in sec()\n\nrev 0 12/26/98\toriginal\nrev 1 4/15/99\tlittle better calc of ts\n\nBorrowed from Doug Noll; Univ. of Michigan. Modified to take more input cv's.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}","page":"Function References","title":"MIRT.getindex!","text":"getindex!(y::AbstractVector, x::AbstractArray{T,D}, mask::AbstractArray{Bool,D})\n\nEquivalent to the in-place y .= x[mask] but is non-allocating.\n\nFor non-Boolean indexing, just use @views y .= A[index], per https://discourse.julialang.org/t/efficient-non-allocating-in-place-getindex-for-bitarray/42268\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.interp1-Tuple{AbstractVector{<:Real}, AbstractVector{<:Number}, Any}","page":"Function References","title":"MIRT.interp1","text":"yi = interp1(x, y, xi ; how=Gridded(Linear()), extrap=0)\n\n1D interpolation of y = f(x) at points xi\n\nIn:\n\nx::AbstractVector{<:Real}\ny::AbstractVector{<:Number}\n\nOption:\n\nhow::Interpolations.InterpolationType default Gridded(Linear())\nextrap::Any how to extrapolate, e.g., Flat(); default 0\n\nother options from Interpolations.jl are Line() Periodic() Reflect() Throw()\n\nOutput is same size as input xi\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_dump-Tuple{Any}","page":"Function References","title":"MIRT.ir_dump","text":"ir_dump(x::Any ; io::IO = stdout)\nir_dump(io::IO, x::Any)\n\nShow all the fields of a structure or NamedTuple more nicely than dump() does\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_load_brainweb_t1_256-Tuple{}","page":"Function References","title":"MIRT.ir_load_brainweb_t1_256","text":"data = ir_load_brainweb_t1_256()\n\nLoad brainweb T1-weighted MRI slice of size 256 × 256.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_coil_compress-Tuple{AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ir_mri_coil_compress","text":"(odata, σ, Vr) = ir_mri_coil_compress(idata ; ncoil)\n\nMRI coil compression via PCA. Given multiple MRI surface coil images (idata), use SVD/PCA to find a smaller number of virtual coil images (odata).\n\nIn:\n\nidata [(N) n_in]: noisy complex images (2D or 3D) for each coil\n\nOption:\n\nncoil Desired # of virtual coils (default: 1)\n\nOut:\n\nodata [(N) ncoil]: virtual coil images\nσ     [n_in]: singular values.\nVr    [n_in, ncoil]: compression matrix for reducing other data.\n\ntodo: currently ignores noise correlations\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_kspace_ga_radial-Tuple{}","page":"Function References","title":"MIRT.ir_mri_kspace_ga_radial","text":"kspace = ir_mri_kspace_ga_radial(; Nro=?, Nspoke=?, ...)\n\nGenerate k-space sampling pattern for \"golden angle\" radial sampling.\n\noption\n\nNro:Int\t\tnumber of samples in each readout/spoke, default 256\nNspoke::Int\tnumber of spokes, default 1\nstart::Real\tfirst angle in series [radians], default π/2\nangle::Real\tangular spacing [radians], default GA\ndelta_ro::Real\treadout spacing, default 1/Nro\nshift::Real\t\tshift due to gradient delays, default 0\nradial sample locations are ir * delta_ro\nwhere ir = [-(Nro/2 - 1):1:Nro/2] + shift\n\nout\n\nkspace\t[Nro Nspoke 2] (Float32)\n\nkx and ky k-space locations for Nspoke*Nro samples in interval (-0.5 0.5] for default shift, delta_ro so default units are \"cycles / sample\"\n\n2015-07 Mai Le, original Matlab version\n\n2015-07-04 Jeff Fessler, minor changes to Matlab version\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim-Tuple{Symbol}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim","text":"(smap,info) = ir_mri_sensemap_sim( :all ; kwargs)\n\nLike ir_mri_sensemap_sim but also returns info with data for all coils, mainly for testing and plotting.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim","text":"(smap,info) = ir_mri_sensemap_sim( ir_ic_pair ; kwargs)\n\nLike ir_mri_sensemap_sim but also returns info with data for specific coils where ir_ic_pair::Vector{Tuple{Int,Int}}. (Usually used internally only.)\n\ninfo::NamedTuple geometry information for plots\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim-Tuple{}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim","text":"smap = ir_mri_sensemap_sim(...)\n\nSimulate 2D or 3D sensitivity maps for sensitivity-encoded MRI based on grivich:00:tmf http://doi.org/10.1119/1.19461\n\nThis code makes maps for multiple coils, but does not model coupling between coils, so most likely it is an approximation at best.\n\noption\n\ndims::Dims\t\timage size; default (64, 64)\ndx::Real\t\tpixel/voxel dimension; default: 3\ndy::Real\t\tpixel/voxel dimension; default: dx\ndz::Real\t\t\"\"\nncoil::Int\t\t# of coils total; default 4\nnring::Int\t\t# of rings of coils; default 1\nrcoil::Real\t\tcoil radius; default dx * nx / 2 * 0.50\ndz_coil\t\t\tring spacing in z; default nz*dz/nring\n(3D geometry is a cylinder)\ncoil_distance::Real\t\tdistance of coil center from isocenter\nfor central ring of coils as a multiple of FOVx,\nwhere FOVx=nx*dx; default 1.2\norbit::Real\t\t\tdefault 360 [degrees]\norbit_start::AbstractVector{<:Real} = fill(0, nring) [degrees]\nscale::Symbol\n:none (default)\n+\tssos_center make SSoS of center = 1\n\nout\n\nsmap\t[dims ncoil]\tsimulated sensitivity maps (complex!)\n\nAll length parameters must have same units (e.g., mm or cm)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}","page":"Function References","title":"MIRT.ir_mri_sensemap_sim_do","text":"(smap, info) = ir_mri_sensemap_sim_do()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_smap1-NTuple{4, Any}","page":"Function References","title":"MIRT.ir_mri_smap1","text":"ir_mri_smap1()\n\nbased on grivich:00:tmf\n\nfor a circular coil in \"x-y plane\" of radius \"a\"\n\nNote that coil x-y plane is not same as object x-y plane!\n\nReturns (i,j,k) components of B vector for each (x,y,z) location\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ir_mri_smap_r-Tuple{Any, Any}","page":"Function References","title":"MIRT.ir_mri_smap_r","text":"ir_mri_smap_r(r, z)\n\nfunction for testing near 0\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.jinc-Tuple{Real}","page":"Function References","title":"MIRT.jinc","text":"jinc(x)\n\nReturn jinc(x) = J1(pi*x)/(2x), where J1 is a Bessel function of the first kind.\n\nUnits of x are typically cycles/m.\n\nReturn type is promote_type(typeof(x), Float32).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}","page":"Function References","title":"MIRT.map_many","text":"y = map_many(fun::Function, x::AbstractArray{<:Any}, idim::Dims)\n\napply a function fun to leading slices of input x; cousin of mapslices\n\nin\n\nfun::Function maps input of size idim to output of some size odim\nx [idim ldim]\n\nout\n\ny [odim ldim]\n\nExample: if fun maps array of size (1,2) to array of size (3,4,5) and if input x has size (1,2,7,8) then output y will have size (3,4,5,7,8) where y[:,:,:,i,j] = fun(x[:,:,i,j])\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mask_or-Tuple{AbstractMatrix{Bool}}","page":"Function References","title":"MIRT.mask_or","text":"mask_or(mask)\n\ncompress 3D mask to 2D by logical or along z direction\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}","page":"Function References","title":"MIRT.mask_outline","text":"mask_outline(mask)\n\nreturn outer boundary of 2D mask (or mask_or for 3D)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.maskit-Tuple{AbstractArray{<:Number}, AbstractArray{Bool}}","page":"Function References","title":"MIRT.maskit","text":"maskit(x::AbstractArray{<:Number})\n\nopposite of embed\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.max_percent_diff-Tuple{Any, Any}","page":"Function References","title":"MIRT.max_percent_diff","text":"d = max_percent_diff(s1, s2, [options])\n\nCompute the \"maximum percent difference\" between two signals: s1, s2.\n\nDefault is to normalize by maximum(abs.(s1)).\n\noptions\n\nmaxboth::Bool use max of both arguments to normalize; default false\nnormalize::Bool normalize each before comparing; default false\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_kspace_spiral-Tuple{}","page":"Function References","title":"MIRT.mri_kspace_spiral","text":"kspace, omega, gradxy = mri_kspace_spiral( [options] )\n\nMake k-space spiral trajectory based on GE 3T scanner constraints\n\nOption:\n\nN dimention of reconstructed image\nNt # of time points\nfov field of view in cm\ndt time sampling interval out; default 5e-6 sec\ngamp::Real design gradient amplitude max, G/cm; default 2.2\ngslew::Int design slew rate, mT/m/ms; default 180\n\nOut:\n\nkspace [Nt,2] kspace trajectory [kx ky] in cycles/cm, NO: cycles/FOV\nomega [Nt,2] \"\" in radians\ngradxy [Nt 2] gradient waveforms in (units?)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D","page":"Function References","title":"MIRT.mri_trajectory","text":"kspace, omega, wi = mri_trajectory( ; ktype, N, fov, arg_wi, kwargs...)\n\nGenerate kspace trajectory samples and density compensation functions.\n\noption\n\nktype::Symbol k-space trajectory type; default :radial\nN::Dims target image size; default (32,30)\nfov field of view in x and y (and z); default (250,250) mm\narg_wi options to pass to ir_mri_density_comp - not yet done\nkwargs options for the specific trajectory\n\nout\n\nkspace [Nk 2|3] kspace samples in units 1/fov\nomega [Nk 2|3] trajectory samples over [-π,π)\nwi [Nk 1] (optional) density compensation factors\n\ntrajectory types: :cartesian :radial :cart_y_2 :random :half8 :epi_sin :spiral0 :spiral1 :spiral3 :rosette3 :epi_under :gads (emulate golden-angle data sharing per winkelmann:07:aor)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring","page":"Function References","title":"MIRT.mri_trajectory_gads","text":"omega, wi = mri_trajectory_gads(N, fov ; ...)\n\nemulate 2D golden angle radial sampling with data sharing\n\noption: Nro # of samples in each readout/spoke shift shift along read-out due to gradient delays (stress) kmax_frac fractions of maximum krad (0.5) for rings (annuli) under under-sampling factor for each annulus\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}","page":"Function References","title":"MIRT.mri_trajectory_radial","text":"mri_trajectory_radial()\n\noption:\n\nna_nr default ensures proper sampling at edge of k-space\nna angular spokes; default: na_nr * nr\nnr radial samples per spoke\nir default: 0:nr\n\ntodo: generalize to 3D using barger:02:trc\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.mri_trajectory_rosette3-Tuple{Any, Any}","page":"Function References","title":"MIRT.mri_trajectory_rosette3","text":"mri_trajectory_rosette3(N, fov ; ...)\n\n3d rosette, with default parameters from bucholz:08:miw\n\noptions: omax: maximum omega nt : time samples (65.536 ms for 4 usec dt) dt : time sample spacing (4 usec) ti : time samples\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ncg-Tuple{AbstractVector, AbstractVector{<:Function}, AbstractVector{<:Function}, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ncg","text":"(x,out) = ncg(B, gradf, curvf, x0 ; ...)\n\nNonlinear preconditioned conjugate gradient algorithm to minimize a general \"inverse problem\" cost function of the form Psi(x) = sum_j=1^J f_j(B_j x) where each function f_j(v) has a quadratic majorizer of the form\n\nq_j(vu) = f_j(u) + nabla f_j(u) (v - u) + 12 v - u^2_C_j(u)\n\nwhere C_j(u) is diagonal matrix of curvatures. (It suffices for each f_j to have a Lipschitz smooth gradient.)\n\nThis CG method uses a majorize-minimize (MM) line search.\n\nin\n\nB\t\tarray of J blocks B_1B_J\ngradf\tarray of J functions return gradients of f_1f_J\ncurvf\tarray of J functions z -> curv(z) that return a scalar\n\nor a vector of curvature values for each element of z\n\nx0\tinitial guess; need length(x) == size(B[j],2) for j=1J\n\nUsually x0 is a Vector but it can be an Array if each B_j is a linear operator (e.g., LinearMapAO) of suitable \"dimensions\".\n\noption\n\nniter\t# number of outer iterations; default 50\nninner\t# number of inner iterations of MM line search; default 5\nP\t\t# preconditioner; default I\nbetahow\t\"beta\" method for the search direction; default :dai_yuan\nfun\t\tUser-defined function to be evaluated with two arguments (x,iter).\nIt is evaluated at (x0,0) and then after each iteration.\n\noutput\n\nx\t\tfinal iterate\nout\t\t[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))\n(all 0 by default). This is an array of length niter+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ncg-Tuple{Function, Function, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ncg","text":"(x,out) = ncg(grad, curv, x0, ...)\n\nspecial case of ncg (nonlinear CG) for minimizing a cost function whose gradient is grad(x) and that has a quadratic majorizer with diagonal Hessian given by curv(x). Typically curv = (x) -> L where L is the Lipschitz constant of grad\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Function References","title":"MIRT.ndgrid","text":"(xx,yy,zz) = ndgrid(x::AbstractVector{<:Any}, y::..., z::...) todo - improve?\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector}","page":"Function References","title":"MIRT.ndgrid","text":"(xx,yy) = ndgrid(x::AbstractVector{<:Any}, y::AbstractVector{<:Any}) todo - improve?\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_eltype-Tuple{Type{<:Integer}}","page":"Function References","title":"MIRT.nufft_eltype","text":"nufft_eltype(::DataType)\n\nensure plan_nfft eltype is Float32 or Float64\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_errors-Tuple{}","page":"Function References","title":"MIRT.nufft_errors","text":"w, errs = nufft_errors( ; M=?, w=?, N=?, n_shift=?, ...)\n\nCompute NUFFT approximation errors (for signal of length N of unit norm), for given digital frequency values w, i.e., Ω.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_init-Tuple{AbstractArray{<:Real}, Int64}","page":"Function References","title":"MIRT.nufft_init","text":"p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=0)\n\nSetup 1D NUFFT, for computing fast O(N log N) approximation to\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M\n\nin\n\nw::AbstractArray{<:Real} [M] frequency locations (aka Ω, units radians/sample)\neltype(w) determines the plan_nfft type; so to save memory use Float32!\nsize(w) determines odim for A if operator=true\nN::Int signal length\n\noption\n\nnfft_m::Int\t\tsee NFFT.jl documentation; default 4\nnfft_sigma::Real\t\"\", default 2.0\nn_shift::Real\t\toften is N/2; default 0\npi_error::Bool\t\tthrow error if w  π, default true\nSet to false only if you are very sure of what you are doing!\ndo_many::Bool\tsupport extended inputs via map_many? default true\noperator::Bool=true set to false to make A an LinearMapAM\n\nout\n\np NamedTuple\n\n(nufft = x -> nufft(x), adjoint = y -> nufft_adj(y), A::LinearMapAO)\n\nThe default settings are such that for a 1D signal of length N=512, the worst-case error is below 1e-5 which is probably adequate for typical medical imaging applications. To verify this statement, run nufft_plot1() and see plot.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{<:Real}, Tuple{Vararg{Int64, D}}}} where D","page":"Function References","title":"MIRT.nufft_init","text":"p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=?)\n\nSetup multi-dimensional NUFFT, for computing fast O(N log N) approximation to\n\nXm = sum_n=0^N-1 xn exp(-i wm (n - n_shift)) m=1M\n\nin\n\nw::AbstractArray{<:Real} [M,D] frequency locations (aka Ω, units radians/sample)\n\n+ `eltype(w)` determines the `plan_nfft` type; so to save memory use Float32!\n+ `size(w)[1:(end-1)]` determines `odim` if `operator=true`\n\nN::Dims{D} signal dimensions\n\noption\n\nnfft_m::Int\t\tsee NFFT.jl documentation; default 4\nnfft_sigma::Real\t\"\", default 2.0\nn_shift::AbstractVector{<:Real}\t[D]\toften is N/2; default zeros(D)\npi_error::Bool\t\tthrow error if w  π, default true\nSet to false only if you are very sure of what you are doing!\ndo_many::Bool\tsupport extended inputs via map_many? default true\noperator::Bool=true set to false to make A an LinearMapAM\n\nThe default do_many option is designed for parallel MRI where the k-space sampling pattern applies to every coil. It may also be useful for dynamic MRI with repeated sampling patterns. The coil and/or time dimensions must come after the spatial dimensions.\n\nout\n\np NamedTuple with fields\n\n`nufft = x -> nufft(x), adjoint = y -> nufft_adj(y), A=LinearMapAO`\n(Using `operator=true` allows the `LinearMapAO` to support `do_many`.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T","page":"Function References","title":"MIRT.nufft_typer","text":"nufft_typer(T::DataType, x::AbstractArray{<:Real} ; warn::Bool=true)\n\ntype conversion wrapper for nfft()\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{<:Function}, AbstractVector{<:Function}, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.ogm_ls","text":"(x,out) = ogm_ls(B, gradf, curvf, x0; niter=?, ninner=?, fun=?)\n\nOGM with a line search; Drori&Taylor @arxiv 1803.05676; to minimize a general \"inverse problem\" cost function of the form Psi(x) = sum_j=1^J f_j(B_j x) where each function f_j(v) has a quadratic majorizer of the form\n\nq_j(vu) = f_j(u) + nabla f_j(u) (v - u) + 12 v - u^2_C_j(u)\n\nwhere C_j(u) is diagonal matrix of curvatures. (It suffices for each f_j to have a Lipschitz smooth gradient.)\n\nThis OGM method uses a majorize-minimize (MM) line search.\n\nin\n\nB\t\tarray of J blocks B_1B_J\ngradf\tarray of J functions return gradients of f_1f_J\ncurvf\tarray of J functions z -> curv(z) that return a scalar\n\nor a vector of curvature values for each element of z\n\nx0\tinitial guess; need length(x) == size(B[j],2) for j=1J\n\noption\n\nniter\t# number of outer iterations; default 50\nninner\t# number of inner iterations of MM line search; default 5\nfun\t\tUser-defined function to be evaluated with two arguments (x,iter).\nIt is evaluated at (x0,0) and then after each iteration.\n\noutput\n\nx\t\tfinal iterate\nout\t\t[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))\n(all 0 by default). This is an array of length niter+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{<:Number}}","page":"Function References","title":"MIRT.ogm_ls","text":"(x,out) = ogm_ls(grad, curv, x0, ...)\n\nspecial case of ogm_ls (OGM with line search) for minimizing a cost function whose gradient is grad(x) and that has a quadratic majorizer with diagonal Hessian given by curv(x). Typically curv = (x) -> L where L is the Lipschitz constant of grad\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.pogm_restart-Tuple{Any, Function, Function, Real}","page":"Function References","title":"MIRT.pogm_restart","text":"x, out = pogm_restart(x0, Fcost, f_grad, f_L ;\nf_mu=0, mom=:pogm, restart=:gr, restart_cutoff=0.,\nbsig=1, niter=10, g_prox=(z,c)->z, fun=...)\n\nIterative proximal algorithms (PGM=ISTA, FPGM=FISTA, POGM) with restart.\n\nin\n\nx0 initial guess\nFcost function for computing the cost function value F(x)\n(needed only if restart === :fr)\nf_grad function for computing the gradient of f(x)\nf_L Lipschitz constant of the gradient of f(x)\n\noption\n\nf_mu strong convexity parameter of f(x); default 0.\nif f_mu > 0, (alpha beta_k gamma_k) is chosen by Table 1 in [KF18]\ng_prox function g_prox(z,c) for the proximal operator for g(x)\ng_prox(z,c) computes argmin_x 12 z-x^2 + c  g(x)\nmom\tmomentum option\n:pogm POGM (fastest); default!\n:fpgm (FISTA), gamma_k = 0\n:pgm PGM (ISTA), beta_k = gamma_k = 0\nrestart restart option\n:gr gradient restart; default!\n:fr function restart\n:none no restart\nrestart_cutoff for :gr restart if cos(angle) < this; default 0.\nbsig gradient \"gamma\" decrease option (value within [0 1]); default 1\nsee barsigma in [KF18]\nniter number of iterations; default 10\nfun function(iter, xk, yk, is_restart) user-defined function evaluated each iter with secondary xk, primary yk, and boolean is_restart indicating whether this iteration was a restart\n\nout\n\nx\tfinal iterate\nfor PGM (ISTA): x_N = y_N\nfor FPGM (FISTA): primary iterate y_N\nfor POGM: secondary iterate x_N, see [KF18]\nout [fun(0, x0, x0, false), fun(1, x1, y1, is_restart), ...] array of length [niter+1]\n\nOptimization Problem: Nonsmooth Composite Convex Minimization\n\nargmin_x F(x)  F(x) = f(x) + g(x))\nf(x) smooth convex function\ng(x) convex function, possibly nonsmooth and \"proximal-friendly\" [CP11]\n\nOptimization Algorithms:\n\nAccelerated First-order Algorithms when g(x) = 0 [KF18] iterate as below for given coefficients (alpha beta_k gamma_k)\n\nFor k = 0,1,...\ny_k+1 = x_k - alpha  f(x_k) : gradient update\nx_k+1 = y_k+1 + beta_k  (y_k+1 - y_k) + gamma_k  (y_k+1 - x_k) : momentum update\n\nProximal versions of the above for g(x) neq 0 are in the below references, and use the proximal operater prox_g(z) = argmin_x 12z-x^2 + g(x).\n\nProximal Gradient method (PGM or ISTA) - beta_k = gamma_k = 0. [BT09]\nFast Proximal Gradient Method (FPGM or FISTA) - gamma_k = 0. [BT09]\nProximal Optimized Gradient Method (POGM) - [THG15]\nFPGM(FISTA) with Restart - [OC15]\nPOGM with Restart - [KF18]\n\nreferences\n\n[CP11] P. L. Combettes, J. C. Pesquet,\n\n\"Proximal splitting methods in signal processing,\"  Fixed-Point Algorithms for Inverse Problems in Science and Engineering,  Springer, Optimization and Its Applications, 2011.\n\n[KF18] D. Kim, J.A. Fessler,\n\n\"Adaptive restart of the optimized gradient method for convex optimization,\" 2018  Arxiv:1703.04641,  [http://doi.org/10.1007/s10957-018-1287-4]\n\n[BT09] A. Beck, M. Teboulle:\n\n\"A fast iterative shrinkage-thresholding algorithm for linear inverse problems,\"  SIAM J. Imaging Sci., 2009.\n\n[THG15] A.B. Taylor, J.M. Hendrickx, F. Glineur,\n\n\"Exact worst-case performance of first-order algorithms  for composite convex optimization,\" Arxiv:1512.07516, 2015,  SIAM J. Opt. 2017  [http://doi.org/10.1137/16m108104x]\n\nCopyright 2017-3-31, Donghwan Kim and Jeff Fessler, University of Michigan 2018-08-13 Julia 0.7.0 2019-02-24 interface redesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.poweriter-Tuple{Any}","page":"Function References","title":"MIRT.poweriter","text":"v1,σ1 = poweriter(A; niter=?, ...)\n\nDetermine first right singular vector v1 and first singular value σ1 of A by applying power iteration to A'A\n\nin\n\nA M × N matrix\n\noption\n\nniter default 200\nx0 initial guess of v1\ntol stopping tolerance for s1, default 1e-6\nchat::Bool verbose? default false\n\nout\n\nv1 [N] principal right singular vector\nσ1 spectral norm of A\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rect-Tuple{Real}","page":"Function References","title":"MIRT.rect","text":"rect(x::Real)\n\nUnit width rect function. Potential problem? Bring up with fess.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.reverser-Tuple{AbstractArray, AbstractVector{<:Int64}}","page":"Function References","title":"MIRT.reverser","text":"y = reverser(x, dims)\n\nreverse array along specified dimensions (or all if unspecified)\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rmsd100-Tuple{AbstractArray{<:Number}, AbstractArray{<:Number}}","page":"Function References","title":"MIRT.rmsd100","text":"rmsd = rmsd100(x, y ; mask)\n\nCompute 100 * RMSD (root mean squared difference) between x and y within domain mask.\n\nin\n\nx : array\ny : another array of same size\n\noption:\n\nmask::Array{Bool} : domain over which to compute the RMSE; default trues(size(x))\n\nout\n\nrmsd : rmsd of x vs y within mask in %\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.rotate2d-Tuple{Any, Any, Any}","page":"Function References","title":"MIRT.rotate2d","text":"(xr,yr) = rotate2d(x, y, theta) 2D rotation\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIRT.snr2sigma-Tuple{Any, AbstractArray{<:Complex}}","page":"Function References","title":"MIRT.snr2sigma","text":"snr2sigma(db, yb)\n\nConvert SNR in dB to noise σ for complex gaussian noise. No sqrt(2) factors is needed here because randn(Complex{Float}) already accounts for that. (See randn documentation.)\n\n\n\n\n\n","category":"method"},{"location":"#MIRT:-The-Michigan-Image-Reconstruction-Toolbox","page":"Home","title":"MIRT: The Michigan Image Reconstruction Toolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIRT.jl is a collection of Julia functions for performing image reconstruction and solving related inverse problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is very much still under construction, although there are already enough tools to solve useful problems like compressed sensing MRI reconstruction. Trying the demos is a good way to get started.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is even more still under construction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further examples will likely be shared at JuliaImageRecon; see Examples there.","category":"page"}]
}
