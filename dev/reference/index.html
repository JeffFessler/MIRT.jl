<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · MIRT.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MIRT.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MIRT.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../toc/">Table of Contents</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/1-mirt/">MIRT overview</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JeffFessler/MIRT.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="function_reference"><a class="docs-heading-anchor" href="#function_reference">Function References</a><a id="function_reference-1"></a><a class="docs-heading-anchor-permalink" href="#function_reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, ImageGeom}" href="#Base.show-Tuple{IO, ImageGeom}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io::IO, ig::ImageGeom)
show(io::IO, ::MIME&quot;text/plain&quot;, ig::ImageGeom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L468-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, SinoGeom}" href="#Base.show-Tuple{IO, SinoGeom}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io::IO, sg::SinoGeom)
show(io::IO, ::MIME&quot;text/plain&quot;, sg::SinoGeom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L449-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.Afft-Union{Tuple{AbstractArray{Bool, D}}, Tuple{S}, Tuple{D}} where {D, S&lt;:Number}" href="#MIRT.Afft-Union{Tuple{AbstractArray{Bool, D}}, Tuple{S}, Tuple{D}} where {D, S&lt;:Number}"><code>MIRT.Afft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A = Afft(samp::AbstractArray{Bool} ; T::DataType = ComplexF32)</code></pre><p>Make a LinearMapAO object for (under-sampled) FFT, of type <code>T</code>, using given sampling pattern <code>samp</code>. Especially for compressed sensing MRI with Cartesian sampling.</p><p>Option:</p><ul><li><code>operator::Bool = true</code> set to <code>false</code> to return a <code>LinearMapAM</code></li><li><code>work::AbstractArray</code> work space for in-place fft operations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/system/Afft.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}" href="#MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.Anufft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Anufft(ω, N ; kwargs ...)</code></pre><p>Make a <code>LinearMapAO</code> object of size <code>length(ω) × prod(N)</code>. See <code>nufft_init</code> for options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/nufft.jl#L218-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}" href="#MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}"><code>MIRT.Aodwt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A, levels, mfun = Aodwt(dims ; level::Int=3, wt=wavelet(WT.haar))</code></pre><p>Create orthogonal discrete wavelet transform (ODWT) <code>LinearMapAA</code></p><p>in</p><ul><li><code>dims::Dims</code> tuple of dimensions</li></ul><p>option</p><ul><li><code>level::Int</code> # of levels; default 3</li><li><code>wt</code> wavelet transform type (see <code>Wavelets</code> package); default Haar</li><li><code>operator::Bool=true</code> default to <code>LinearMapAO</code></li><li><code>T::DataType</code> : <code>Float32</code> by default; use <code>ComplexF32</code> if needed</li></ul><p>out</p><ul><li><code>A</code> a <code>LinearMapAX</code> object</li><li><code>scales</code> array of size <code>dims</code> showing the scale of each coefficient</li></ul><p>which is useful when imposing scale-dependent regularization</p><ul><li><code>mfun</code> convenience function for A*X when X is a Matrix or Array (not vector)</li></ul><p>2019-02-23 Jeff Fessler, University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/Aodwt.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT._down_round-Union{Tuple{D}, Tuple{Tuple{Vararg{Real, D}}, Tuple{Vararg{Number, D}}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT._down_round-Union{Tuple{D}, Tuple{Tuple{Vararg{Real, D}}, Tuple{Vararg{Number, D}}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT._down_round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(n,d) = _down_round()</code></pre><p>helper function needed to downsample <code>image_geom</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L305-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.caller_name-Tuple{}" href="#MIRT.caller_name-Tuple{}"><code>MIRT.caller_name</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>caller_name() or caller_name(;level=4)</code></p><p>Return &quot;filename line fun():&quot; as a string to describe where this function was called.</p><p>Stack levels:</p><ul><li>1: #caller_name</li><li>2: caller_name()</li><li>3: function that invoked caller()</li><li>4: the calling function we want to return</li></ul><p>Hence the default level is 4, but we increment it by one in case user says <code>@show caller_name()</code> in which case stack[3] is a macro expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/io/caller_name.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cbct-Union{Tuple{ImageGeom{3, S}}, Tuple{S}} where S&lt;:Tuple{Real, Real, Real}" href="#MIRT.cbct-Union{Tuple{ImageGeom{3, S}}, Tuple{S}} where S&lt;:Tuple{Real, Real, Real}"><code>MIRT.cbct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cbct(ig::ImageGeom{3,&lt;:Real}; nthread::Int=1)</code></pre><p>Constructor for <code>MIRT_cbct_ig</code> (does not support units currently)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L175-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cuboid_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Real}}" href="#MIRT.cuboid_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Real}}"><code>MIRT.cuboid_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = cuboid_im(ig, params ;
oversample=1, hu_scale=1, how=:auto, return_params=false)</code></pre><p>generate cuboid phantom image from parameters: 	<code>[x_center y_center z_center x_diameter y_diameter z_diameter 		xy_angle_degrees z_angle_degrees amplitude]</code></p><p>in</p><ul><li><code>ig::ImageGeom</code></li><li><code>params</code> <code>[N 9]</code> cuboid parameters (&quot;diameter&quot; not &quot;radius&quot;)</li></ul><p>options</p><ul><li><code>oversample::Int</code> oversampling factor (for partial volume)</li><li><code>how::Symbol</code><ul><li><code>:sample</code> use samples</li><li><code>:lowmem1</code> one slice per time</li><li><code>:exact</code> perfect partial volume if <code>*angle* = 0</code></li><li>default: <code>:exact</code> if non rotated, else <code>:sample</code></li></ul></li><li><code>return_params::Bool</code>	if true, return both <code>phantom</code> and <code>params</code></li></ul><p>out</p><ul><li><code>phantom</code> <code>[nx ny nz]</code> image</li><li><code>params</code> <code>[N 9]</code> cuboid parameters (only return if <code>return_params=true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/cuboid_im.jl#L11-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cuboid_im-Tuple{ImageGeom, Symbol}" href="#MIRT.cuboid_im-Tuple{ImageGeom, Symbol}"><code>MIRT.cuboid_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = cuboid_im(ig, code, args...)</code></pre><p><code>code = :default | :rotate</code> # add more options</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/cuboid_im.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cuboid_im-Tuple{ImageGeom}" href="#MIRT.cuboid_im-Tuple{ImageGeom}"><code>MIRT.cuboid_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = cuboid_im(ig ; args...)</code></pre><p><code>:default</code> default parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/cuboid_im.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cuboid_im_exact-NTuple{10, Any}" href="#MIRT.cuboid_im_exact-NTuple{10, Any}"><code>MIRT.cuboid_im_exact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cuboid_im_exact()</code></pre><p>:exact</p><p>non-rotated cuboid – rotation not done</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/cuboid_im.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cuboid_im_lowmem1-NTuple{10, Any}" href="#MIRT.cuboid_im_lowmem1-NTuple{10, Any}"><code>MIRT.cuboid_im_lowmem1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cuboid_im_lowmem1(...)</code></pre><p>This version does <code>:sample</code> 1 slice at a time to reduce memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/cuboid_im.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.cuboid_im_sample-NTuple{10, Any}" href="#MIRT.cuboid_im_sample-NTuple{10, Any}"><code>MIRT.cuboid_im_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cuboid_im_sample()</code></pre><p>:sample</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/cuboid_im.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.diff_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Z = diff_adj(dx, N::Dims{D} ; dims = 1:D)</code></pre><p>Adjoint of finite differences of arrays along one or more dimensions. By default performs the same operations as <span>$vec(Z) = [(I_{N_d} \otimes \cdots \otimes D_{N_1}); \dots; (D_{N_d} \otimes \cdots \otimes I_{N_1})]&#39; * d$</span> where <code>D_N</code> denotes the <code>N-1 × N</code> 1D finite difference matrix and <code>⊗</code> denotes the Kronecker product, but does it efficiently without using <code>spdiagm</code> (or any <code>SparseArrays</code> function).</p><p>in</p><ul><li><code>dx</code> vector of typical length <code>N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1</code></li><li><code>N::Dims</code> desired output size</li></ul><p>option</p><ul><li><code>dims</code> dimension(s) for performing adjoint finite differences; default <code>1:ndims(X)</code></li></ul><p>out</p><ul><li><code>Z</code> <code>N_1 × ... × N_d</code> array by default</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffs.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D" href="#MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D"><code>MIRT.diff_forw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = diff_forw(X ; dims = 1:ndims(X))</code></pre><p>Finite differences along one or more dimensions of an array, e.g., for anisotropic TV regularization.</p><p>By default performs the same operations as <span>$d = [(I_{N_d} \otimes \cdots \otimes D_{N_1}); \dots; (D_{N_d} \otimes \cdots \otimes I_{N_1})] vec(X)$</span> where <span>$D_N$</span> denotes the <code>N-1 × N</code> 1D finite difference matrix and <code>⊗</code> denotes the Kronecker product, but does it efficiently without using <code>spdiagm</code> (or any <code>SparseArrays</code> function).</p><p>Input dimension <code>N</code> must exceed <code>1</code> for each dimension specified by <code>dims</code>.</p><p>in</p><ul><li><code>X</code> <code>N_1 × ... × N_d</code> array (typically an N-D image).</li></ul><p>option</p><ul><li><code>dims</code> dimension(s) for performing finite differences; default <code>1:ndims(X)</code></li></ul><p>must have unique elements and be a nonempty subset of <code>1:ndims(X)</code></p><p>out</p><ul><li><code>d</code> vector of default length <code>N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffs.jl#L35-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D" href="#MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D"><code>MIRT.diff_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = diff_map(N::Dims{D} ; dims = 1:D)</code></pre><p>in</p><ul><li><code>N::Dims</code> image size</li></ul><p>out</p><ul><li><code>T</code> <code>LinearMapAA</code> object for computing finite differences via <code>T*x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffs.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}" href="#MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}"><code>MIRT.diffl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl!(g::AbstractArray, x::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>When <code>x</code> is a <code>N</code>-dimensional array, the <code>i</code>th slice of the <code>g</code> array (along its last dimension) is the <code>diffl!</code> of <code>x</code> along <code>dims[i]</code>. This is useful for total variation (TV) and other regularizers that need finite differences along multiple dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}" href="#MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}"><code>MIRT.diffl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl!(g::AbstractArray, x::AbstractArray, dim::Int ; ...)</code></pre><p>Apply left finite difference operator to input array <code>x</code>, storing the result &quot;in-place&quot; in pre-allocated output array <code>g</code>. (The letter <code>g</code> is mnemonic for &quot;gradient&quot;.)</p><p>Arrays <code>g</code> and <code>x</code> must have the same size, and cannot alias. By default, the &quot;first&quot; elements of <code>g</code> are zero for dimension <code>dim</code>. The default is <code>dim=1</code>.</p><p>Option:</p><ul><li><code>add::Bool = false</code> use <code>x[i] + x[i-1]</code> instead of <code>x[i] - x[i-1]</code> (useful for certain diagonal majorizers).</li><li><code>edge::Symbol = :zero</code> set the first elements of dimension <code>dim</code> to 0<ul><li>Choose <code>edge=:circ</code> to use circulant (aka periodic) boundary conditions.</li><li>Choose <code>edge=:none</code> to leave the first elements untouched.</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [2, 6, 7]; g = similar(x); diffl!(g, x)
3-element Vector{Int64}:
 0
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}" href="#MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Allocating version of <code>diffl!</code> for <code>dims</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray, Int64}" href="#MIRT.diffl-Tuple{AbstractArray, Int64}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray, dim::Int ; ...)</code></pre><p>Allocating version of <code>diffl!</code> along <code>dim</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1,2] .+ [10 30 70]; g = diffl(x, 2)
2×3 Matrix{Int64}:
 0  20  40
 0  20  40</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray}" href="#MIRT.diffl-Tuple{AbstractArray}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray ; ...)</code></pre><p>Allocating version of <code>diffl!</code> along <code>dim=1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}" href="#MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}"><code>MIRT.diffl_adj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl_adj!(z::AbstractArray, g::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Adjoint of <code>diffl!</code> for multiple dimensions <code>dims</code>. Here <code>g</code> must have one more dimension than <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}" href="#MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}"><code>MIRT.diffl_adj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl_adj!(z, g, dim::Int ; ...)</code></pre><p>Adjoint of left finite difference <code>diffl!</code>, in-place. Arrays <code>z</code> and <code>g</code> must be same size. See <code>diffl_adj</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj-Tuple{AbstractArray, Int64}" href="#MIRT.diffl_adj-Tuple{AbstractArray, Int64}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray, dim::Int ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> along <code>dim</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = ones(Int,2,3); z = diffl_adj(g, 2)
2×3 Matrix{Int64}:
 -1  0  1
 -1  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj-Tuple{AbstractArray}" href="#MIRT.diffl_adj-Tuple{AbstractArray}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> along <code>dim=1</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = [0, 2, 5]; z = diffl_adj(g)
3-element Vector{Int64}:
 -2
 -3
  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L227-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}" href="#MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> for <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L261-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D" href="#MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D"><code>MIRT.diffl_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = diffl_map(N::Dims{D}, dims::AbstractVector{Int} ; kwargs...)
T = diffl_map(N::Dims{D}, dim::Int ; kwargs...)</code></pre><p>in</p><ul><li><code>N::Dims</code> image size</li></ul><p>options: see <code>diffl!</code></p><ul><li><code>T::Type</code> for <code>LinearMapAA</code>, default <code>Float32</code></li><li><code>operator::Bool = true</code> use <code>false</code> for <code>LinearMapAM</code></li></ul><p>out</p><ul><li><code>T</code> <code>LinearMapAA</code> object for computing finite differences via <code>T*x</code></li></ul><p>using <code>diffl!</code> and <code>diffl_adj!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/regularize/diffl.jl#L277-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.disk_phantom_params-Tuple{}" href="#MIRT.disk_phantom_params-Tuple{}"><code>MIRT.disk_phantom_params</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>params = disk_phantom_params( ; ...)</code></p><p>Generate ellipse phantom parameters for a head-sized disk plus many disks within it, designed so that the disks have some minimum separation <code>minsep</code> to avoid overlap and to simplify patch-based model fitting.</p><p><strong>Arguments</strong></p><ul><li><code>fov::Real = 240</code> image field of view in mm</li><li><code>rhead::Real = 100</code> background radius for &quot;head&quot; [mm]</li><li><code>muhead::Real = 1000</code> &quot;mu&quot; (intensity) value for background head disk</li><li><code>rmin::Real = 10</code> min radius for random disks</li><li><code>rmax::Real = 20</code> max radius for random disks</li><li><code>mumin::Real = 100</code> range of &quot;mu&quot; values for disks</li><li><code>mumax::Real = 300</code></li><li><code>ndisk::Int = 10</code> # of random disks</li><li><code>minsep::Real = 8</code> minimum disk separation in mm</li><li><code>maxtry::Int = 500</code> give up on adding more disks if this is reached</li><li><code>warn::Bool = false</code> warn if maxtry reached?</li><li><code>seed::Int = 0</code> if nonzero then use this seed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/disk-phantom.jl#L12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:MIRT.SinoParallel" href="#MIRT.downsample-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:MIRT.SinoParallel"><code>MIRT.downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sg = downsample(sg, down)</code></pre><p>down-sample (for testing with small problems)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L209-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}" href="#MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}"><code>MIRT.downsample1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample1(x, down ; warn=true)</code></pre><p>downsample 1D vector by factor <code>down</code></p><p>in</p><ul><li><code>x [n1]</code></li><li><code>down::Int</code> downsampling factor</li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default <code>isinteractive()</code></li></ul><p>out</p><ul><li><code>y [n1/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/downsample.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}" href="#MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}"><code>MIRT.downsample2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample2(x, down ; warn=true, T)</code></pre><p>downsample by averaging by integer factors in</p><ul><li><code>x [nx ny]</code></li><li><code>down</code> can be a scalar (same factor for both dimensions) or a <code>NTuple{2,Int}</code></li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default <code>isinteractive()</code></li><li><code>T::DataType</code> specify output eltype; default <code>eltype(x[1] / down[1])</code></li></ul><p>out</p><ul><li><code>y [nx/down ny/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/downsample.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}" href="#MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}"><code>MIRT.downsample3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample3(x, down ; warn=true, T)</code></pre><p>downsample by averaging by integer factors in</p><ul><li><code>x [nx ny nz]</code></li><li><code>down</code> can be a scalar (same factor for all dimensions) or a <code>NTuple{3,Int}</code></li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default true</li><li><code>T::DataType</code> specify output eltype; default <code>eltype(x[1] / down[1])</code></li></ul><p>out</p><ul><li><code>y [nx/down ny/down nz/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/downsample.jl#L141-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}" href="#MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}"><code>MIRT.downsample_dim1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample_dim1(x, down ; warn::Bool)</code></pre><p>Down-sample <code>x</code> by factor <code>down</code> along first dimension by averaging.</p><p>in</p><ul><li><code>x [n1 (Nd)]</code></li><li><code>down::Int</code> downsampling factor</li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if non-integer multiple; default <code>isinteractive()</code></li></ul><p>out</p><ul><li><code>y [n1÷down (Nd)]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/downsample.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}" href="#MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}"><code>MIRT.dtft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X = dtft(w, x ; n_shift=?)</code></pre><p>multi-dimensional DTFT (DSFT)</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m,:] (n - n_{shift})), m=1,…,M$</span> where here <code>n</code> is a <code>CartesianIndex</code></p><p>in</p><ul><li><code>w::AbstractMatrix{&lt;:Real}</code>	<code>[M,D]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>x::AbstractArray{&lt;:Number}</code>	<code>[(Nd)]</code> D-dimensional signal</li></ul><p>option</p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is N/2; default zeros(D)</li></ul><p>out</p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/dtft.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}" href="#MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}"><code>MIRT.dtft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X = dtft(w, x ; n_shift=?)</code></pre><p>1D DTFT</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m] (n - n_{shift})), m=1,…,M$</span></p><p>in</p><ul><li><code>w::AbstractVector{&lt;:Real}</code>	<code>[M]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>x::AbstractVector{&lt;:Number}</code>	<code>[N]</code> 1D signal</li></ul><p>option</p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li></ul><p>out</p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/dtft.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = dtft_adj(w, X, N ; n_shift=?)</code></pre><p>adjoint for multi-dimensional DTFT (DSFT)</p><p><span>$x[n] = \sum_{m=1}^M X[m] \exp(i w[m,:] (n - n_{shift})), n=0,…,N-1$</span> where here <code>n</code> is a <code>CartesianIndex</code></p><p>in</p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li><li><code>w::AbstractMatrix{&lt;:Real}</code> <code>[M,D]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Dims</code>	<code>[D]</code> dimensions of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is <code>N/2</code>; default <code>zeros(D)</code></li><li><code>T::DataType</code> default <code>(eltype(w) == Float64) ? ComplexF64 : ComplexF32</code></li></ul><p>out</p><ul><li><code>x::AbstractArray{&lt;:Number}</code> <code>[(N)]</code> <code>D</code>-dimensional signal</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/dtft.jl#L172-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}" href="#MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}"><code>MIRT.dtft_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = dtft_adj(w, X, N ; n_shift=?)</code></pre><p>adjoint for 1D DTFT</p><p><span>$x[n] = \sum_{m=1}^M X[m] \exp(i w[m] (n - n_{shift})), n=0,…,N-1$</span></p><p>This is the <em>adjoint</em> (transpose) of <code>dtft</code>, not an <em>inverse</em> DTFT.</p><p>in</p><ul><li><code>w::AbstractVector{&lt;:Real}</code>	<code>[M]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>X::AbstractVector{ComplexF64}</code>	<code>[M]</code> spectrum values</li><li><code>N::Int</code> size of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>T::DataType</code> output data type; default <code>ComplexF64</code></li></ul><p>out</p><ul><li><code>x::AbstractVector{&lt;:Number}</code>	signal [N]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/dtft.jl#L137-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = dtft_init(w, N ; n_shift=?)</code></pre><p>for multi-dimensional DTFT (DSFT)</p><p>in</p><ul><li><code>w::AbstractMatrix{&lt;:Real}</code>	<code>[M,D]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Dims</code> <code>[D]</code> dimensions of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is N/2; default zeros(D)</li><li><code>T::DataType</code> default <code>ComplexF64</code> for testing NUFFT accuracy</li></ul><p>out</p><ul><li><code>d::NamedTuple</code> with fields</li></ul><pre><code class="nohighlight hljs">`dtft = x -&gt; dtft(x), adjoint = y -&gt; dtft_adj(y), A=LinearMapAO`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/dtft.jl#L101-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}" href="#MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}"><code>MIRT.dtft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = dtft_init(w, N ; n_shift=?)</code></pre><p>for 1D DTFT</p><p>in</p><ul><li><code>w::AbstractVector{&lt;:Real}</code>	<code>[M]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Int</code> size of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>T::DataType</code> default <code>ComplexF64</code> for testing NUFFT accuracy</li></ul><p>out</p><ul><li><code>d::NamedTuple</code> with fields</li></ul><pre><code class="nohighlight hljs">`dtft = x -&gt; dtft(x), adjoint = y -&gt; dtft_adj(y), A=LinearMapAO`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/dtft.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Number}}" href="#MIRT.ellipse_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Number}}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(ig, params ;
rot=0, oversample=1, hu_scale=1, replace=false)</code></pre><p>Generate ellipse phantom image from parameters:</p><p><code>[x_center y_center x_radius y_radius angle_degrees amplitude]</code></p><p>in</p><ul><li><code>ig</code>		from <code>image_geom()</code></li><li><code>params</code>	<code>[ne 6]</code> ellipse parameters</li></ul><p><strong>Arguments</strong></p><ul><li><code>rot</code>			rotate ellipses by this amount [degrees]</li><li><code>oversample</code>	oversampling factor, for grayscale boundaries</li><li><code>hu_scale</code>	use 1000 to scale shepp-logan to HU</li><li><code>replace</code>		replace ellipse values if true, else add</li><li><code>how</code>			<code>:fast</code> is the only option</li></ul><p>out</p><ul><li><code>phantom</code>		[nx ny]	image (Float32)</li></ul><p>note: <code>op ellipse</code> in aspire with <code>nsub=3</code> is <code>oversample=4 = 2^(3-1)</code> here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L11-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{ImageGeom, Symbol}" href="#MIRT.ellipse_im-Tuple{ImageGeom, Symbol}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(ig, code ; kwarg...)</code></pre><p><code>code = :shepplogan | :shepplogan_emis | :shepplogan_brainweb | :southpark</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{ImageGeom}" href="#MIRT.ellipse_im-Tuple{ImageGeom}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(ig ; kwarg...)</code></pre><p><code>:shepplogan</code> (default) for given image geometry <code>ig</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{Int64, Any}" href="#MIRT.ellipse_im-Tuple{Int64, Any}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(nx::Int, params ; kwarg...)</code></pre><p>square image of size <code>nx</code> by <code>nx</code> with pixel size <code>dx=1</code> and ellipse <code>params</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{Int64, Int64}" href="#MIRT.ellipse_im-Tuple{Int64, Int64}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(nx::Int, ny::Int ; kwarg...)</code></pre><p><code>:shepplogan_emis</code> of size <code>nx</code> by <code>ny</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{Int64, Number, Any}" href="#MIRT.ellipse_im-Tuple{Int64, Number, Any}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(nx, dx, params ; kwarg...)</code></pre><p>square image of size <code>nx × nx</code>, specifying pixel size <code>dx</code> and ellipse <code>params</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im-Tuple{Int64}" href="#MIRT.ellipse_im-Tuple{Int64}"><code>MIRT.ellipse_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipse_im(nx::Int ; ny::Int=nx, dx::Number=1, kwarg...)</code></pre><p>image of size <code>nx</code> by <code>ny</code> (default <code>nx</code>) with specified <code>dx</code> (default 1), defaults to <code>:shepplogan_emis</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im_fast!-NTuple{12, Any}" href="#MIRT.ellipse_im_fast!-NTuple{12, Any}"><code>MIRT.ellipse_im_fast!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>phantom = ellipse<em>im</em>fast!()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L135-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_im_params-Tuple{ImageGeom, Symbol}" href="#MIRT.ellipse_im_params-Tuple{ImageGeom, Symbol}"><code>MIRT.ellipse_im_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">params = ellipse_im_params(ig::ImageGeom, params::Symbol)</code></pre><p><code>code = :shepplogan | :shepplogan_emis | :shepplogan_brainweb | :southpark | :disks</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_sino-Tuple{AbstractArray{&lt;:Real}, AbstractArray{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#MIRT.ellipse_sino-Tuple{AbstractArray{&lt;:Real}, AbstractArray{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>MIRT.ellipse_sino</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sino = ellipse_sino(rg::AbstractArray{&lt;:Real}, ϕg::AbstractArray{&lt;:Real}, 		ells ; oversample=1, xscale=1, yscale=1)</code></p><p>Create sinogram projection of one or more ellipses, for arbitrary radial/angular sampling grid locations <code>(rg, ϕg)</code></p><p>in</p><ul><li><code>rg::AbstractArray{&lt;:Real}</code>	radial sampling locations</li><li><code>ϕg::AbstractArray{&lt;:Real}</code>	angular sampling locations (radians)</li><li><code>ells::Matrix</code> <code>[ne 6]</code> ellipse parameters<ul><li><code>[centx centy radx rady angle_degrees amplitude]</code></li></ul></li></ul><p>options</p><ul><li><code>xscale::Int</code> use -1 to flip in x (not recommended); default 1</li><li><code>yscale::Int</code> use -1 to flip in y (not recommended); default 1</li></ul><p>out</p><ul><li><code>sino::AbstractArray{Float32}</code> same size as <code>rg</code> and <code>ϕg</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_sino.jl#L51-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipse_sino-Tuple{SinoGeom, AbstractMatrix{&lt;:Real}}" href="#MIRT.ellipse_sino-Tuple{SinoGeom, AbstractMatrix{&lt;:Real}}"><code>MIRT.ellipse_sino</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sino = ellipse_sino(sg, ells ; oversample=1, xscale=1, yscale=1)</code></p><p>Create sinogram projection of one or more ellipses. Works for any sinogram geometry.</p><p>in</p><ul><li><code>sg::SinoGeom</code> sinogram geometry object from <code>sino_geom()</code></li><li><code>ells::Matrix</code> <code>[ne 6]</code> ellipse parameters<ul><li><code>[centx centy radx rady angle_degrees amplitude]</code></li></ul></li></ul><p>options</p><ul><li><code>oversample::Int</code>	oversampling factor for emulating &quot;strips&quot;<ul><li>default 1: just 1 ray per detector element</li></ul></li><li><code>xscale::Int</code>		use -1 to flip in x (not recommended); default 1</li><li><code>yscale::Int</code>		use -1 to flip in y (not recommended); default 1</li></ul><p>out</p><ul><li><code>sino</code> <code>[nb na]</code> sinogram</li></ul><p>To get the sample locations, use <code>(pos,ang) = sg.grid</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_sino.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipsoid_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Number}}" href="#MIRT.ellipsoid_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Number}}"><code>MIRT.ellipsoid_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipsoid_im(ig, params;
oversample=1, checkfov=false, how=:slow, showmem=false, hu_scale=1, return_params=false)</code></pre><p>generate ellipsoid phantom image from parameters: <code>[x_center, y_center, z_center, x_radius, y_radius, z_radius, 	xy_angle_degrees, z_angle_degrees, density]</code></p><p>in</p><ul><li><code>ig::ImageGeom</code>	from <code>image_geom()</code></li><li><code>params</code>			<code>[N 9]</code> ellipsoid parameters.</li></ul><p>option</p><ul><li><code>oversample::Int</code>		oversampling factor (default:1)</li><li><code>checkfov::Bool</code>		warn if any ellipsoid is out of fov</li><li><code>how::Symbol</code><ul><li><code>:fast</code> does it fast – to do, only works slow</li><li><code>:lowmem</code> uses less memory than <code>:fast</code> but slower</li><li><code>:slow</code> default</li></ul></li><li><code>showmem::Bool</code></li><li><code>hu_scale::Number</code> use 1000 to scale shepp-logan to HU; default 1</li><li><code>return_params::Bool</code>		if true, return both phantom and params</li></ul><p>out</p><ul><li><code>phantom</code>		<code>[nx ny nz]</code> image</li><li><code>params</code>		<code>[N 9]</code> ellipsoid parameters (only if <code>return_params=true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipsoid_im.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipsoid_im-Tuple{ImageGeom, Symbol}" href="#MIRT.ellipsoid_im-Tuple{ImageGeom, Symbol}"><code>MIRT.ellipsoid_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipsoid_im(ig, ptype ; args...)</code></pre><p><code>ptype = :zhu | :kak | :e3d | :spheroid</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipsoid_im.jl#L338-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipsoid_im-Tuple{ImageGeom}" href="#MIRT.ellipsoid_im-Tuple{ImageGeom}"><code>MIRT.ellipsoid_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = ellipsoid_im(ig ; args...)</code></pre><p><code>:zhu</code> (default) for given image geometry <code>ig</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipsoid_im.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ellipsoid_im_slow!-NTuple{13, Any}" href="#MIRT.ellipsoid_im_slow!-NTuple{13, Any}"><code>MIRT.ellipsoid_im_slow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ellipsoid_im_slow!()</code></pre><p>brute force fine grid - can use lots of memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipsoid_im.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}" href="#MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(array, v, mask ; filler=0)</code></pre><p>embed vector <code>v</code> of length <code>sum(mask)</code> into elements of <code>array</code> where <code>mask</code> is <code>true</code>, setting the remaining elements to <code>filler</code> (default 0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}" href="#MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array = embed(matrix::AbstractMatrix{&lt;:Number}, mask::AbstractArray{Bool})</code></pre><p>Embed each column of <code>matrix</code> into <code>mask</code> then <code>cat</code> along next dimension In:</p><ul><li><code>matrix [sum(mask) L]</code></li><li><code>mask [(N)]</code></li></ul><p>Out:</p><ul><li><code>array [(N) L]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L85-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number" href="#MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number"><code>MIRT.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array = embed(v, mask ; filler=0)</code></pre><p>embed vector <code>v</code> of length <code>sum(mask)</code> into elements of an array where <code>mask</code> is <code>true</code>; see <code>embed!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.eql_root-Tuple{Real, Real, Real}" href="#MIRT.eql_root-Tuple{Real, Real, Real}"><code>MIRT.eql_root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = eql_root(a,b,c)
Numerically stable method for computing the positive root
of the quadratic polynomial `-ax^2 - 2bx + c, a &gt;= 0`.
Assumes solvable equations; will throw otherwise.</code></pre><p>in</p><ul><li><code>a</code> : The negative of the <code>x^2</code> term. Must be positive.</li><li><code>b</code> : Half the negative of the <code>x</code> term.</li><li><code>c</code> : The constant term.</li></ul><p>out</p><ul><li><code>x</code> : The positive root that satisfies <code>0 = -ax^2 - 2bx + c</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/eql_root.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>MIRT.exp_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">D = exp_mult(A, u, v ; warnboth)</code></pre><p>Memory efficient and fast implementation of <code>D = A&#39; * exp(-u * v^T)</code> that is useful for B0-field-corrected MRI image reconstruction.</p><p>in:</p><ul><li><code>A [N L]</code> matrix</li><li><code>u [N]</code> vector</li><li><code>v [M]</code> vector</li><li><code>warnboth</code> warn if both <code>u</code> and <code>v</code> are complex; default: true</li></ul><p>out:</p><ul><li><code>D [L M]</code> complex vector: <code>D = A&#39; * exp(-u * v^T)</code></li></ul><p><code>D_lm = sum_n A_nl^* exp(-u_n v_m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/exp_mult.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}" href="#MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>MIRT.exp_xform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp_xform(x, u, v ; mode::Symbol = :matrix)</code></pre><p>in:</p><ul><li><code>x [N L]</code> possibly complex vector(s)</li><li><code>u [D N]</code> possibly complex vectors</li><li><code>v [D M]</code> possibly complex vectors</li><li><code>mode::Symbol</code> <code>:matrix</code> (default) | <code>:element</code> | <code>:row</code> | <code>:column</code></li></ul><p>out:</p><ul><li><code>y [M L]</code> typically complex vector</li></ul><p><code>y[m,l] = sum_n x[n,l] exp(-sum(u[:,n] .* v[:,m]))</code></p><p>Iterates through subsets of the ML matrix designated by <code>:mode</code> (i.e. row, column, element, or just computing the entire matrix) This is the &#39;slow&#39; &#39;exact&#39; transform model for MRI.</p><p>Output type will depend on input types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/exp_xform.jl#L14-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.genkspace-NTuple{8, Any}" href="#MIRT.genkspace-NTuple{8, Any}"><code>MIRT.genkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genkspace</code></pre><p>Generate the proper length of k-space trajectory.</p><p>It linearly interpolates the output of <code>genspiral</code> to the correct <code>length()</code> &amp; takes care of the rotations for the interleaves.</p><ul><li><code>ld</code> is the length of the data</li><li><code>nint</code> is the number of interleaves</li></ul><p>Brad Sutton; University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/kspace-spiral.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.genspi-Tuple{Any, Any}" href="#MIRT.genspi-Tuple{Any, Any}"><code>MIRT.genspi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gx, Gy, kx, ky, sx, sy, gts = genspi(...)</code></pre><p>This is translation of C code from scanner: exactly what is played out to gradients at 4us.</p><p>multi-shot spiral design uses Duyn&#39;s approximate slewrate limited design augmented with archimedian <code>gmax</code> limit in [args]</p><ul><li><p><code>D</code> = FOV; cm</p></li><li><p><code>N</code> = matrix size()</p></li><li><p><code>Tmax</code> = longest acquisition allowed; s</p></li><li><p><code>dts</code> = output sample spacing; s</p></li><li><p><code>gtype</code> = trajectory type()</p></li></ul><p>option [CVs]</p><ul><li><code>nl</code> = number of interleaves</li><li><code>gamp</code> = design grad max; G/cm</li><li><code>gslew</code> = design slew rate; mT/m/ms</li><li><code>nramp</code> = number of rampdown points; default 0</li></ul><p>out</p><ul><li><code>Gx; Gy</code></li></ul><p>time is in sec()</p><ul><li>rev 0 12/26/98	original</li><li>rev 1 4/15/99	little better calc of ts</li></ul><p>Borrowed from Doug Noll; Univ. of Michigan. Modified to take more input cv&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/kspace-spiral.jl#L155-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}" href="#MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.getindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex!(y::AbstractVector, x::AbstractArray{T,D}, mask::AbstractArray{Bool,D})</code></pre><p>Equivalent to the in-place <code>y .= x[mask]</code> but is non-allocating.</p><p>For non-Boolean indexing, just use <code>@views y .= A[index]</code>, per https://discourse.julialang.org/t/efficient-non-allocating-in-place-getindex-for-bitarray/42268</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ig_downsample-Union{Tuple{S}, Tuple{D}, Tuple{ImageGeom{D, S}, Tuple{Vararg{Int64, D}}}} where {D, S}" href="#MIRT.ig_downsample-Union{Tuple{S}, Tuple{D}, Tuple{ImageGeom{D, S}, Tuple{Vararg{Int64, D}}}} where {D, S}"><code>MIRT.ig_downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ig_down = ig_downsample(ig, down::Tuple{Int})</code></pre><p>down sample an image geometry by the factor <code>down</code> cf <code>image_geom_downsample</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom-Tuple{}" href="#MIRT.image_geom-Tuple{}"><code>MIRT.image_geom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ig = image_geom(...)</code></pre><p>Constructor for <code>ImageGeom</code>, where <code>dx,dy,dz</code> and <code>fov</code> and <code>fovz</code> may have units</p><p><strong>Arguments</strong></p><ul><li><code>nx::Int = 128</code></li><li><code>ny::Int = nx</code></li><li><code>dx::RealU = ?</code> (must specify one of <code>dx</code> or <code>fov</code>)</li><li><code>dy::RealU = -dx</code></li><li><code>offset_x::Real = 0</code> (unitless)</li><li><code>offset_y::Real = 0</code> (unitless)</li><li><code>fov::RealU = ?</code> (if specified, then <code>nx*dx=ny*dy</code>)</li><li><code>nz::Int = 0</code></li><li><code>dz::RealU = ?</code> (need one of <code>dz</code> or <code>zfov</code> if <code>nz &gt; 0</code>)</li><li><code>zfov::RealU = ?</code> (if specified, then <code>nz*dz</code>)</li><li><code>offset_z::Real = 0</code> (unitless)</li><li><code>offsets::Symbol = :none</code> or :dsp</li><li><code>mask::Union{Symbol,AbstractArray{Bool}} = :all</code> | <code>:circ</code> | <code>:all_but_edge_xy</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L193-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom_add_unitv-Union{Tuple{AbstractArray{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Number, D}" href="#MIRT.image_geom_add_unitv-Union{Tuple{AbstractArray{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Number, D}"><code>MIRT.image_geom_add_unitv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>out = image<em>geom</em>add_unitv(z::AbstractArray ; j=?, i=?, c=?)</p><p>add a unit vector to an initial array <code>z</code> (typically of zeros)</p><p><strong>options (use at one of these):</strong></p><ul><li><code>j</code> single index from 1 to length(z)</li><li><code>i</code> (ix, iy [,iz]) index from 1 to nx,ny</li><li><code>c</code> (cx, cy [,cz]) index from +/- n/2 center at floor(n/2)+1</li></ul><p>default with no arguments gives unit vector at center <code>c=(0, 0 [,0])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L418-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom_expand_nz-Union{Tuple{S}, Tuple{ImageGeom{3, S}, Int64}} where S" href="#MIRT.image_geom_expand_nz-Union{Tuple{S}, Tuple{ImageGeom{3, S}, Int64}} where S"><code>MIRT.image_geom_expand_nz</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ig<em>new = image</em>geom<em>expand</em>nz(ig::ImageGeom{3}, nz_pad::Int) pad both ends</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L355-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom_help-Tuple{}" href="#MIRT.image_geom_help-Tuple{}"><code>MIRT.image_geom_help</code></a> — <span class="docstring-category">Method</span></header><section><div><p>image<em>geom</em>help( ; io)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom_mri-Tuple{}" href="#MIRT.image_geom_mri-Tuple{}"><code>MIRT.image_geom_mri</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ig = image_geom_mri(varargin)</code></pre><p>Same as <code>image_geom()</code> but default offsets are 0.5 so that image pixel indices go from -N/2 to N/2-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/image_geom_mri.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom_over-Union{Tuple{D}, Tuple{ImageGeom{D, S} where S&lt;:Tuple{Vararg{Number, D}}, Int64}} where D" href="#MIRT.image_geom_over-Union{Tuple{D}, Tuple{ImageGeom{D, S} where S&lt;:Tuple{Vararg{Number, D}}, Int64}} where D"><code>MIRT.image_geom_over</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ig<em>over = image</em>geom_over(ig::ImageGeom, over::Int) over-sample an image geometry by the factor <code>over</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L370-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.image_geom_plot-Tuple{ImageGeom{2, S} where S&lt;:Tuple{Number, Number}, Function}" href="#MIRT.image_geom_plot-Tuple{ImageGeom{2, S} where S&lt;:Tuple{Number, Number}, Function}"><code>MIRT.image_geom_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_geom_plot(ig, how ; kwargs...)</code></pre><p>The <code>how</code> argument should be <code>MIRTjim.jim</code> to be useful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L457-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}" href="#MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}"><code>MIRT.interp1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yi = interp1(x, y, xi ; how=Gridded(Linear()), extrap=0)</code></pre><p>1D interpolation of <code>y = f(x)</code> at points <code>xi</code></p><p>In:</p><ul><li><code>x::AbstractVector{&lt;:Real}</code></li><li><code>y::AbstractVector{&lt;:Number}</code></li></ul><p>Option:</p><ul><li><code>how::Interpolations.InterpolationType</code> default <code>Gridded(Linear())</code></li><li><code>extrap::Any</code> how to extrapolate, e.g., <code>Flat()</code>; default <code>0</code></li></ul><p>other options from Interpolations.jl are <code>Line()</code> <code>Periodic()</code> <code>Reflect()</code> <code>Throw()</code></p><p>Output is same size as input <code>xi</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/interp1.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_dump-Tuple{Any}" href="#MIRT.ir_dump-Tuple{Any}"><code>MIRT.ir_dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_dump(x::Any ; io::IO = stdout)
ir_dump(io::IO, x::Any)</code></pre><p>Show all the fields of a structure or <code>NamedTuple</code> more nicely than dump() does</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/io/ir_dump.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_load_brainweb_t1_256-Tuple{}" href="#MIRT.ir_load_brainweb_t1_256-Tuple{}"><code>MIRT.ir_load_brainweb_t1_256</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data = ir_load_brainweb_t1_256()</code></pre><p>Load brainweb T1-weighted MRI slice of size <code>256 × 256</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/data/loaders.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}" href="#MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}"><code>MIRT.ir_mri_coil_compress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(odata, σ, Vr) = ir_mri_coil_compress(idata ; ncoil)</code></pre><p>MRI coil compression via PCA. Given multiple MRI surface coil images (idata), use SVD/PCA to find a smaller number of virtual coil images (odata).</p><p>In:</p><ul><li><code>idata</code> <code>[(N) n_in]</code>: noisy complex images (2D or 3D) for each coil</li></ul><p>Option:</p><ul><li><code>ncoil</code> Desired # of virtual coils (default: 1)</li></ul><p>Out:</p><ul><li><code>odata</code> <code>[(N) ncoil]</code>: virtual coil images</li><li><code>σ</code>     <code>[n_in]</code>: singular values.</li><li><code>Vr</code>    <code>[n_in, ncoil]</code>: compression matrix for reducing other data.</li></ul><p>todo: currently ignores noise correlations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/coil_compress.jl#L15-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_kspace_ga_radial-Tuple{}" href="#MIRT.ir_mri_kspace_ga_radial-Tuple{}"><code>MIRT.ir_mri_kspace_ga_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace = ir_mri_kspace_ga_radial(; Nro=?, Nspoke=?, ...)</code></pre><p>Generate k-space sampling pattern for &quot;golden angle&quot; radial sampling.</p><p>option</p><ul><li><code>Nro:Int</code>		number of samples in each readout/spoke, default 256</li><li><code>Nspoke::Int</code>	number of spokes, default 1</li><li><code>start::Real</code>	first angle in series [radians], default π/2</li><li><code>angle::Real</code>	angular spacing [radians], default GA</li><li><code>delta_ro::Real</code>	readout spacing, default <code>1/Nro</code></li><li><code>shift::Real</code>		shift due to gradient delays, default 0<ul><li>radial sample locations are <code>ir * delta_ro</code></li><li>where <code>ir = [-(Nro/2 - 1):1:Nro/2] + shift</code></li></ul></li></ul><p>out</p><ul><li><code>kspace</code>	<code>[Nro Nspoke 2]</code> (Float32)</li></ul><p><code>kx</code> and <code>ky</code> k-space locations for <code>Nspoke*Nro</code> samples in interval <code>(-0.5 0.5]</code> for default <code>shift</code>, <code>delta_ro</code> so default units are &quot;cycles / sample&quot;</p><p>2015-07 Mai Le, original Matlab version</p><p>2015-07-04 Jeff Fessler, minor changes to Matlab version</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/kspace.jl#L10-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{Symbol}" href="#MIRT.ir_mri_sensemap_sim-Tuple{Symbol}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap,info) = ir_mri_sensemap_sim( :all ; kwargs)</code></pre><p>Like <code>ir_mri_sensemap_sim</code> but also returns <code>info</code> with data for all coils, mainly for testing and plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/sensemap-sim.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}" href="#MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap,info) = ir_mri_sensemap_sim( ir_ic_pair ; kwargs)</code></pre><p>Like <code>ir_mri_sensemap_sim</code> but also returns <code>info</code> with data for specific coils where <code>ir_ic_pair::Vector{Tuple{Int,Int}}</code>. (Usually used internally only.)</p><ul><li><code>info::NamedTuple</code> geometry information for plots</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/sensemap-sim.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{}" href="#MIRT.ir_mri_sensemap_sim-Tuple{}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smap = ir_mri_sensemap_sim(...)</code></pre><p>Simulate 2D or 3D sensitivity maps for sensitivity-encoded MRI based on grivich:00:tmf http://doi.org/10.1119/1.19461</p><p>This code makes maps for multiple coils, but does not model coupling between coils, so most likely it is an approximation at best.</p><p>option</p><ul><li><code>dims::Dims</code>		image size; default (64, 64)</li><li><code>dx::Real</code>		pixel/voxel dimension; default: 3</li><li><code>dy::Real</code>		pixel/voxel dimension; default: <code>dx</code></li><li><code>dz::Real</code>		&quot;&quot;</li><li><code>ncoil::Int</code>		# of coils total; default 4</li><li><code>nring::Int</code>		# of rings of coils; default 1</li><li><code>rcoil::Real</code>		coil radius; default <code>dx * nx / 2 * 0.50</code></li><li><code>dz_coil</code>			ring spacing in z; default <code>nz*dz/nring</code><ul><li>(3D geometry is a cylinder)</li></ul></li><li><code>coil_distance::Real</code>		distance of coil center from isocenter<ul><li>for central ring of coils as a multiple of <code>FOVx</code>,</li><li>where <code>FOVx=nx*dx</code>; default 1.2</li></ul></li><li><code>orbit::Real</code>			default 360 [degrees]</li><li><code>orbit_start::AbstractVector{&lt;:Real} = fill(0, nring)</code> [degrees]</li><li><code>scale::Symbol</code><ul><li><code>:none</code> (default)</li></ul>+	<code>ssos_center</code> make SSoS of center = 1</li></ul><p>out</p><ul><li><code>smap	[dims ncoil]</code>	simulated sensitivity maps (complex!)</li></ul><p>All length parameters must have same units (e.g., mm or cm)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/sensemap-sim.jl#L21-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}" href="#MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}"><code>MIRT.ir_mri_sensemap_sim_do</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap, info) = ir_mri_sensemap_sim_do()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/sensemap-sim.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_smap1-NTuple{4, Any}" href="#MIRT.ir_mri_smap1-NTuple{4, Any}"><code>MIRT.ir_mri_smap1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_mri_smap1()</code></pre><p>based on grivich:00:tmf</p><p>for a circular coil in &quot;x-y plane&quot; of radius &quot;a&quot;</p><p>Note that coil x-y plane is not same as object x-y plane!</p><p>Returns <code>(i,j,k)</code> components of B vector for each <code>(x,y,z)</code> location</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/sensemap-sim.jl#L239-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_smap_r-Tuple{Any, Any}" href="#MIRT.ir_mri_smap_r-Tuple{Any, Any}"><code>MIRT.ir_mri_smap_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_mri_smap_r(r, z)</code></pre><p>function for testing near 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/sensemap-sim.jl#L227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.jinc-Tuple{Real}" href="#MIRT.jinc-Tuple{Real}"><code>MIRT.jinc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jinc(x)</code></pre><p>Return <code>jinc(x) = J1(pi*x)/(2x)</code>, where <code>J1</code> is a Bessel function of the first kind.</p><p>Units of <code>x</code> are typically cycles/m.</p><p>Return type is <code>promote_type(typeof(x), Float32)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/jinc.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.map_many</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = map_many(fun::Function, x::AbstractArray{&lt;:Any}, idim::Dims)</code></pre><p>apply a function <code>fun</code> to leading slices of input <code>x</code>; cousin of <code>mapslices</code></p><p>in</p><ul><li><code>fun::Function</code> maps input of size <code>idim</code> to output of some size <code>odim</code></li><li><code>x [idim ldim]</code></li></ul><p>out</p><ul><li><code>y [odim ldim]</code></li></ul><p>Example: if <code>fun</code> maps array of size (1,2) to array of size (3,4,5) and if input <code>x</code> has size (1,2,7,8) then output <code>y</code> will have size (3,4,5,7,8) where <code>y[:,:,:,i,j] = fun(x[:,:,i,j])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/map_many.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mask_or-Tuple{AbstractMatrix{Bool}}" href="#MIRT.mask_or-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_or</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask_or(mask)</code></pre><p>compress 3D mask to 2D by logical <code>or</code> along <code>z</code> direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}" href="#MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_outline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask_outline(mask)</code></pre><p>return outer boundary of 2D mask (or mask_or for 3D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}" href="#MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.maskit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maskit(x::AbstractArray{&lt;:Number})</code></pre><p>opposite of embed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/mask.jl#L123-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.max_percent_diff-Tuple{Any, Any}" href="#MIRT.max_percent_diff-Tuple{Any, Any}"><code>MIRT.max_percent_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = max_percent_diff(s1, s2, [options])</code></pre><p>Compute the &quot;maximum percent difference&quot; between two signals: <code>s1, s2</code>.</p><p>Default is to normalize by <code>maximum(abs.(s1))</code>.</p><p>options</p><ul><li><code>maxboth::Bool</code> use max of both arguments to normalize; default <code>false</code></li><li><code>normalize::Bool</code> normalize each before comparing; default <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/max_percent_diff.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_kspace_spiral-Tuple{}" href="#MIRT.mri_kspace_spiral-Tuple{}"><code>MIRT.mri_kspace_spiral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace, omega, gradxy = mri_kspace_spiral( [options] )</code></pre><p>Make k-space spiral trajectory based on GE 3T scanner constraints</p><p>Option:</p><ul><li><code>N</code> dimention of reconstructed image</li><li><code>Nt</code> # of time points</li><li><code>fov</code> field of view in cm</li><li><code>dt</code> time sampling interval out; default <code>5e-6</code> sec</li><li><code>gamp::Real</code> design gradient amplitude max, G/cm; default 2.2</li><li><code>gslew::Int</code> design slew rate, mT/m/ms; default 180</li></ul><p>Out:</p><ul><li><code>kspace [Nt,2]</code> kspace trajectory <code>[kx ky]</code> in cycles/cm, NO: cycles/FOV</li><li><code>omega [Nt,2]</code> &quot;&quot; in radians</li><li><code>gradxy [Nt 2]</code> gradient waveforms in (units?)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/kspace-spiral.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_objects-Tuple{Symbol}" href="#MIRT.mri_objects-Tuple{Symbol}"><code>MIRT.mri_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_objects(key::Symbol ; fov::Real=22, unit::Symbol=:mm)</code></pre><p>Special cases</p><p>In:</p><ul><li><code>fov</code> Store the following parameter in fov.</li><li><code>unit</code> specify units; default :mm    Currently, only <code>:cm</code> (centimeters) supported as an alternate unit</li></ul><p>key choices:</p><ul><li><code>:case1</code> predefined 2D test case</li><li><code>:case4</code> predefined 3D test case</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_objects.jl#L404-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_objects-Tuple{Tuple}" href="#MIRT.mri_objects-Tuple{Tuple}"><code>MIRT.mri_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_objects((type,params)) for a single tuple</code></pre><p>Here the <code>params</code> can be a single row or column vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_objects.jl#L365-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_objects-Tuple{Vector{&lt;:Tuple}}" href="#MIRT.mri_objects-Tuple{Vector{&lt;:Tuple}}"><code>MIRT.mri_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">st = mri_objects([(:type1, params1), (:type2, params2), ...])</code></pre><p>Generate object that describes image-domain objects and Fourier domain spectra of simple structures such as rectangles, disks, superpositions thereof. These functions are useful for simple &quot;idealized&quot; MRI simulations where the data is modeled as analytical Fourier samples, i.e., no field inhomogeneity and no relaxation effects.</p><p>in</p><ul><li><code>[(type, params), ...]</code> e.g. <code>[(:rect2, params), (:gauss3, params), ...]</code></li></ul><p>type, params:</p><ul><li><code>:dirac2 [N 3] [xcent ycent value]</code></li><li><code>:dirac3 [N 4] [xcent ycent zcent value]</code></li><li><code>:rect2 [N 5] [xcent ycent xwidth ywidth value]</code></li><li><code>:rect3 [N 7] [xcent ycent zcent xwidth ywidth zwidth value]</code></li><li><code>:gauss2 [N 5] [xcent ycent xwidth ywidth value]</code></li><li><code>:gauss3 [N 7] [xcent ycent zcent xwidth ywidth zwidth value]</code></li><li><code>:circ2 [N 5] [xcent ycent rad value]</code></li><li><code>:cyl3 [N 6] [xcent ycent zcent xrad zwidth value]</code></li></ul><p>All types must be 2D or 3D, not mixed.</p><p>out</p><ul><li><code>st</code> struct</li><li><code>st.image(x,y)</code>  returns 2D image-domain (sampled) picture</li><li><code>st.image(x,y,z)</code> same but 3D</li><li><code>st.kspace(u,v)</code> returns 2D Fourier-space samples</li><li><code>st.kspace(u,v,w)</code> same but 3D</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_objects.jl#L312-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D" href="#MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D"><code>MIRT.mri_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace, omega, wi = mri_trajectory( ; ktype, N, fov, arg_wi, kwargs...)</code></pre><p>Generate kspace trajectory samples and density compensation functions.</p><p>option</p><ul><li><code>ktype::Symbol</code> k-space trajectory type; default <code>:radial</code></li><li><code>N::Dims</code> target image size; default (32,30)</li><li><code>fov</code> field of view in x and y (and z); default (250,250) mm</li><li><code>arg_wi</code> options to pass to <code>ir_mri_density_comp</code> - not yet done</li><li><code>kwargs</code> options for the specific trajectory</li></ul><p>out</p><ul><li><code>kspace [Nk 2|3]</code> kspace samples in units 1/fov</li><li><code>omega [Nk 2|3]</code> trajectory samples over [-π,π)</li><li><code>wi [Nk 1]</code> (optional) density compensation factors</li></ul><p>trajectory types: <code>:cartesian</code> <code>:radial</code> <code>:cart_y_2</code> <code>:random</code> <code>:half8</code> <code>:epi_sin</code> <code>:spiral0 :spiral1 :spiral3</code> <code>:rosette3</code> <code>:epi_under</code> <code>:gads</code> (emulate golden-angle data sharing per winkelmann:07:aor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_trajectory.jl#L15-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring" href="#MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring"><code>MIRT.mri_trajectory_gads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">omega, wi = mri_trajectory_gads(N, fov ; ...)</code></pre><p>emulate 2D golden angle radial sampling with data sharing</p><p>option: <code>Nro</code> # of samples in each readout/spoke <code>shift</code> shift along read-out due to gradient delays (stress) <code>kmax_frac</code> fractions of maximum krad (0.5) for rings (annuli) <code>under</code> under-sampling factor for each annulus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_trajectory.jl#L210-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}" href="#MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}"><code>MIRT.mri_trajectory_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_trajectory_radial()</code></pre><p>option:</p><ul><li><code>na_nr</code> default ensures proper sampling at edge of k-space</li><li><code>na</code> angular spokes; default: na_nr * nr</li><li><code>nr</code> radial samples per spoke</li><li><code>ir</code> default: <code>0:nr</code></li></ul><p>todo: generalize to 3D using barger:02:trc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_trajectory.jl#L258-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory_rosette3-Tuple{Any, Any}" href="#MIRT.mri_trajectory_rosette3-Tuple{Any, Any}"><code>MIRT.mri_trajectory_rosette3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_trajectory_rosette3(N, fov ; ...)</code></pre><p>3d rosette, with default parameters from bucholz:08:miw</p><p>options: omax: maximum omega nt : time samples (65.536 ms for 4 usec dt) dt : time sample spacing (4 usec) ti : time samples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/mri_trajectory.jl#L295-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.my_rect-Tuple{Any, Any}" href="#MIRT.my_rect-Tuple{Any, Any}"><code>MIRT.my_rect</code></a> — <span class="docstring-category">Method</span></header><section><div><p>params = my_rect(xfov, yfov)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L275-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}" href="#MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(x,out) = ncg(B, gradf, curvf, x0 ; ...)</code></p><p>Nonlinear preconditioned conjugate gradient algorithm to minimize a general &quot;inverse problem&quot; cost function of the form <span>$\Psi(x) = \sum_{j=1}^J f_j(B_j x)$</span> where each function <span>$f_j(v)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(v;u) = f_j(u) + \nabla f_j(u) (v - u) + 1/2 \|v - u\|^2_{C_j(u)}\]</p><p>where <span>$C_j(u)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>This CG method uses a majorize-minimize (MM) line search.</p><p>in</p><ul><li><code>B</code>		array of <span>$J$</span> blocks <span>$B_1,...,B_J$</span></li><li><code>gradf</code>	array of <span>$J$</span> functions return gradients of <span>$f_1,...,f_J$</span></li><li><code>curvf</code>	array of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar</li></ul><p>or a vector of curvature values for each element of <span>$z$</span></p><ul><li><code>x0</code>	initial guess; need <code>length(x) == size(B[j],2)</code> for <span>$j=1...J$</span></li></ul><p>Usually <code>x0</code> is a <code>Vector</code> but it can be an <code>Array</code> if each <code>B_j</code> is a linear operator (e.g., <code>LinearMapAO</code>) of suitable &quot;dimensions&quot;.</p><p>option</p><ul><li><code>niter</code>	# number of outer iterations; default 50</li><li><code>ninner</code>	# number of inner iterations of MM line search; default 5</li><li><code>P</code>		# preconditioner; default <code>I</code></li><li><code>betahow</code>	&quot;beta&quot; method for the search direction; default <code>:dai_yuan</code></li><li><code>fun</code>		User-defined function to be evaluated with two arguments (x,iter).<ul><li>It is evaluated at (x0,0) and then after each iteration.</li></ul></li></ul><p>output</p><ul><li><code>x</code>		final iterate</li><li><code>out</code>		<code>[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))</code><ul><li>(all 0 by default). This is an array of length <code>niter+1</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/algorithm/general/ncg.jl#L14-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}" href="#MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(x,out) = ncg(grad, curv, x0, ...)</code></p><p>special case of <code>ncg</code> (nonlinear CG) for minimizing a cost function whose gradient is <code>grad(x)</code> and that has a quadratic majorizer with diagonal Hessian given by <code>curv(x)</code>. Typically <code>curv = (x) -&gt; L</code> where <code>L</code> is the Lipschitz constant of <code>grad</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/algorithm/general/ncg.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ndgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}" href="#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>MIRT.ndgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(xx,yy,zz) = ndgrid(x::AbstractVector{&lt;:Any}, y::..., z::...)</code> todo - improve?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/ndgrid.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ndgrid-Tuple{AbstractVector, AbstractVector}" href="#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector}"><code>MIRT.ndgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(xx,yy) = ndgrid(x::AbstractVector{&lt;:Any}, y::AbstractVector{&lt;:Any})</code> todo - improve?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/ndgrid.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}" href="#MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}"><code>MIRT.nufft_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nufft_eltype(::DataType)</code></pre><p>ensure plan_nfft eltype is Float32 or Float64</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/nufft.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_errors-Tuple{}" href="#MIRT.nufft_errors-Tuple{}"><code>MIRT.nufft_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">w, errs = nufft_errors( ; M=?, w=?, N=?, n_shift=?, ...)</code></pre><p>Compute NUFFT approximation errors (for signal of length <code>N</code> of unit norm), for given digital frequency values <code>w</code>, i.e., Ω.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/errors.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}" href="#MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.nufft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=0)</code></pre><p>Setup 1D NUFFT, for computing fast <span>$O(N \log N)$</span> approximation to</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m] (n - n_{shift})), m=1,…,M$</span></p><p>in</p><ul><li><code>w::AbstractArray{&lt;:Real}</code> <code>[M]</code> frequency locations (units radians/sample)<ul><li><code>eltype(w)</code> determines the <code>plan_nfft</code> type; so to save memory use Float32!</li><li><code>size(w)</code> determines <code>odim</code> for <code>A</code> if <code>operator=true</code></li></ul></li><li><code>N::Int</code> signal length</li></ul><p>option</p><ul><li><code>nfft_m::Int</code>		see NFFT.jl documentation; default 4</li><li><code>nfft_sigma::Real</code>	&quot;&quot;, default 2.0</li><li><code>n_shift::Real</code>		often is N/2; default 0</li><li><code>pi_error::Bool</code>		throw error if <span>$|w| &gt; π$</span>, default <code>true</code><ul><li>Set to <code>false</code> only if you are very sure of what you are doing!</li></ul></li><li><code>do_many::Bool</code>	support extended inputs via <code>map_many</code>? default <code>true</code></li><li><code>operator::Bool=true</code> set to <code>false</code> to make <code>A</code> an <code>LinearMapAM</code></li></ul><p>out</p><ul><li><code>p NamedTuple</code></li></ul><p><code>(nufft = x -&gt; nufft(x), adjoint = y -&gt; nufft_adj(y), A::LinearMapAO)</code></p><p>The default settings are such that for a 1D signal of length N=512, the worst-case error is below 1e-5 which is probably adequate for typical medical imaging applications. To verify this statement, run <code>nufft_plot1()</code> and see plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/nufft.jl#L42-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.nufft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=?)</code></pre><p>Setup multi-dimensional NUFFT, for computing fast <span>$O(N \log N)$</span> approximation to</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m,:] (n - n_{shift})), m=1,…,M$</span></p><p>in</p><ul><li><code>w::AbstractArray{&lt;:Real}</code> <code>[M,D]</code> frequency locations (units radians/sample)</li></ul><pre><code class="nohighlight hljs">+ `eltype(w)` determines the `plan_nfft` type; so to save memory use Float32!
+ `size(w)[1:(end-1)]` determines `odim` if `operator=true`</code></pre><ul><li><code>N::Dims{D}</code> signal dimensions</li></ul><p>option</p><ul><li><code>nfft_m::Int</code>		see NFFT.jl documentation; default 4</li><li><code>nfft_sigma::Real</code>	&quot;&quot;, default 2.0</li><li><code>n_shift::AbstractVector{&lt;:Real}</code>	<code>[D]</code>	often is N/2; default zeros(D)</li><li><code>pi_error::Bool</code>		throw error if <span>$|w| &gt; π$</span>, default <code>true</code><ul><li>Set to <code>false</code> only if you are very sure of what you are doing!</li></ul></li><li><code>do_many::Bool</code>	support extended inputs via <code>map_many</code>? default <code>true</code></li><li><code>operator::Bool=true</code> set to <code>false</code> to make <code>A</code> an <code>LinearMapAM</code></li></ul><p>The default <code>do_many</code> option is designed for parallel MRI where the k-space sampling pattern applies to every coil. It may also be useful for dynamic MRI with repeated sampling patterns. The coil and/or time dimensions must come after the spatial dimensions.</p><p>out</p><ul><li><code>p NamedTuple</code> with fields</li></ul><pre><code class="nohighlight hljs">`nufft = x -&gt; nufft(x), adjoint = y -&gt; nufft_adj(y), A=LinearMapAO`
(Using `operator=true` allows the `LinearMapAO` to support `do_many`.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/nufft.jl#L122-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T" href="#MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>MIRT.nufft_typer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nufft_typer(T::DataType, x::AbstractArray{&lt;:Real} ; warn::Bool=true)</code></pre><p>type conversion wrapper for <code>nfft()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/nufft/nufft.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}" href="#MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ogm_ls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ogm_ls(B, gradf, curvf, x0; niter=?, ninner=?, fun=?)</code></pre><p>OGM with a line search; Drori&amp;Taylor @arxiv 1803.05676; to minimize a general &quot;inverse problem&quot; cost function of the form <span>$\Psi(x) = \sum_{j=1}^J f_j(B_j x)$</span> where each function <span>$f_j(v)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(v;u) = f_j(u) + \nabla f_j(u) (v - u) + 1/2 \|v - u\|^2_{C_j(u)}\]</p><p>where <span>$C_j(u)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>This OGM method uses a majorize-minimize (MM) line search.</p><p>in</p><ul><li><code>B</code>		array of <span>$J$</span> blocks <span>$B_1,...,B_J$</span></li><li><code>gradf</code>	array of <span>$J$</span> functions return gradients of <span>$f_1,...,f_J$</span></li><li><code>curvf</code>	array of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar</li></ul><p>or a vector of curvature values for each element of <span>$z$</span></p><ul><li><code>x0</code>	initial guess; need <code>length(x) == size(B[j],2)</code> for <span>$j=1...J$</span></li></ul><p>option</p><ul><li><code>niter</code>	# number of outer iterations; default 50</li><li><code>ninner</code>	# number of inner iterations of MM line search; default 5</li><li><code>fun</code>		User-defined function to be evaluated with two arguments (x,iter).</li><li>It is evaluated at (x0,0) and then after each iteration.</li></ul><p>output</p><ul><li><code>x</code>		final iterate</li><li><code>out</code>		<code>[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))</code><ul><li>(all 0 by default). This is an array of length <code>niter+1</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/algorithm/general/ogm_ls.jl#L12-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}" href="#MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}"><code>MIRT.ogm_ls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ogm_ls(grad, curv, x0, ...)</code></pre><p>special case of <code>ogm_ls</code> (OGM with line search) for minimizing a cost function whose gradient is <code>grad(x)</code> and that has a quadratic majorizer with diagonal Hessian given by <code>curv(x)</code>. Typically <code>curv = (x) -&gt; L</code> where <code>L</code> is the Lipschitz constant of <code>grad</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/algorithm/general/ogm_ls.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.pogm_restart-Tuple{Any, Function, Function, Real}" href="#MIRT.pogm_restart-Tuple{Any, Function, Function, Real}"><code>MIRT.pogm_restart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x, out = pogm_restart(x0, Fcost, f_grad, f_L ;
f_mu=0, mom=:pogm, restart=:gr, restart_cutoff=0.,
bsig=1, niter=10, g_prox=(z,c)-&gt;z, fun=...)</code></pre><p>Iterative proximal algorithms (PGM=ISTA, FPGM=FISTA, POGM) with restart.</p><p><strong>in</strong></p><ul><li><code>x0</code> initial guess</li><li><code>Fcost</code> function for computing the cost function value <span>$F(x)$</span><ul><li>(needed only if <code>restart === :fr</code>)</li></ul></li><li><code>f_grad</code> function for computing the gradient of <span>$f(x)$</span></li><li><code>f_L</code> Lipschitz constant of the gradient of <span>$f(x)$</span></li></ul><p><strong>option</strong></p><ul><li><code>f_mu</code> strong convexity parameter of <span>$f(x)$</span>; default 0.<ul><li>if <code>f_mu &gt; 0</code>, <span>$(\alpha, \beta_k, \gamma_k)$</span> is chosen by Table 1 in [KF18]</li></ul></li><li><code>g_prox</code> function <code>g_prox(z,c)</code> for the proximal operator for <span>$g(x)$</span><ul><li><code>g_prox(z,c)</code> computes <span>$argmin_x 1/2 \|z-x\|^2 + c \, g(x)$</span></li></ul></li><li><code>mom</code>	momentum option<ul><li><code>:pogm</code> POGM (fastest); default!</li><li><code>:fpgm</code> (FISTA), <span>$\gamma_k = 0$</span></li><li><code>:pgm</code> PGM (ISTA), <span>$\beta_k = \gamma_k = 0$</span></li></ul></li><li><code>restart</code> restart option<ul><li><code>:gr</code> gradient restart; default!</li><li><code>:fr</code> function restart</li><li><code>:none</code> no restart</li></ul></li><li><code>restart_cutoff</code> for <code>:gr</code> restart if cos(angle) &lt; this; default 0.</li><li><code>bsig</code> gradient &quot;gamma&quot; decrease option (value within [0 1]); default 1<ul><li>see <span>$\bar{\sigma}$</span> in [KF18]</li></ul></li><li><code>niter</code> number of iterations; default 10</li><li><code>fun</code> function<code>(iter, xk, yk, is_restart)</code> user-defined function evaluated each <code>iter</code> with secondary <code>xk</code>, primary <code>yk</code>, and boolean <code>is_restart</code> indicating whether this iteration was a restart</li></ul><p><strong>out</strong></p><ul><li><code>x</code>	final iterate<ul><li>for PGM (ISTA): <span>$x_N = y_N$</span></li><li>for FPGM (FISTA): primary iterate <span>$y_N$</span></li><li>for POGM: secondary iterate <span>$x_N$</span>, see [KF18]</li></ul></li><li><code>out [fun(0, x0, x0, false), fun(1, x1, y1, is_restart), ...]</code> array of length <code>[niter+1]</code></li></ul><p>Optimization Problem: Nonsmooth Composite Convex Minimization</p><ul><li><span>$argmin_x F(x),  F(x) := f(x) + g(x))$</span><ul><li><span>$f(x)$</span> smooth convex function</li><li><span>$g(x)$</span> convex function, possibly nonsmooth and &quot;proximal-friendly&quot; [CP11]</li></ul></li></ul><p><strong>Optimization Algorithms:</strong></p><p>Accelerated First-order Algorithms when <span>$g(x) = 0$</span> [KF18] iterate as below for given coefficients <span>$(\alpha, \beta_k, \gamma_k)$</span></p><ul><li>For k = 0,1,...<ul><li><span>$y_{k+1} = x_k - \alpha  f&#39;(x_k)$</span> : gradient update</li><li><span>$x_{k+1} = y_{k+1} + \beta_k  (y_{k+1} - y_k) + \gamma_k  (y_{k+1} - x_k)$</span> : momentum update</li></ul></li></ul><p>Proximal versions of the above for <span>$g(x) \neq 0$</span> are in the below references, and use the proximal operater <span>$prox_g(z) = argmin_x {1/2\|z-x\|^2 + g(x)}$</span>.</p><ul><li>Proximal Gradient method (PGM or ISTA) - <span>$\beta_k = \gamma_k = 0$</span>. [BT09]</li><li>Fast Proximal Gradient Method (FPGM or FISTA) - <span>$\gamma_k = 0$</span>. [BT09]</li><li>Proximal Optimized Gradient Method (POGM) - [THG15]</li><li>FPGM(FISTA) with Restart - [OC15]</li><li>POGM with Restart - [KF18]</li></ul><p><strong>references</strong></p><ul><li>[CP11] P. L. Combettes, J. C. Pesquet,</li></ul><p>&quot;Proximal splitting methods in signal processing,&quot;  Fixed-Point Algorithms for Inverse Problems in Science and Engineering,  Springer, Optimization and Its Applications, 2011.</p><ul><li>[KF18] D. Kim, J.A. Fessler,</li></ul><p>&quot;Adaptive restart of the optimized gradient method for convex optimization,&quot; 2018  Arxiv:1703.04641,  [http://doi.org/10.1007/s10957-018-1287-4]</p><ul><li>[BT09] A. Beck, M. Teboulle:</li></ul><p>&quot;A fast iterative shrinkage-thresholding algorithm for linear inverse problems,&quot;  SIAM J. Imaging Sci., 2009.</p><ul><li>[THG15] A.B. Taylor, J.M. Hendrickx, F. Glineur,</li></ul><p>&quot;Exact worst-case performance of first-order algorithms  for composite convex optimization,&quot; Arxiv:1512.07516, 2015,  SIAM J. Opt. 2017  [http://doi.org/10.1137/16m108104x]</p><p>Copyright 2017-3-31, Donghwan Kim and Jeff Fessler, University of Michigan 2018-08-13 Julia 0.7.0 2019-02-24 interface redesign</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/algorithm/general/pogm_restart.jl#L17-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.poweriter-Tuple{Any}" href="#MIRT.poweriter-Tuple{Any}"><code>MIRT.poweriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">v1,σ1 = poweriter(A; niter=?, ...)</code></pre><p>Determine first right singular vector <code>v1</code> and first singular value <code>σ1</code> of <code>A</code> by applying power iteration to <code>A&#39;A</code></p><p>in</p><ul><li><code>A</code> M × N matrix</li></ul><p>option</p><ul><li><code>niter</code> default 200</li><li><code>x0</code> initial guess of <code>v1</code></li><li><code>tol</code> stopping tolerance for s1, default 1e-6</li><li><code>chat::Bool</code> verbose? default false</li></ul><p>out</p><ul><li><code>v1</code> <code>[N]</code> principal right singular vector</li><li><code>σ1</code> spectral norm of <code>A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/algorithm/general/poweriter.jl#L11-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect-Tuple{Real}" href="#MIRT.rect-Tuple{Real}"><code>MIRT.rect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rect(x::Real)</code></pre><p>Unit width rect function. Potential problem? Bring up with fess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/rect.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Real}}" href="#MIRT.rect_im-Tuple{ImageGeom, AbstractMatrix{&lt;:Real}}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(ig, params ;
oversample=1, hu_scale=1, fov=maximum(ig.fovs), chat=false, how=:auto,
replace=false, return_params=false)</code></pre><p>generate rectangle phantom image from parameters:  <code>[x_center y_center x_width y_width angle_degrees amplitude]</code></p><p>in</p><ul><li><code>ig</code>				<code>image_geom()</code> object</li><li><code>params</code>			<code>[Nrect,6]</code> rect parameters. if empty use default</li></ul><p>options</p><ul><li><code>oversample::Int</code>	oversampling factor, for grayscale boundaries</li><li><code>hu_scale::Real</code>		use 1000 to scale</li><li><code>fov::Real</code>			default <code>maximum(ig.fovs)</code></li><li><code>chat::Bool</code>			verbosity?</li><li><code>how::Symbol</code>			<code>:fast</code> or <code>:slow</code>; default <code>:auto</code></li><li><code>replace::Bool</code>		default <code>false</code></li><li><code>return_params::Bool</code>	if true, return both phantom and params</li></ul><p>out</p><ul><li><code>phantom</code>		<code>[nx ny]</code> image (Float32)</li><li><code>params</code>		<code>[Nrect 6]</code> rect parameters (only return if <code>return_params=true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L11-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{ImageGeom, Symbol}" href="#MIRT.rect_im-Tuple{ImageGeom, Symbol}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(ig, code ; args...)</code></pre><p><code>code = :my_rect | :default | :smiley</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{ImageGeom}" href="#MIRT.rect_im-Tuple{ImageGeom}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(ig ; args...)</code></pre><p><code>:default</code> (default) for given image geometry <code>ig</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{Int64, Any}" href="#MIRT.rect_im-Tuple{Int64, Any}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(nx::Int, params ; args...)</code></pre><p>square image of size <code>nx</code> by <code>nx</code> with pixel size <code>dx=1</code> and rect <code>params</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{Int64, Int64}" href="#MIRT.rect_im-Tuple{Int64, Int64}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(nx::Int, ny::Int ; args...)</code></pre><p><code>:my_rect</code> of size <code>nx</code> by <code>ny</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{Int64, Real, Any}" href="#MIRT.rect_im-Tuple{Int64, Real, Any}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(nx, dx, params ; args...)</code></pre><p>square image of size <code>nx</code> by <code>nx</code>, specifying pixel size <code>dx</code> and rect <code>params</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im-Tuple{Int64}" href="#MIRT.rect_im-Tuple{Int64}"><code>MIRT.rect_im</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im(nx::Int ; ny::Int=nx, dx::Real=1)</code></pre><p>image of size <code>nx</code> by <code>ny</code> (default <code>nx</code>) with specified <code>dx</code> (default 1), defaults to <code>:my_rect</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im_default_parameters-Tuple{Any, Any}" href="#MIRT.rect_im_default_parameters-Tuple{Any, Any}"><code>MIRT.rect_im_default_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>params = rect<em>im</em>default_parameters(xfov, yfov)</p><p>default parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im_fast-NTuple{8, Any}" href="#MIRT.rect_im_fast-NTuple{8, Any}"><code>MIRT.rect_im_fast</code></a> — <span class="docstring-category">Method</span></header><section><div><p>phantom = rect<em>im</em>fast() for non-rotated rectangles 	using exact integration over each pixel so over-sampling is irrelevant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_im_slow-NTuple{8, Any}" href="#MIRT.rect_im_slow-NTuple{8, Any}"><code>MIRT.rect_im_slow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phantom = rect_im_slow()</code></pre><p>for rotated rectangles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L132-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_sino-Tuple{AbstractArray{&lt;:Real}, AbstractArray{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#MIRT.rect_sino-Tuple{AbstractArray{&lt;:Real}, AbstractArray{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>MIRT.rect_sino</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino = rect_sino(rg::AbstractArray{&lt;:Real}, ϕg::AbstractArray{&lt;:Real},
	rects ; oversample=1, xscale=1, yscale=1)</code></pre><p>Create sinogram projection of one or more rectangles, for arbitrary radial/angular sampling grid locations <code>(rg, ϕg)</code></p><p>in</p><ul><li><code>rg::AbstractArray{&lt;:Real}</code>	radial sampling locations</li><li><code>ϕg::AbstractArray{&lt;:Real}</code>	angular sampling locations (radians)</li><li><code>rects::Matrix</code> <code>[n 6]</code> rectangle parameters<ul><li><code>[centx centy widthx widthy angle_degrees value]</code></li></ul></li></ul><p>options</p><ul><li><code>xscale::Int</code> use -1 to flip in x (not recommended); default 1</li><li><code>yscale::Int</code> use -1 to flip in y (not recommended); default 1</li></ul><p>out</p><ul><li><code>sino::AbstractArray{Float32}</code> same size as <code>rg</code> and <code>ϕg</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_sino.jl#L51-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect_sino-Tuple{SinoGeom, AbstractMatrix{&lt;:Real}}" href="#MIRT.rect_sino-Tuple{SinoGeom, AbstractMatrix{&lt;:Real}}"><code>MIRT.rect_sino</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino = rect_sino(sg, rects ; oversample=1, xscale=1, yscale=1)</code></pre><p>Create sinogram projection of one or more rectangles. Works for any sinogram geometry.</p><p>in</p><ul><li><code>sg::SinoGeom</code> sinogram geometry object from <code>sino_geom()</code></li><li><code>rects::Matrix</code> <code>[ne 6]</code> rectangle parameters<ul><li><code>[centx centy widthx widthy angle_degrees value]</code></li></ul></li></ul><p>options</p><ul><li><code>oversample::Int</code>	oversampling factor for emulating &quot;strips&quot;<ul><li>default 1: just 1 ray per detector element</li></ul></li><li><code>xscale::Int</code>		use -1 to flip in x (not recommended); default 1</li><li><code>yscale::Int</code>		use -1 to flip in y (not recommended); default 1</li></ul><p>out</p><ul><li><code>sino</code>		<code>[nb na]</code> sinogram</li></ul><p>To get the sample locations, use <code>(pos,ang) = sg.grid</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_sino.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.reshaper-Tuple{AbstractArray, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.reshaper-Tuple{AbstractArray, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.reshaper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reshaper(x::AbstractArray, dim:Dims)</code></pre><p>Reshape <code>x</code> to size <code>dim</code> with <code>:</code> only if needed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L517-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}" href="#MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}"><code>MIRT.reverser</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = reverser(x, dims)</code></pre><p>reverse array along specified dimensions (or all if unspecified)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/reverser.jl#L10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}" href="#MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}"><code>MIRT.rmsd100</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmsd = rmsd100(x, y ; mask)</code></pre><p>Compute 100 * RMSD (root mean squared difference) between <code>x</code> and <code>y</code> within domain mask.</p><p>in</p><ul><li><code>x</code> : array</li><li><code>y</code> : another array of same size</li></ul><p>option:</p><ul><li><code>mask::Array{Bool}</code> : domain over which to compute the RMSE; default <code>trues(size(x))</code></li></ul><p>out</p><ul><li>rmsd : rmsd of <code>x</code> vs <code>y</code> within <code>mask</code> in %</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/utility/rmsd100.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rot3-NTuple{5, Any}" href="#MIRT.rot3-NTuple{5, Any}"><code>MIRT.rot3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rot3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipsoid_im.jl#L373-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rotate2d-Tuple{Any, Any, Any}" href="#MIRT.rotate2d-Tuple{Any, Any, Any}"><code>MIRT.rotate2d</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(xr,yr) = rotate2d(x, y, theta)</code> 2D rotation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rotate2d.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.shepp_logan_3d_parameters-NTuple{4, Any}" href="#MIRT.shepp_logan_3d_parameters-NTuple{4, Any}"><code>MIRT.shepp_logan_3d_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shepp_logan_3d_parameters()</code></pre><p>most of these values are unitless &#39;fractions of field of view&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipsoid_im.jl#L385-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.shepp_logan_parameters-Tuple{Number, Number}" href="#MIRT.shepp_logan_parameters-Tuple{Number, Number}"><code>MIRT.shepp_logan_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>params = shepp<em>logan</em>parameters(xfov, yfov ; case::Symbol ; u::Tuple)</p><p>Shepp Logan phantom parameters from Kak and Slaney text, p. 255.</p><p>By default the first four columns are unitless &quot;fractions of field of view&quot;, so columns 1,3 are scaled by <code>xfov</code> and columns 2,4 are scaled by <code>xfov</code>. The optional 3-tuple <code>u</code> specifies scaling and/or units:</p><ul><li>columns 1-4 (center, radii) are scaled by <code>u[1]</code> (e.g., mm),</li><li>column 5 (angle) is scaled by <code>u[2]</code> (e.g., <code>1</code> or <code>°</code>),</li><li>column 6 (value) is scaled by <code>u[3]</code> (e.g., <code>1/cm</code>) for an attenuation map.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L283-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom-Tuple{Symbol}" href="#MIRT.sino_geom-Tuple{Symbol}"><code>MIRT.sino_geom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sg = sino_geom(...)</code></pre><p>Constructor for <code>SinoGeom</code></p><p>Create the &quot;sinogram geometry&quot; structure that describes the sampling characteristics of a given sinogram for a 2D parallel or fan-beam system. Using this structure facilitates &quot;object oriented&quot; code. (Use <code>ct_geom()</code> instead for 3D axial or helical cone-beam CT.)</p><p>in</p><ul><li><code>how::Symbol</code>	<code>:fan</code> (fan-beam) | <code>:par</code> (parallel-beam) | <code>:moj</code> (mojette)</li></ul><p>options for all geometries (including parallel-beam):</p><ul><li><code>units::Symbol</code>	e.g. <code>:cm</code> or <code>:mm</code>; default: :none</li><li><code>orbit_start</code>		default: 0</li><li><code>orbit</code>			[degrees] default: <code>180</code> for parallel / mojette</li></ul><p>and <code>360</code> for fan</p><ul><li><p>can be <code>:short</code> for fan-beam short scan</p></li><li><p><code>down::Int</code>		down-sampling factor, for testing</p></li><li><p><code>nb</code>				# radial samples cf <code>nr</code> (i.e., <code>ns</code> for <code>:fan</code>)</p></li><li><p><code>na</code>				# angular samples (cf <code>nbeta</code> for <code>:fan</code>)</p></li><li><p><code>d</code>				radial sample spacing; cf <code>dr</code> or <code>ds</code>; default 1</p></li><li><p>for mojette this is actually <code>dx</code></p></li><li><p><code>offset</code>			cf <code>offset_r</code> <code>channel_offset</code> unitless; default 0</p></li><li><p>(relative to centerline between two central channels).</p></li><li><p>Use 0.25 or 1.25 for &quot;quarter-detector offset&quot;</p></li><li><p><code>strip_width</code>		detector width; default: <code>d</code></p></li></ul><p>options for fan-beam</p><ul><li><code>source_offset</code>		same units as d; use with caution! default 0</li></ul><p>fan beam distances:</p><ul><li><code>dsd</code> cf <code>dis_src_det</code> default: <code>Inf</code> (parallel beam)</li><li><code>dod</code> cf <code>dis_iso_det</code> default: <code>0</code></li><li><code>dfs</code> cf <code>dis_foc_src</code> default: <code>0</code> (3rd generation CT arc),<ul><li>use <code>Inf</code> for flat detector</li></ul></li></ul><p>out</p><ul><li><code>sg::SinoGeom</code>	initialized structure</li></ul><p>See also</p><ul><li><code>sino_geom_help()</code> help on methods</li><li><code>sino_geom_plot_grids()</code> show sampling</li></ul><p>Jeff Fessler, University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L123-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_fan-Tuple{}" href="#MIRT.sino_geom_fan-Tuple{}"><code>MIRT.sino_geom_fan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sg = sino_geom_fan()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L246-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_gamma-Tuple{SinoFan}" href="#MIRT.sino_geom_gamma-Tuple{SinoFan}"><code>MIRT.sino_geom_gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_gamma()</code></pre><p>gamma sample values for :fan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L335-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_gamma_dfs-Tuple{SinoFan}" href="#MIRT.sino_geom_gamma_dfs-Tuple{SinoFan}"><code>MIRT.sino_geom_gamma_dfs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>gamma for general finite dfs (rarely used)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_ge1-Tuple{}" href="#MIRT.sino_geom_ge1-Tuple{}"><code>MIRT.sino_geom_ge1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_ge1()</code></pre><p>sinogram geometry for GE lightspeed system These numbers are published in IEEE T-MI Oct. 2006, p.1272-1283 wang:06:pwl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L525-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_grid-Tuple{SinoPar}" href="#MIRT.sino_geom_grid-Tuple{SinoPar}"><code>MIRT.sino_geom_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(rg, ϕg) = sino_geom_grid(sg::SinoGeom)</code></pre><p>Return grids <code>rg</code> and <code>ϕg</code> (in radians) of size <code>[nb na]</code> of equivalent <em>parallel-beam</em> <code>(r,ϕ)</code> (radial, angular) sampling positions, for any sinogram geometry. For parallel beam this is just <code>ndgrid(sg.r, sg.ar)</code> but for fan beam and mojette this involves more complicated computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L421-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_help-Tuple{}" href="#MIRT.sino_geom_help-Tuple{}"><code>MIRT.sino_geom_help</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_help()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_moj-Tuple{}" href="#MIRT.sino_geom_moj-Tuple{}"><code>MIRT.sino_geom_moj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sg = sino_geom_moj( ... )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L306-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_over-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:MIRT.SinoParallel" href="#MIRT.sino_geom_over-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:MIRT.SinoParallel"><code>MIRT.sino_geom_over</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sg = sino_geom_over(sg, over::Int)</code></pre><p>over-sample in &quot;radial&quot; dimension For Mojette sampling, it means that <code>d = dx/over</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_par-Tuple{}" href="#MIRT.sino_geom_par-Tuple{}"><code>MIRT.sino_geom_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sg = sino_geom_par( ... )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L286-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_plot!-Tuple{SinoGeom, Function}" href="#MIRT.sino_geom_plot!-Tuple{SinoGeom, Function}"><code>MIRT.sino_geom_plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_plot!(sg, plot! ; ig)</code></pre><p>Picture of the source position / detector geometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_plot.jl#L60-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_plot_grid-Tuple{SinoGeom, Function}" href="#MIRT.sino_geom_plot_grid-Tuple{SinoGeom, Function}"><code>MIRT.sino_geom_plot_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_plot_grid(sg, Plots.scatter) &lt;- trick to avoid Plots.dependency</code></pre><p>Scatter plot of <code>(r,phi)</code> sampling locations from <code>sg.grid</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_plot.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_plot_grids-Tuple{Function}" href="#MIRT.sino_geom_plot_grids-Tuple{Function}"><code>MIRT.sino_geom_plot_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_plot_grids()</code></pre><p>scatter plot of (r,phi) sampling locations for all geometries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_plot.jl#L29-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_rfov-Tuple{SinoPar}" href="#MIRT.sino_geom_rfov-Tuple{SinoPar}"><code>MIRT.sino_geom_rfov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_rfov()</code></pre><p>radial FOV</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L346-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_taufun-Tuple{SinoGeom, Any, Any}" href="#MIRT.sino_geom_taufun-Tuple{SinoGeom, Any, Any}"><code>MIRT.sino_geom_taufun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_taufun()</code></pre><p>projected <code>s/ds</code>, useful for footprint center and support</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L376-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_unitv-Tuple{SinoGeom}" href="#MIRT.sino_geom_unitv-Tuple{SinoGeom}"><code>MIRT.sino_geom_unitv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_unitv()</code></pre><p>sinogram with a single ray</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L406-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_xds-Tuple{SinoPar}" href="#MIRT.sino_geom_xds-Tuple{SinoPar}"><code>MIRT.sino_geom_xds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_xds()</code></pre><p>center positions of detectors (for beta = 0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L386-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.sino_geom_yds-Tuple{SinoPar}" href="#MIRT.sino_geom_yds-Tuple{SinoPar}"><code>MIRT.sino_geom_yds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_yds()</code></pre><p>center positions of detectors (for beta = 0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L396-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.smiley_parameters-Tuple{Any, Any}" href="#MIRT.smiley_parameters-Tuple{Any, Any}"><code>MIRT.smiley_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>params = smiley_parameters(xfov, yfov)</code></p><p>smiley face out of rects</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_im.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}" href="#MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}"><code>MIRT.snr2sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snr2sigma(db, yb)</code></pre><p>Convert SNR in dB to noise σ for complex gaussian noise. No <code>sqrt(2)</code> factors is needed here because <code>randn(Complex{Float})</code> already accounts for that. (See <code>randn</code> documentation.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/mri/coil_compress.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.south_park_parameters-Tuple{}" href="#MIRT.south_park_parameters-Tuple{}"><code>MIRT.south_park_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>param = south<em>park</em>parameters( ; fov::Number = 100)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/ellipse_im.jl#L326-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.trapezoid-NTuple{5, Real}" href="#MIRT.trapezoid-NTuple{5, Real}"><code>MIRT.trapezoid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>trapezoid(t::Real, t1, t2, t3, t4)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/rect_sino.jl#L134-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ImageGeom" href="#MIRT.ImageGeom"><code>MIRT.ImageGeom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageGeom{D,S}</code></pre><p>Image geometry struct with essential grid parameters.</p><ul><li><code>dims::Dims{D}</code> image dimensions</li><li><code>deltas::S</code> where <code>S &lt;: NTuple{D}</code> pixel sizes, where each Δ is usually <code>Real</code> or <code>Unitful.Length</code></li><li><code>offsets::NTuple{D,Float32}</code> unitless</li><li><code>mask::AbstractArray{Bool,D}</code> logical mask, often <code>FillArrays.Trues(dims)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ImageGeom-Union{Tuple{S}, Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, S, Tuple{Vararg{Real, D}}, AbstractArray{Bool, D}}} where {D, S&lt;:Tuple{Vararg{Number, D}}}" href="#MIRT.ImageGeom-Union{Tuple{S}, Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, S, Tuple{Vararg{Real, D}}, AbstractArray{Bool, D}}} where {D, S&lt;:Tuple{Vararg{Number, D}}}"><code>MIRT.ImageGeom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ig = ImageGeom(dims, deltas, offsets, [, mask])</code></pre><p>Convenient constructor for <code>ImageGeom</code>. The <code>deltas</code> elements should each be <code>Real</code> or a <code>Unitful.Length</code>. Default <code>mask</code> is <code>FillArrays.Trues(dims)</code> which is akin to <code>trues(dims)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ImageGeom-Union{Tuple{}, Tuple{D}} where D" href="#MIRT.ImageGeom-Union{Tuple{}, Tuple{D}} where D"><code>MIRT.ImageGeom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ig = ImageGeom( ; nx=128, dims=(nx,nx), deltas=(1,1), offsets=(0,0), mask=Trues(dims))</code></pre><p>Convenience constructor for 2D case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L74-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.MIRT_cbct_ig" href="#MIRT.MIRT_cbct_ig"><code>MIRT.MIRT_cbct_ig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MIRT_cbct_ig</code></pre><p>Structure suitable for passing to C routines <code>cbct_*</code> based on the struct <code>cbct_ig</code> found in <code>cbct,def.h</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/image_geom.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.SinoFanArc" href="#MIRT.SinoFanArc"><code>MIRT.SinoFanArc</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SinoFanArc</code> 2D Fan-beam sinogram geometry for arc detector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.SinoFanFlat" href="#MIRT.SinoFanFlat"><code>MIRT.SinoFanFlat</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SinoFanFlat</code> 2D Fan-beam sinogram geometry for flat detector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.SinoMoj" href="#MIRT.SinoMoj"><code>MIRT.SinoMoj</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SinoMoj</code> 2D Mojette sinogram geometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.SinoPar" href="#MIRT.SinoPar"><code>MIRT.SinoPar</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SinoPar</code> 2D parallel-beam sinogram geometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/8a318a14e88d776ce1da807a8b2b0487a74417a8/src/fbp/sino_geom.jl#L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/1-mirt/">« MIRT overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 11 August 2022 22:44">Thursday 11 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
