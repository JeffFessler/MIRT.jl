<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · MIRT.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MIRT.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MIRT.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../toc/">Table of Contents</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/1-mirt/">MIRT overview</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JeffFessler/MIRT.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="function_reference"><a class="docs-heading-anchor" href="#function_reference">Function References</a><a id="function_reference-1"></a><a class="docs-heading-anchor-permalink" href="#function_reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MIRT.Afft-Union{Tuple{AbstractArray{Bool, D}}, Tuple{S}, Tuple{D}} where {D, S&lt;:Number}" href="#MIRT.Afft-Union{Tuple{AbstractArray{Bool, D}}, Tuple{S}, Tuple{D}} where {D, S&lt;:Number}"><code>MIRT.Afft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A = Afft(samp::AbstractArray{Bool} ; T::DataType = ComplexF32)</code></pre><p>Make a LinearMapAO object for (under-sampled) FFT, of type <code>T</code>, using given sampling pattern <code>samp</code>. Especially for compressed sensing MRI with Cartesian sampling.</p><p>Option:</p><ul><li><code>operator::Bool = true</code> set to <code>false</code> to return a <code>LinearMapAM</code></li><li><code>work::AbstractArray</code> work space for in-place fft operations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/system/Afft.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}" href="#MIRT.Anufft-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.Anufft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Anufft(ω, N ; kwargs ...)</code></pre><p>Make a <code>LinearMapAO</code> object of size <code>length(ω) × prod(N)</code>. See <code>nufft_init</code> for options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/nufft.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}" href="#MIRT.Aodwt-Tuple{Tuple{Vararg{Int64, N}} where N}"><code>MIRT.Aodwt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A, levels, mfun = Aodwt(dims ; level::Int=3, wt=wavelet(WT.haar))</code></pre><p>Create orthogonal discrete wavelet transform (ODWT) <code>LinearMapAA</code></p><p>in</p><ul><li><code>dims::Dims</code> tuple of dimensions</li></ul><p>option</p><ul><li><code>level::Int</code> # of levels; default 3</li><li><code>wt</code> wavelet transform type (see <code>Wavelets</code> package); default Haar</li><li><code>operator::Bool=true</code> default to <code>LinearMapAO</code></li><li><code>T::DataType</code> : <code>Float32</code> by default; use <code>ComplexF32</code> if needed</li></ul><p>out</p><ul><li><code>A</code> a <code>LinearMapAX</code> object</li><li><code>scales</code> array of size <code>dims</code> showing the scale of each coefficient</li></ul><p>which is useful when imposing scale-dependent regularization</p><ul><li><code>mfun</code> convenience function for A*X when X is a Matrix or Array (not vector)</li></ul><p>2019-02-23 Jeff Fessler, University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/Aodwt.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.caller_name-Tuple{}" href="#MIRT.caller_name-Tuple{}"><code>MIRT.caller_name</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>caller_name() or caller_name(;level=4)</code></p><p>Return &quot;filename line fun():&quot; as a string to describe where this function was called.</p><p>Stack levels:</p><ul><li>1: #caller_name</li><li>2: caller_name()</li><li>3: function that invoked caller()</li><li>4: the calling function we want to return</li></ul><p>Hence the default level is 4, but we increment it by one in case user says <code>@show caller_name()</code> in which case stack[3] is a macro expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/io/caller_name.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT.diff_adj-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.diff_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Z = diff_adj(dx, N::Dims{D} ; dims = 1:D)</code></pre><p>Adjoint of finite differences of arrays along one or more dimensions. By default performs the same operations as <span>$vec(Z) = [(I_{N_d} \otimes \cdots \otimes D_{N_1}); \dots; (D_{N_d} \otimes \cdots \otimes I_{N_1})]&#39; * d$</span> where <code>D_N</code> denotes the <code>N-1 × N</code> 1D finite difference matrix and <code>⊗</code> denotes the Kronecker product, but does it efficiently without using <code>spdiagm</code> (or any <code>SparseArrays</code> function).</p><p>in</p><ul><li><code>dx</code> vector of typical length <code>N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1</code></li><li><code>N::Dims</code> desired output size</li></ul><p>option</p><ul><li><code>dims</code> dimension(s) for performing adjoint finite differences; default <code>1:ndims(X)</code></li></ul><p>out</p><ul><li><code>Z</code> <code>N_1 × ... × N_d</code> array by default</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffs.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D" href="#MIRT.diff_forw-Union{Tuple{AbstractArray{&lt;:Number, D}}, Tuple{D}} where D"><code>MIRT.diff_forw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = diff_forw(X ; dims = 1:ndims(X))</code></pre><p>Finite differences along one or more dimensions of an array, e.g., for anisotropic TV regularization.</p><p>By default performs the same operations as <span>$d = [(I_{N_d} \otimes \cdots \otimes D_{N_1}); \dots; (D_{N_d} \otimes \cdots \otimes I_{N_1})] vec(X)$</span> where <span>$D_N$</span> denotes the <code>N-1 × N</code> 1D finite difference matrix and <code>⊗</code> denotes the Kronecker product, but does it efficiently without using <code>spdiagm</code> (or any <code>SparseArrays</code> function).</p><p>Input dimension <code>N</code> must exceed <code>1</code> for each dimension specified by <code>dims</code>.</p><p>in</p><ul><li><code>X</code> <code>N_1 × ... × N_d</code> array (typically an N-D image).</li></ul><p>option</p><ul><li><code>dims</code> dimension(s) for performing finite differences; default <code>1:ndims(X)</code></li></ul><p>must have unique elements and be a nonempty subset of <code>1:ndims(X)</code></p><p>out</p><ul><li><code>d</code> vector of default length <code>N_d*...*(N_1-1) + ... + (N_d-1)*...*N_1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffs.jl#L35-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D" href="#MIRT.diff_map-Union{Tuple{Tuple{Vararg{Int64, D}}}, Tuple{D}} where D"><code>MIRT.diff_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = diff_map(N::Dims{D} ; dims = 1:D)</code></pre><p>in</p><ul><li><code>N::Dims</code> image size</li></ul><p>out</p><ul><li><code>T</code> <code>LinearMapAA</code> object for computing finite differences via <code>T*x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffs.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}" href="#MIRT.diffl!-Union{Tuple{Nx}, Tuple{Ng}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, Ng}, AbstractArray{Tx, Nx}, AbstractVector{Int64}}} where {Tg, Tx, Ng, Nx}"><code>MIRT.diffl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl!(g::AbstractArray, x::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>When <code>x</code> is a <code>N</code>-dimensional array, the <code>i</code>th slice of the <code>g</code> array (along its last dimension) is the <code>diffl!</code> of <code>x</code> along <code>dims[i]</code>. This is useful for total variation (TV) and other regularizers that need finite differences along multiple dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}" href="#MIRT.diffl!-Union{Tuple{N}, Tuple{Tx}, Tuple{Tg}, Tuple{AbstractArray{Tg, N}, AbstractArray{Tx, N}, Int64}} where {Tg, Tx, N}"><code>MIRT.diffl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl!(g::AbstractArray, x::AbstractArray, dim::Int ; ...)</code></pre><p>Apply left finite difference operator to input array <code>x</code>, storing the result &quot;in-place&quot; in pre-allocated output array <code>g</code>. (The letter <code>g</code> is mnemonic for &quot;gradient&quot;.)</p><p>Arrays <code>g</code> and <code>x</code> must have the same size, and cannot alias. By default, the &quot;first&quot; elements of <code>g</code> are zero for dimension <code>dim</code>. The default is <code>dim=1</code>.</p><p>Option:</p><ul><li><code>add::Bool = false</code> use <code>x[i] + x[i-1]</code> instead of <code>x[i] - x[i-1]</code> (useful for certain diagonal majorizers).</li><li><code>edge::Symbol = :zero</code> set the first elements of dimension <code>dim</code> to 0<ul><li>Choose <code>edge=:circ</code> to use circulant (aka periodic) boundary conditions.</li><li>Choose <code>edge=:none</code> to leave the first elements untouched.</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [2, 6, 7]; g = similar(x); diffl!(g, x)
3-element Vector{Int64}:
 0
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}" href="#MIRT.diffl-Tuple{AbstractArray, AbstractVector{Int64}}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Allocating version of <code>diffl!</code> for <code>dims</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray, Int64}" href="#MIRT.diffl-Tuple{AbstractArray, Int64}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray, dim::Int ; ...)</code></pre><p>Allocating version of <code>diffl!</code> along <code>dim</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1,2] .+ [10 30 70]; g = diffl(x, 2)
2×3 Matrix{Int64}:
 0  20  40
 0  20  40</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl-Tuple{AbstractArray}" href="#MIRT.diffl-Tuple{AbstractArray}"><code>MIRT.diffl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = diffl(x::AbstractArray ; ...)</code></pre><p>Allocating version of <code>diffl!</code> along <code>dim=1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}" href="#MIRT.diffl_adj!-Union{Tuple{Ng}, Tuple{Nz}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, Nz}, AbstractArray{Tg, Ng}, AbstractVector{Int64}}} where {Tz, Tg, Nz, Ng}"><code>MIRT.diffl_adj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl_adj!(z::AbstractArray, g::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Adjoint of <code>diffl!</code> for multiple dimensions <code>dims</code>. Here <code>g</code> must have one more dimension than <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}" href="#MIRT.diffl_adj!-Union{Tuple{N}, Tuple{Tg}, Tuple{Tz}, Tuple{AbstractArray{Tz, N}, AbstractArray{Tg, N}, Int64}} where {Tz, Tg, N}"><code>MIRT.diffl_adj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffl_adj!(z, g, dim::Int ; ...)</code></pre><p>Adjoint of left finite difference <code>diffl!</code>, in-place. Arrays <code>z</code> and <code>g</code> must be same size. See <code>diffl_adj</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj-Tuple{AbstractArray, Int64}" href="#MIRT.diffl_adj-Tuple{AbstractArray, Int64}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray, dim::Int ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> along <code>dim</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = ones(Int,2,3); z = diffl_adj(g, 2)
2×3 Matrix{Int64}:
 -1  0  1
 -1  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj-Tuple{AbstractArray}" href="#MIRT.diffl_adj-Tuple{AbstractArray}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> along <code>dim=1</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = [0, 2, 5]; z = diffl_adj(g)
3-element Vector{Int64}:
 -2
 -3
  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L227-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}" href="#MIRT.diffl_adj-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractVector{Int64}}} where {T, N}"><code>MIRT.diffl_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = diffl_adj(g::AbstractArray, dims::AbstractVector{Int} ; ...)</code></pre><p>Allocating version of <code>diffl_adj!</code> for <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L261-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D" href="#MIRT.diffl_map-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, AbstractVector{Int64}}} where D"><code>MIRT.diffl_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = diffl_map(N::Dims{D}, dims::AbstractVector{Int} ; kwargs...)
T = diffl_map(N::Dims{D}, dim::Int ; kwargs...)</code></pre><p>in</p><ul><li><code>N::Dims</code> image size</li></ul><p>options: see <code>diffl!</code></p><ul><li><code>T::Type</code> for <code>LinearMapAA</code>, default <code>Float32</code></li><li><code>operator::Bool = true</code> use <code>false</code> for <code>LinearMapAM</code></li></ul><p>out</p><ul><li><code>T</code> <code>LinearMapAA</code> object for computing finite differences via <code>T*x</code></li></ul><p>using <code>diffl!</code> and <code>diffl_adj!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/regularize/diffl.jl#L277-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}" href="#MIRT.downsample1-Tuple{AbstractVector{&lt;:Number}, Int64}"><code>MIRT.downsample1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample1(x, down ; warn=true)</code></pre><p>downsample 1D vector by factor <code>down</code></p><p>in</p><ul><li><code>x [n1]</code></li><li><code>down::Int</code> downsampling factor</li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default <code>isinteractive()</code></li></ul><p>out</p><ul><li><code>y [n1/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/downsample.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}" href="#MIRT.downsample2-Tuple{AbstractMatrix{&lt;:Number}, Tuple{Int64, Int64}}"><code>MIRT.downsample2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample2(x, down ; warn=true, T)</code></pre><p>downsample by averaging by integer factors in</p><ul><li><code>x [nx ny]</code></li><li><code>down</code> can be a scalar (same factor for both dimensions) or a <code>NTuple{2,Int}</code></li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default <code>isinteractive()</code></li><li><code>T::DataType</code> specify output eltype; default <code>eltype(x[1] / down[1])</code></li></ul><p>out</p><ul><li><code>y [nx/down ny/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/downsample.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}" href="#MIRT.downsample3-Tuple{AbstractArray{&lt;:Number, 3}, Tuple{Int64, Int64, Int64}}"><code>MIRT.downsample3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample3(x, down ; warn=true, T)</code></pre><p>downsample by averaging by integer factors in</p><ul><li><code>x [nx ny nz]</code></li><li><code>down</code> can be a scalar (same factor for all dimensions) or a <code>NTuple{3,Int}</code></li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if noninteger multiple; default true</li><li><code>T::DataType</code> specify output eltype; default <code>eltype(x[1] / down[1])</code></li></ul><p>out</p><ul><li><code>y [nx/down ny/down nz/down]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/downsample.jl#L141-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}" href="#MIRT.downsample_dim1-Tuple{AbstractArray{&lt;:Number}, Int64}"><code>MIRT.downsample_dim1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = downsample_dim1(x, down ; warn::Bool)</code></pre><p>Down-sample <code>x</code> by factor <code>down</code> along first dimension by averaging.</p><p>in</p><ul><li><code>x [n1 (Nd)]</code></li><li><code>down::Int</code> downsampling factor</li></ul><p>option</p><ul><li><code>warn::Bool</code> warn if non-integer multiple; default <code>isinteractive()</code></li></ul><p>out</p><ul><li><code>y [n1÷down (Nd)]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/downsample.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}" href="#MIRT.dtft-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Number}}"><code>MIRT.dtft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X = dtft(w, x ; n_shift=?)</code></pre><p>multi-dimensional DTFT (DSFT)</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m,:] (n - n_{shift})), m=1,…,M$</span> where here <code>n</code> is a <code>CartesianIndex</code></p><p>in</p><ul><li><code>w::AbstractMatrix{&lt;:Real}</code>	<code>[M,D]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>x::AbstractArray{&lt;:Number}</code>	<code>[(Nd)]</code> D-dimensional signal</li></ul><p>option</p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is N/2; default zeros(D)</li></ul><p>out</p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/dtft.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}" href="#MIRT.dtft-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}}"><code>MIRT.dtft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X = dtft(w, x ; n_shift=?)</code></pre><p>1D DTFT</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m] (n - n_{shift})), m=1,…,M$</span></p><p>in</p><ul><li><code>w::AbstractVector{&lt;:Real}</code>	<code>[M]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>x::AbstractVector{&lt;:Number}</code>	<code>[N]</code> 1D signal</li></ul><p>option</p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li></ul><p>out</p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/dtft.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.dtft_adj-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Number}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = dtft_adj(w, X, N ; n_shift=?)</code></pre><p>adjoint for multi-dimensional DTFT (DSFT)</p><p><span>$x[n] = \sum_{m=1}^M X[m] \exp(i w[m,:] (n - n_{shift})), n=0,…,N-1$</span> where here <code>n</code> is a <code>CartesianIndex</code></p><p>in</p><ul><li><code>X::AbstractVector{ComplexF64}</code> <code>[M]</code> DTFT</li><li><code>w::AbstractMatrix{&lt;:Real}</code> <code>[M,D]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Dims</code>	<code>[D]</code> dimensions of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is <code>N/2</code>; default <code>zeros(D)</code></li><li><code>T::DataType</code> default <code>(eltype(w) == Float64) ? ComplexF64 : ComplexF32</code></li></ul><p>out</p><ul><li><code>x::AbstractArray{&lt;:Number}</code> <code>[(N)]</code> <code>D</code>-dimensional signal</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/dtft.jl#L172-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}" href="#MIRT.dtft_adj-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Int64}"><code>MIRT.dtft_adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = dtft_adj(w, X, N ; n_shift=?)</code></pre><p>adjoint for 1D DTFT</p><p><span>$x[n] = \sum_{m=1}^M X[m] \exp(i w[m] (n - n_{shift})), n=0,…,N-1$</span></p><p>This is the <em>adjoint</em> (transpose) of <code>dtft</code>, not an <em>inverse</em> DTFT.</p><p>in</p><ul><li><code>w::AbstractVector{&lt;:Real}</code>	<code>[M]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>X::AbstractVector{ComplexF64}</code>	<code>[M]</code> spectrum values</li><li><code>N::Int</code> size of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>T::DataType</code> output data type; default <code>ComplexF64</code></li></ul><p>out</p><ul><li><code>x::AbstractVector{&lt;:Number}</code>	signal [N]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/dtft.jl#L137-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.dtft_init-Tuple{AbstractMatrix{&lt;:Real}, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.dtft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = dtft_init(w, N ; n_shift=?)</code></pre><p>for multi-dimensional DTFT (DSFT)</p><p>in</p><ul><li><code>w::AbstractMatrix{&lt;:Real}</code>	<code>[M,D]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Dims</code> <code>[D]</code> dimensions of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::AbstractVector{&lt;:Real}</code> often is N/2; default zeros(D)</li><li><code>T::DataType</code> default <code>ComplexF64</code> for testing NUFFT accuracy</li></ul><p>out</p><ul><li><code>d::NamedTuple</code> with fields</li></ul><pre><code class="nohighlight hljs">`dtft = x -&gt; dtft(x), adjoint = y -&gt; dtft_adj(y), A=LinearMapAO`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/dtft.jl#L101-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}" href="#MIRT.dtft_init-Tuple{AbstractVector{&lt;:Real}, Int64}"><code>MIRT.dtft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = dtft_init(w, N ; n_shift=?)</code></pre><p>for 1D DTFT</p><p>in</p><ul><li><code>w::AbstractVector{&lt;:Real}</code>	<code>[M]</code> frequency locations (&quot;units&quot; radians/sample)</li><li><code>N::Int</code> size of signal <code>x</code></li></ul><p>option</p><ul><li><code>n_shift::Real</code> often is N/2; default 0</li><li><code>T::DataType</code> default <code>ComplexF64</code> for testing NUFFT accuracy</li></ul><p>out</p><ul><li><code>d::NamedTuple</code> with fields</li></ul><pre><code class="nohighlight hljs">`dtft = x -&gt; dtft(x), adjoint = y -&gt; dtft_adj(y), A=LinearMapAO`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/dtft.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}" href="#MIRT.embed!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractVector{&lt;:Number}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(array, v, mask ; filler=0)</code></pre><p>embed vector <code>v</code> of length <code>sum(mask)</code> into elements of <code>array</code> where <code>mask</code> is <code>true</code>, setting the remaining elements to <code>filler</code> (default 0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}" href="#MIRT.embed-Tuple{AbstractMatrix{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array = embed(matrix::AbstractMatrix{&lt;:Number}, mask::AbstractArray{Bool})</code></pre><p>Embed each column of <code>matrix</code> into <code>mask</code> then <code>cat</code> along next dimension In:</p><ul><li><code>matrix [sum(mask) L]</code></li><li><code>mask [(N)]</code></li></ul><p>Out:</p><ul><li><code>array [(N) L]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L85-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number" href="#MIRT.embed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T&lt;:Number"><code>MIRT.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array = embed(v, mask ; filler=0)</code></pre><p>embed vector <code>v</code> of length <code>sum(mask)</code> into elements of an array where <code>mask</code> is <code>true</code>; see <code>embed!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.eql_root-Tuple{Real, Real, Real}" href="#MIRT.eql_root-Tuple{Real, Real, Real}"><code>MIRT.eql_root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = eql_root(a,b,c)
Numerically stable method for computing the positive root
of the quadratic polynomial `-ax^2 - 2bx + c, a &gt;= 0`.
Assumes solvable equations; will throw otherwise.</code></pre><p>in</p><ul><li><code>a</code> : The negative of the <code>x^2</code> term. Must be positive.</li><li><code>b</code> : Half the negative of the <code>x</code> term.</li><li><code>c</code> : The constant term.</li></ul><p>out</p><ul><li><code>x</code> : The positive root that satisfies <code>0 = -ax^2 - 2bx + c</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/eql_root.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#MIRT.exp_mult-Tuple{Any, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>MIRT.exp_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">D = exp_mult(A, u, v ; warnboth)</code></pre><p>Memory efficient and fast implementation of <code>D = A&#39; * exp(-u * v^T)</code> that is useful for B0-field-corrected MRI image reconstruction.</p><p>in:</p><ul><li><code>A [N L]</code> matrix</li><li><code>u [N]</code> vector</li><li><code>v [M]</code> vector</li><li><code>warnboth</code> warn if both <code>u</code> and <code>v</code> are complex; default: true</li></ul><p>out:</p><ul><li><code>D [L M]</code> complex vector: <code>D = A&#39; * exp(-u * v^T)</code></li></ul><p><code>D_lm = sum_n A_nl^* exp(-u_n v_m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/exp_mult.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}" href="#MIRT.exp_xform-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>MIRT.exp_xform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp_xform(x, u, v ; mode::Symbol = :matrix)</code></pre><p>in:</p><ul><li><code>x [N L]</code> possibly complex vector(s)</li><li><code>u [D N]</code> possibly complex vectors</li><li><code>v [D M]</code> possibly complex vectors</li><li><code>mode::Symbol</code> <code>:matrix</code> (default) | <code>:element</code> | <code>:row</code> | <code>:column</code></li></ul><p>out:</p><ul><li><code>y [M L]</code> typically complex vector</li></ul><p><code>y[m,l] = sum_n x[n,l] exp(-sum(u[:,n] .* v[:,m]))</code></p><p>Iterates through subsets of the ML matrix designated by <code>:mode</code> (i.e. row, column, element, or just computing the entire matrix) This is the &#39;slow&#39; &#39;exact&#39; transform model for MRI.</p><p>Output type will depend on input types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/exp_xform.jl#L14-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.genkspace-NTuple{8, Any}" href="#MIRT.genkspace-NTuple{8, Any}"><code>MIRT.genkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genkspace</code></pre><p>Generate the proper length of k-space trajectory.</p><p>It linearly interpolates the output of <code>genspiral</code> to the correct <code>length()</code> &amp; takes care of the rotations for the interleaves.</p><ul><li><code>ld</code> is the length of the data</li><li><code>nint</code> is the number of interleaves</li></ul><p>Brad Sutton; University of Michigan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/kspace-spiral.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.genspi-Tuple{Any, Any}" href="#MIRT.genspi-Tuple{Any, Any}"><code>MIRT.genspi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gx, Gy, kx, ky, sx, sy, gts = genspi(...)</code></pre><p>This is translation of C code from scanner: exactly what is played out to gradients at 4us.</p><p>multi-shot spiral design uses Duyn&#39;s approximate slewrate limited design augmented with archimedian <code>gmax</code> limit in [args]</p><ul><li><p><code>D</code> = FOV; cm</p></li><li><p><code>N</code> = matrix size()</p></li><li><p><code>Tmax</code> = longest acquisition allowed; s</p></li><li><p><code>dts</code> = output sample spacing; s</p></li><li><p><code>gtype</code> = trajectory type()</p></li></ul><p>option [CVs]</p><ul><li><code>nl</code> = number of interleaves</li><li><code>gamp</code> = design grad max; G/cm</li><li><code>gslew</code> = design slew rate; mT/m/ms</li><li><code>nramp</code> = number of rampdown points; default 0</li></ul><p>out</p><ul><li><code>Gx; Gy</code></li></ul><p>time is in sec()</p><ul><li>rev 0 12/26/98	original</li><li>rev 1 4/15/99	little better calc of ts</li></ul><p>Borrowed from Doug Noll; Univ. of Michigan. Modified to take more input cv&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/kspace-spiral.jl#L155-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}" href="#MIRT.getindex!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, D}, AbstractArray{Bool, D}}} where {T, D}"><code>MIRT.getindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex!(y::AbstractVector, x::AbstractArray{T,D}, mask::AbstractArray{Bool,D})</code></pre><p>Equivalent to the in-place <code>y .= x[mask]</code> but is non-allocating.</p><p>For non-Boolean indexing, just use <code>@views y .= A[index]</code>, per https://discourse.julialang.org/t/efficient-non-allocating-in-place-getindex-for-bitarray/42268</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}" href="#MIRT.interp1-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Number}, Any}"><code>MIRT.interp1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yi = interp1(x, y, xi ; how=Gridded(Linear()), extrap=0)</code></pre><p>1D interpolation of <code>y = f(x)</code> at points <code>xi</code></p><p>In:</p><ul><li><code>x::AbstractVector{&lt;:Real}</code></li><li><code>y::AbstractVector{&lt;:Number}</code></li></ul><p>Option:</p><ul><li><code>how::Interpolations.InterpolationType</code> default <code>Gridded(Linear())</code></li><li><code>extrap::Any</code> how to extrapolate, e.g., <code>Flat()</code>; default <code>0</code></li></ul><p>other options from Interpolations.jl are <code>Line()</code> <code>Periodic()</code> <code>Reflect()</code> <code>Throw()</code></p><p>Output is same size as input <code>xi</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/interp1.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_dump-Tuple{Any}" href="#MIRT.ir_dump-Tuple{Any}"><code>MIRT.ir_dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_dump(x::Any ; io::IO = stdout)
ir_dump(io::IO, x::Any)</code></pre><p>Show all the fields of a structure or <code>NamedTuple</code> more nicely than dump() does</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/io/ir_dump.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_load_brainweb_t1_256-Tuple{}" href="#MIRT.ir_load_brainweb_t1_256-Tuple{}"><code>MIRT.ir_load_brainweb_t1_256</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data = ir_load_brainweb_t1_256()</code></pre><p>Load brainweb T1-weighted MRI slice of size <code>256 × 256</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/data/loaders.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}" href="#MIRT.ir_mri_coil_compress-Tuple{AbstractArray{&lt;:Number}}"><code>MIRT.ir_mri_coil_compress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(odata, σ, Vr) = ir_mri_coil_compress(idata ; ncoil)</code></pre><p>MRI coil compression via PCA. Given multiple MRI surface coil images (idata), use SVD/PCA to find a smaller number of virtual coil images (odata).</p><p>In:</p><ul><li><code>idata</code> <code>[(N) n_in]</code>: noisy complex images (2D or 3D) for each coil</li></ul><p>Option:</p><ul><li><code>ncoil</code> Desired # of virtual coils (default: 1)</li></ul><p>Out:</p><ul><li><code>odata</code> <code>[(N) ncoil]</code>: virtual coil images</li><li><code>σ</code>     <code>[n_in]</code>: singular values.</li><li><code>Vr</code>    <code>[n_in, ncoil]</code>: compression matrix for reducing other data.</li></ul><p>todo: currently ignores noise correlations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/coil_compress.jl#L15-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_kspace_ga_radial-Tuple{}" href="#MIRT.ir_mri_kspace_ga_radial-Tuple{}"><code>MIRT.ir_mri_kspace_ga_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace = ir_mri_kspace_ga_radial(; Nro=?, Nspoke=?, ...)</code></pre><p>Generate k-space sampling pattern for &quot;golden angle&quot; radial sampling.</p><p>option</p><ul><li><code>Nro:Int</code>		number of samples in each readout/spoke, default 256</li><li><code>Nspoke::Int</code>	number of spokes, default 1</li><li><code>start::Real</code>	first angle in series [radians], default π/2</li><li><code>angle::Real</code>	angular spacing [radians], default GA</li><li><code>delta_ro::Real</code>	readout spacing, default <code>1/Nro</code></li><li><code>shift::Real</code>		shift due to gradient delays, default 0<ul><li>radial sample locations are <code>ir * delta_ro</code></li><li>where <code>ir = [-(Nro/2 - 1):1:Nro/2] + shift</code></li></ul></li></ul><p>out</p><ul><li><code>kspace</code>	<code>[Nro Nspoke 2]</code> (Float32)</li></ul><p><code>kx</code> and <code>ky</code> k-space locations for <code>Nspoke*Nro</code> samples in interval <code>(-0.5 0.5]</code> for default <code>shift</code>, <code>delta_ro</code> so default units are &quot;cycles / sample&quot;</p><p>2015-07 Mai Le, original Matlab version</p><p>2015-07-04 Jeff Fessler, minor changes to Matlab version</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/kspace.jl#L10-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{Symbol}" href="#MIRT.ir_mri_sensemap_sim-Tuple{Symbol}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap,info) = ir_mri_sensemap_sim( :all ; kwargs)</code></pre><p>Like <code>ir_mri_sensemap_sim</code> but also returns <code>info</code> with data for all coils, mainly for testing and plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/sensemap-sim.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}" href="#MIRT.ir_mri_sensemap_sim-Tuple{Vector{Tuple{Int64, Int64}}}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap,info) = ir_mri_sensemap_sim( ir_ic_pair ; kwargs)</code></pre><p>Like <code>ir_mri_sensemap_sim</code> but also returns <code>info</code> with data for specific coils where <code>ir_ic_pair::Vector{Tuple{Int,Int}}</code>. (Usually used internally only.)</p><ul><li><code>info::NamedTuple</code> geometry information for plots</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/sensemap-sim.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim-Tuple{}" href="#MIRT.ir_mri_sensemap_sim-Tuple{}"><code>MIRT.ir_mri_sensemap_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smap = ir_mri_sensemap_sim(...)</code></pre><p>Simulate 2D or 3D sensitivity maps for sensitivity-encoded MRI based on grivich:00:tmf http://doi.org/10.1119/1.19461</p><p>This code makes maps for multiple coils, but does not model coupling between coils, so most likely it is an approximation at best.</p><p>option</p><ul><li><code>dims::Dims</code>		image size; default (64, 64)</li><li><code>dx::Real</code>		pixel/voxel dimension; default: 3</li><li><code>dy::Real</code>		pixel/voxel dimension; default: <code>dx</code></li><li><code>dz::Real</code>		&quot;&quot;</li><li><code>ncoil::Int</code>		# of coils total; default 4</li><li><code>nring::Int</code>		# of rings of coils; default 1</li><li><code>rcoil::Real</code>		coil radius; default <code>dx * nx / 2 * 0.50</code></li><li><code>dz_coil</code>			ring spacing in z; default <code>nz*dz/nring</code><ul><li>(3D geometry is a cylinder)</li></ul></li><li><code>coil_distance::Real</code>		distance of coil center from isocenter<ul><li>for central ring of coils as a multiple of <code>FOVx</code>,</li><li>where <code>FOVx=nx*dx</code>; default 1.2</li></ul></li><li><code>orbit::Real</code>			default 360 [degrees]</li><li><code>orbit_start::AbstractVector{&lt;:Real} = fill(0, nring)</code> [degrees]</li><li><code>scale::Symbol</code><ul><li><code>:none</code> (default)</li></ul>+	<code>ssos_center</code> make SSoS of center = 1</li></ul><p>out</p><ul><li><code>smap	[dims ncoil]</code>	simulated sensitivity maps (complex!)</li></ul><p>All length parameters must have same units (e.g., mm or cm)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/sensemap-sim.jl#L21-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}" href="#MIRT.ir_mri_sensemap_sim_do-NTuple{14, Any}"><code>MIRT.ir_mri_sensemap_sim_do</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(smap, info) = ir_mri_sensemap_sim_do()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/sensemap-sim.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_smap1-NTuple{4, Any}" href="#MIRT.ir_mri_smap1-NTuple{4, Any}"><code>MIRT.ir_mri_smap1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_mri_smap1()</code></pre><p>based on grivich:00:tmf</p><p>for a circular coil in &quot;x-y plane&quot; of radius &quot;a&quot;</p><p>Note that coil x-y plane is not same as object x-y plane!</p><p>Returns <code>(i,j,k)</code> components of B vector for each <code>(x,y,z)</code> location</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/sensemap-sim.jl#L239-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ir_mri_smap_r-Tuple{Any, Any}" href="#MIRT.ir_mri_smap_r-Tuple{Any, Any}"><code>MIRT.ir_mri_smap_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir_mri_smap_r(r, z)</code></pre><p>function for testing near 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/sensemap-sim.jl#L227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.jinc-Tuple{Real}" href="#MIRT.jinc-Tuple{Real}"><code>MIRT.jinc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jinc(x)</code></pre><p>Return <code>jinc(x) = J1(pi*x)/(2x)</code>, where <code>J1</code> is a Bessel function of the first kind.</p><p>Units of <code>x</code> are typically cycles/m.</p><p>Return type is <code>promote_type(typeof(x), Float32)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/jinc.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}" href="#MIRT.map_many-Tuple{Function, AbstractArray, Tuple{Vararg{Int64, N}} where N}"><code>MIRT.map_many</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = map_many(fun::Function, x::AbstractArray{&lt;:Any}, idim::Dims)</code></pre><p>apply a function <code>fun</code> to leading slices of input <code>x</code>; cousin of <code>mapslices</code></p><p>in</p><ul><li><code>fun::Function</code> maps input of size <code>idim</code> to output of some size <code>odim</code></li><li><code>x [idim ldim]</code></li></ul><p>out</p><ul><li><code>y [odim ldim]</code></li></ul><p>Example: if <code>fun</code> maps array of size (1,2) to array of size (3,4,5) and if input <code>x</code> has size (1,2,7,8) then output <code>y</code> will have size (3,4,5,7,8) where <code>y[:,:,:,i,j] = fun(x[:,:,i,j])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/map_many.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mask_or-Tuple{AbstractMatrix{Bool}}" href="#MIRT.mask_or-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_or</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask_or(mask)</code></pre><p>compress 3D mask to 2D by logical <code>or</code> along <code>z</code> direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}" href="#MIRT.mask_outline-Tuple{AbstractMatrix{Bool}}"><code>MIRT.mask_outline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask_outline(mask)</code></pre><p>return outer boundary of 2D mask (or mask_or for 3D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}" href="#MIRT.maskit-Tuple{AbstractArray{&lt;:Number}, AbstractArray{Bool}}"><code>MIRT.maskit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maskit(x::AbstractArray{&lt;:Number})</code></pre><p>opposite of embed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/mask.jl#L123-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.max_percent_diff-Tuple{Any, Any}" href="#MIRT.max_percent_diff-Tuple{Any, Any}"><code>MIRT.max_percent_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = max_percent_diff(s1, s2, [options])</code></pre><p>Compute the &quot;maximum percent difference&quot; between two signals: <code>s1, s2</code>.</p><p>Default is to normalize by <code>maximum(abs.(s1))</code>.</p><p>options</p><ul><li><code>maxboth::Bool</code> use max of both arguments to normalize; default <code>false</code></li><li><code>normalize::Bool</code> normalize each before comparing; default <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/max_percent_diff.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_kspace_spiral-Tuple{}" href="#MIRT.mri_kspace_spiral-Tuple{}"><code>MIRT.mri_kspace_spiral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace, omega, gradxy = mri_kspace_spiral( [options] )</code></pre><p>Make k-space spiral trajectory based on GE 3T scanner constraints</p><p>Option:</p><ul><li><code>N</code> dimention of reconstructed image</li><li><code>Nt</code> # of time points</li><li><code>fov</code> field of view in cm</li><li><code>dt</code> time sampling interval out; default <code>5e-6</code> sec</li><li><code>gamp::Real</code> design gradient amplitude max, G/cm; default 2.2</li><li><code>gslew::Int</code> design slew rate, mT/m/ms; default 180</li></ul><p>Out:</p><ul><li><code>kspace [Nt,2]</code> kspace trajectory <code>[kx ky]</code> in cycles/cm, NO: cycles/FOV</li><li><code>omega [Nt,2]</code> &quot;&quot; in radians</li><li><code>gradxy [Nt 2]</code> gradient waveforms in (units?)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/kspace-spiral.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D" href="#MIRT.mri_trajectory-Union{Tuple{}, Tuple{D}} where D"><code>MIRT.mri_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace, omega, wi = mri_trajectory( ; ktype, N, fov, arg_wi, kwargs...)</code></pre><p>Generate kspace trajectory samples and density compensation functions.</p><p>option</p><ul><li><code>ktype::Symbol</code> k-space trajectory type; default <code>:radial</code></li><li><code>N::Dims</code> target image size; default (32,30)</li><li><code>fov</code> field of view in x and y (and z); default (250,250) mm</li><li><code>arg_wi</code> options to pass to <code>ir_mri_density_comp</code> - not yet done</li><li><code>kwargs</code> options for the specific trajectory</li></ul><p>out</p><ul><li><code>kspace [Nk 2|3]</code> kspace samples in units 1/fov</li><li><code>omega [Nk 2|3]</code> trajectory samples over [-π,π)</li><li><code>wi [Nk 1]</code> (optional) density compensation factors</li></ul><p>trajectory types: <code>:cartesian</code> <code>:radial</code> <code>:cart_y_2</code> <code>:random</code> <code>:half8</code> <code>:epi_sin</code> <code>:spiral0 :spiral1 :spiral3</code> <code>:rosette3</code> <code>:epi_under</code> <code>:gads</code> (emulate golden-angle data sharing per winkelmann:07:aor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/mri_trajectory.jl#L15-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring" href="#MIRT.mri_trajectory_gads-Union{Tuple{Nring}, Tuple{Tuple{Vararg{Int64, N}} where N, Any}} where Nring"><code>MIRT.mri_trajectory_gads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">omega, wi = mri_trajectory_gads(N, fov ; ...)</code></pre><p>emulate 2D golden angle radial sampling with data sharing</p><p>option: <code>Nro</code> # of samples in each readout/spoke <code>shift</code> shift along read-out due to gradient delays (stress) <code>kmax_frac</code> fractions of maximum krad (0.5) for rings (annuli) <code>under</code> under-sampling factor for each annulus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/mri_trajectory.jl#L210-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}" href="#MIRT.mri_trajectory_radial-Tuple{Tuple{Vararg{Int64, N}} where N, Any}"><code>MIRT.mri_trajectory_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_trajectory_radial()</code></pre><p>option:</p><ul><li><code>na_nr</code> default ensures proper sampling at edge of k-space</li><li><code>na</code> angular spokes; default: na_nr * nr</li><li><code>nr</code> radial samples per spoke</li><li><code>ir</code> default: <code>0:nr</code></li></ul><p>todo: generalize to 3D using barger:02:trc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/mri_trajectory.jl#L258-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.mri_trajectory_rosette3-Tuple{Any, Any}" href="#MIRT.mri_trajectory_rosette3-Tuple{Any, Any}"><code>MIRT.mri_trajectory_rosette3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mri_trajectory_rosette3(N, fov ; ...)</code></pre><p>3d rosette, with default parameters from bucholz:08:miw</p><p>options: omax: maximum omega nt : time samples (65.536 ms for 4 usec dt) dt : time sample spacing (4 usec) ti : time samples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/mri_trajectory.jl#L295-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}" href="#MIRT.ncg-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(x,out) = ncg(B, gradf, curvf, x0 ; ...)</code></p><p>Nonlinear preconditioned conjugate gradient algorithm to minimize a general &quot;inverse problem&quot; cost function of the form <span>$\Psi(x) = \sum_{j=1}^J f_j(B_j x)$</span> where each function <span>$f_j(v)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(v;u) = f_j(u) + \nabla f_j(u) (v - u) + 1/2 \|v - u\|^2_{C_j(u)}\]</p><p>where <span>$C_j(u)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>This CG method uses a majorize-minimize (MM) line search.</p><p>in</p><ul><li><code>B</code>		array of <span>$J$</span> blocks <span>$B_1,...,B_J$</span></li><li><code>gradf</code>	array of <span>$J$</span> functions return gradients of <span>$f_1,...,f_J$</span></li><li><code>curvf</code>	array of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar</li></ul><p>or a vector of curvature values for each element of <span>$z$</span></p><ul><li><code>x0</code>	initial guess; need <code>length(x) == size(B[j],2)</code> for <span>$j=1...J$</span></li></ul><p>Usually <code>x0</code> is a <code>Vector</code> but it can be an <code>Array</code> if each <code>B_j</code> is a linear operator (e.g., <code>LinearMapAO</code>) of suitable &quot;dimensions&quot;.</p><p>option</p><ul><li><code>niter</code>	# number of outer iterations; default 50</li><li><code>ninner</code>	# number of inner iterations of MM line search; default 5</li><li><code>P</code>		# preconditioner; default <code>I</code></li><li><code>betahow</code>	&quot;beta&quot; method for the search direction; default <code>:dai_yuan</code></li><li><code>fun</code>		User-defined function to be evaluated with two arguments (x,iter).<ul><li>It is evaluated at (x0,0) and then after each iteration.</li></ul></li></ul><p>output</p><ul><li><code>x</code>		final iterate</li><li><code>out</code>		<code>[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))</code><ul><li>(all 0 by default). This is an array of length <code>niter+1</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/algorithm/general/ncg.jl#L14-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}" href="#MIRT.ncg-Tuple{Function, Function, AbstractArray{&lt;:Number}}"><code>MIRT.ncg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(x,out) = ncg(grad, curv, x0, ...)</code></p><p>special case of <code>ncg</code> (nonlinear CG) for minimizing a cost function whose gradient is <code>grad(x)</code> and that has a quadratic majorizer with diagonal Hessian given by <code>curv(x)</code>. Typically <code>curv = (x) -&gt; L</code> where <code>L</code> is the Lipschitz constant of <code>grad</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/algorithm/general/ncg.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ndgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}" href="#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>MIRT.ndgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(xx,yy,zz) = ndgrid(x::AbstractVector{&lt;:Any}, y::..., z::...)</code> todo - improve?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/ndgrid.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ndgrid-Tuple{AbstractVector, AbstractVector}" href="#MIRT.ndgrid-Tuple{AbstractVector, AbstractVector}"><code>MIRT.ndgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(xx,yy) = ndgrid(x::AbstractVector{&lt;:Any}, y::AbstractVector{&lt;:Any})</code> todo - improve?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/ndgrid.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}" href="#MIRT.nufft_eltype-Tuple{Type{&lt;:Integer}}"><code>MIRT.nufft_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nufft_eltype(::DataType)</code></pre><p>ensure plan_nfft eltype is Float32 or Float64</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/nufft.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_errors-Tuple{}" href="#MIRT.nufft_errors-Tuple{}"><code>MIRT.nufft_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">w, errs = nufft_errors( ; M=?, w=?, N=?, n_shift=?, ...)</code></pre><p>Compute NUFFT approximation errors (for signal of length <code>N</code> of unit norm), for given digital frequency values <code>w</code>, i.e., Ω.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/errors.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}" href="#MIRT.nufft_init-Tuple{AbstractArray{&lt;:Real}, Int64}"><code>MIRT.nufft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=0)</code></pre><p>Setup 1D NUFFT, for computing fast <span>$O(N \log N)$</span> approximation to</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m] (n - n_{shift})), m=1,…,M$</span></p><p>in</p><ul><li><code>w::AbstractArray{&lt;:Real}</code> <code>[M]</code> frequency locations (aka Ω, units radians/sample)<ul><li><code>eltype(w)</code> determines the <code>plan_nfft</code> type; so to save memory use Float32!</li><li><code>size(w)</code> determines <code>odim</code> for <code>A</code> if <code>operator=true</code></li></ul></li><li><code>N::Int</code> signal length</li></ul><p>option</p><ul><li><code>nfft_m::Int</code>		see NFFT.jl documentation; default 4</li><li><code>nfft_sigma::Real</code>	&quot;&quot;, default 2.0</li><li><code>n_shift::Real</code>		often is N/2; default 0</li><li><code>pi_error::Bool</code>		throw error if <span>$|w| &gt; π$</span>, default <code>true</code><ul><li>Set to <code>false</code> only if you are very sure of what you are doing!</li></ul></li><li><code>do_many::Bool</code>	support extended inputs via <code>map_many</code>? default <code>true</code></li><li><code>operator::Bool=true</code> set to <code>false</code> to make <code>A</code> an <code>LinearMapAM</code></li></ul><p>out</p><ul><li><code>p NamedTuple</code></li></ul><p><code>(nufft = x -&gt; nufft(x), adjoint = y -&gt; nufft_adj(y), A::LinearMapAO)</code></p><p>The default settings are such that for a 1D signal of length N=512, the worst-case error is below 1e-5 which is probably adequate for typical medical imaging applications. To verify this statement, run <code>nufft_plot1()</code> and see plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/nufft.jl#L42-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D" href="#MIRT.nufft_init-Union{Tuple{D}, Tuple{AbstractArray{&lt;:Real}, Tuple{Vararg{Int64, D}}}} where D"><code>MIRT.nufft_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = nufft_init(w, N ; nfft_m=4, nfft_sigma=2.0, pi_error=true, n_shift=?)</code></pre><p>Setup multi-dimensional NUFFT, for computing fast <span>$O(N \log N)$</span> approximation to</p><p><span>$X[m] = \sum_{n=0}^{N-1} x[n] \exp(-i w[m,:] (n - n_{shift})), m=1,…,M$</span></p><p>in</p><ul><li><code>w::AbstractArray{&lt;:Real}</code> <code>[M,D]</code> frequency locations (aka Ω, units radians/sample)</li></ul><pre><code class="nohighlight hljs">+ `eltype(w)` determines the `plan_nfft` type; so to save memory use Float32!
+ `size(w)[1:(end-1)]` determines `odim` if `operator=true`</code></pre><ul><li><code>N::Dims{D}</code> signal dimensions</li></ul><p>option</p><ul><li><code>nfft_m::Int</code>		see NFFT.jl documentation; default 4</li><li><code>nfft_sigma::Real</code>	&quot;&quot;, default 2.0</li><li><code>n_shift::AbstractVector{&lt;:Real}</code>	<code>[D]</code>	often is N/2; default zeros(D)</li><li><code>pi_error::Bool</code>		throw error if <span>$|w| &gt; π$</span>, default <code>true</code><ul><li>Set to <code>false</code> only if you are very sure of what you are doing!</li></ul></li><li><code>do_many::Bool</code>	support extended inputs via <code>map_many</code>? default <code>true</code></li><li><code>operator::Bool=true</code> set to <code>false</code> to make <code>A</code> an <code>LinearMapAM</code></li></ul><p>The default <code>do_many</code> option is designed for parallel MRI where the k-space sampling pattern applies to every coil. It may also be useful for dynamic MRI with repeated sampling patterns. The coil and/or time dimensions must come after the spatial dimensions.</p><p>out</p><ul><li><code>p NamedTuple</code> with fields</li></ul><pre><code class="nohighlight hljs">`nufft = x -&gt; nufft(x), adjoint = y -&gt; nufft_adj(y), A=LinearMapAO`
(Using `operator=true` allows the `LinearMapAO` to support `do_many`.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/nufft.jl#L127-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T" href="#MIRT.nufft_typer-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>MIRT.nufft_typer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nufft_typer(T::DataType, x::AbstractArray{&lt;:Real} ; warn::Bool=true)</code></pre><p>type conversion wrapper for <code>nfft()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/nufft/nufft.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}" href="#MIRT.ogm_ls-Tuple{AbstractVector, AbstractVector{&lt;:Function}, AbstractVector{&lt;:Function}, AbstractArray{&lt;:Number}}"><code>MIRT.ogm_ls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ogm_ls(B, gradf, curvf, x0; niter=?, ninner=?, fun=?)</code></pre><p>OGM with a line search; Drori&amp;Taylor @arxiv 1803.05676; to minimize a general &quot;inverse problem&quot; cost function of the form <span>$\Psi(x) = \sum_{j=1}^J f_j(B_j x)$</span> where each function <span>$f_j(v)$</span> has a quadratic majorizer of the form</p><p class="math-container">\[q_j(v;u) = f_j(u) + \nabla f_j(u) (v - u) + 1/2 \|v - u\|^2_{C_j(u)}\]</p><p>where <span>$C_j(u)$</span> is diagonal matrix of curvatures. (It suffices for each <span>$f_j$</span> to have a Lipschitz smooth gradient.)</p><p>This OGM method uses a majorize-minimize (MM) line search.</p><p>in</p><ul><li><code>B</code>		array of <span>$J$</span> blocks <span>$B_1,...,B_J$</span></li><li><code>gradf</code>	array of <span>$J$</span> functions return gradients of <span>$f_1,...,f_J$</span></li><li><code>curvf</code>	array of <span>$J$</span> functions <code>z -&gt; curv(z)</code> that return a scalar</li></ul><p>or a vector of curvature values for each element of <span>$z$</span></p><ul><li><code>x0</code>	initial guess; need <code>length(x) == size(B[j],2)</code> for <span>$j=1...J$</span></li></ul><p>option</p><ul><li><code>niter</code>	# number of outer iterations; default 50</li><li><code>ninner</code>	# number of inner iterations of MM line search; default 5</li><li><code>fun</code>		User-defined function to be evaluated with two arguments (x,iter).</li><li>It is evaluated at (x0,0) and then after each iteration.</li></ul><p>output</p><ul><li><code>x</code>		final iterate</li><li><code>out</code>		<code>[niter+1] (fun(x0,0), fun(x1,1), ..., fun(x_niter,niter))</code><ul><li>(all 0 by default). This is an array of length <code>niter+1</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/algorithm/general/ogm_ls.jl#L12-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}" href="#MIRT.ogm_ls-Tuple{Function, Function, AbstractVector{&lt;:Number}}"><code>MIRT.ogm_ls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(x,out) = ogm_ls(grad, curv, x0, ...)</code></pre><p>special case of <code>ogm_ls</code> (OGM with line search) for minimizing a cost function whose gradient is <code>grad(x)</code> and that has a quadratic majorizer with diagonal Hessian given by <code>curv(x)</code>. Typically <code>curv = (x) -&gt; L</code> where <code>L</code> is the Lipschitz constant of <code>grad</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/algorithm/general/ogm_ls.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.pogm_restart-Tuple{Any, Function, Function, Real}" href="#MIRT.pogm_restart-Tuple{Any, Function, Function, Real}"><code>MIRT.pogm_restart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x, out = pogm_restart(x0, Fcost, f_grad, f_L ;
f_mu=0, mom=:pogm, restart=:gr, restart_cutoff=0.,
bsig=1, niter=10, g_prox=(z,c)-&gt;z, fun=...)</code></pre><p>Iterative proximal algorithms (PGM=ISTA, FPGM=FISTA, POGM) with restart.</p><p><strong>in</strong></p><ul><li><code>x0</code> initial guess</li><li><code>Fcost</code> function for computing the cost function value <span>$F(x)$</span><ul><li>(needed only if <code>restart === :fr</code>)</li></ul></li><li><code>f_grad</code> function for computing the gradient of <span>$f(x)$</span></li><li><code>f_L</code> Lipschitz constant of the gradient of <span>$f(x)$</span></li></ul><p><strong>option</strong></p><ul><li><code>f_mu</code> strong convexity parameter of <span>$f(x)$</span>; default 0.<ul><li>if <code>f_mu &gt; 0</code>, <span>$(\alpha, \beta_k, \gamma_k)$</span> is chosen by Table 1 in [KF18]</li></ul></li><li><code>g_prox</code> function <code>g_prox(z,c)</code> for the proximal operator for <span>$g(x)$</span><ul><li><code>g_prox(z,c)</code> computes <span>$argmin_x 1/2 \|z-x\|^2 + c \, g(x)$</span></li></ul></li><li><code>mom</code>	momentum option<ul><li><code>:pogm</code> POGM (fastest); default!</li><li><code>:fpgm</code> (FISTA), <span>$\gamma_k = 0$</span></li><li><code>:pgm</code> PGM (ISTA), <span>$\beta_k = \gamma_k = 0$</span></li></ul></li><li><code>restart</code> restart option<ul><li><code>:gr</code> gradient restart; default!</li><li><code>:fr</code> function restart</li><li><code>:none</code> no restart</li></ul></li><li><code>restart_cutoff</code> for <code>:gr</code> restart if cos(angle) &lt; this; default 0.</li><li><code>bsig</code> gradient &quot;gamma&quot; decrease option (value within [0 1]); default 1<ul><li>see <span>$\bar{\sigma}$</span> in [KF18]</li></ul></li><li><code>niter</code> number of iterations; default 10</li><li><code>fun</code> function<code>(iter, xk, yk, is_restart)</code> user-defined function evaluated each <code>iter</code> with secondary <code>xk</code>, primary <code>yk</code>, and boolean <code>is_restart</code> indicating whether this iteration was a restart</li></ul><p><strong>out</strong></p><ul><li><code>x</code>	final iterate<ul><li>for PGM (ISTA): <span>$x_N = y_N$</span></li><li>for FPGM (FISTA): primary iterate <span>$y_N$</span></li><li>for POGM: secondary iterate <span>$x_N$</span>, see [KF18]</li></ul></li><li><code>out [fun(0, x0, x0, false), fun(1, x1, y1, is_restart), ...]</code> array of length <code>[niter+1]</code></li></ul><p>Optimization Problem: Nonsmooth Composite Convex Minimization</p><ul><li><span>$argmin_x F(x),  F(x) := f(x) + g(x))$</span><ul><li><span>$f(x)$</span> smooth convex function</li><li><span>$g(x)$</span> convex function, possibly nonsmooth and &quot;proximal-friendly&quot; [CP11]</li></ul></li></ul><p><strong>Optimization Algorithms:</strong></p><p>Accelerated First-order Algorithms when <span>$g(x) = 0$</span> [KF18] iterate as below for given coefficients <span>$(\alpha, \beta_k, \gamma_k)$</span></p><ul><li>For k = 0,1,...<ul><li><span>$y_{k+1} = x_k - \alpha  f&#39;(x_k)$</span> : gradient update</li><li><span>$x_{k+1} = y_{k+1} + \beta_k  (y_{k+1} - y_k) + \gamma_k  (y_{k+1} - x_k)$</span> : momentum update</li></ul></li></ul><p>Proximal versions of the above for <span>$g(x) \neq 0$</span> are in the below references, and use the proximal operater <span>$prox_g(z) = argmin_x {1/2\|z-x\|^2 + g(x)}$</span>.</p><ul><li>Proximal Gradient method (PGM or ISTA) - <span>$\beta_k = \gamma_k = 0$</span>. [BT09]</li><li>Fast Proximal Gradient Method (FPGM or FISTA) - <span>$\gamma_k = 0$</span>. [BT09]</li><li>Proximal Optimized Gradient Method (POGM) - [THG15]</li><li>FPGM(FISTA) with Restart - [OC15]</li><li>POGM with Restart - [KF18]</li></ul><p><strong>references</strong></p><ul><li>[CP11] P. L. Combettes, J. C. Pesquet,</li></ul><p>&quot;Proximal splitting methods in signal processing,&quot;  Fixed-Point Algorithms for Inverse Problems in Science and Engineering,  Springer, Optimization and Its Applications, 2011.</p><ul><li>[KF18] D. Kim, J.A. Fessler,</li></ul><p>&quot;Adaptive restart of the optimized gradient method for convex optimization,&quot; 2018  Arxiv:1703.04641,  [http://doi.org/10.1007/s10957-018-1287-4]</p><ul><li>[BT09] A. Beck, M. Teboulle:</li></ul><p>&quot;A fast iterative shrinkage-thresholding algorithm for linear inverse problems,&quot;  SIAM J. Imaging Sci., 2009.</p><ul><li>[THG15] A.B. Taylor, J.M. Hendrickx, F. Glineur,</li></ul><p>&quot;Exact worst-case performance of first-order algorithms  for composite convex optimization,&quot; Arxiv:1512.07516, 2015,  SIAM J. Opt. 2017  [http://doi.org/10.1137/16m108104x]</p><p>Copyright 2017-3-31, Donghwan Kim and Jeff Fessler, University of Michigan 2018-08-13 Julia 0.7.0 2019-02-24 interface redesign</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/algorithm/general/pogm_restart.jl#L17-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.poweriter-Tuple{Any}" href="#MIRT.poweriter-Tuple{Any}"><code>MIRT.poweriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">v1,σ1 = poweriter(A; niter=?, ...)</code></pre><p>Determine first right singular vector <code>v1</code> and first singular value <code>σ1</code> of <code>A</code> by applying power iteration to <code>A&#39;A</code></p><p>in</p><ul><li><code>A</code> M × N matrix</li></ul><p>option</p><ul><li><code>niter</code> default 200</li><li><code>x0</code> initial guess of <code>v1</code></li><li><code>tol</code> stopping tolerance for s1, default 1e-6</li><li><code>chat::Bool</code> verbose? default false</li></ul><p>out</p><ul><li><code>v1</code> <code>[N]</code> principal right singular vector</li><li><code>σ1</code> spectral norm of <code>A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/algorithm/general/poweriter.jl#L11-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rect-Tuple{Real}" href="#MIRT.rect-Tuple{Real}"><code>MIRT.rect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rect(x::Real)</code></pre><p>Unit width rect function. Potential problem? Bring up with fess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/rect.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}" href="#MIRT.reverser-Tuple{AbstractArray, AbstractVector{&lt;:Int64}}"><code>MIRT.reverser</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = reverser(x, dims)</code></pre><p>reverse array along specified dimensions (or all if unspecified)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/reverser.jl#L10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}" href="#MIRT.rmsd100-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}}"><code>MIRT.rmsd100</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmsd = rmsd100(x, y ; mask)</code></pre><p>Compute 100 * RMSD (root mean squared difference) between <code>x</code> and <code>y</code> within domain mask.</p><p>in</p><ul><li><code>x</code> : array</li><li><code>y</code> : another array of same size</li></ul><p>option:</p><ul><li><code>mask::Array{Bool}</code> : domain over which to compute the RMSE; default <code>trues(size(x))</code></li></ul><p>out</p><ul><li>rmsd : rmsd of <code>x</code> vs <code>y</code> within <code>mask</code> in %</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/utility/rmsd100.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.rotate2d-Tuple{Any, Any, Any}" href="#MIRT.rotate2d-Tuple{Any, Any, Any}"><code>MIRT.rotate2d</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(xr,yr) = rotate2d(x, y, theta)</code> 2D rotation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/fbp/rotate2d.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}" href="#MIRT.snr2sigma-Tuple{Any, AbstractArray{&lt;:Complex}}"><code>MIRT.snr2sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snr2sigma(db, yb)</code></pre><p>Convert SNR in dB to noise σ for complex gaussian noise. No <code>sqrt(2)</code> factors is needed here because <code>randn(Complex{Float})</code> already accounts for that. (See <code>randn</code> documentation.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JeffFessler/MIRT.jl/blob/2558a6eb83af2225f38e9f5ca3799ea3bc4efd5d/src/mri/coil_compress.jl#L51-L58">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/1-mirt/">« MIRT overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 25 October 2022 16:23">Tuesday 25 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
